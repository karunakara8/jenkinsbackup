webpackJsonp([5,7,8,9],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminState = _interopRequire(__webpack_require__(181));
	
	var ArtifactState = _interopRequire(__webpack_require__(290));
	
	var BuildsState = _interopRequire(__webpack_require__(338));
	
	var BundlesState = _interopRequire(__webpack_require__(351));
	
	var HomeModule = _interopRequire(__webpack_require__(354));
	
	var OAuthErrorModule = _interopRequire(__webpack_require__(365));
	
	var notFound404 = _interopRequire(__webpack_require__(366));
	
	var Forbidden403 = _interopRequire(__webpack_require__(367));
	
	var Login = _interopRequire(__webpack_require__(368));
	
	var ChangePassword = _interopRequire(__webpack_require__(370));
	
	var ForgotPassword = _interopRequire(__webpack_require__(372));
	
	var UserProfile = _interopRequire(__webpack_require__(375));
	
	var ServerError5XX = _interopRequire(__webpack_require__(377));
	
	var ServerDown = _interopRequire(__webpack_require__(378));
	
	var BaseState = _interopRequire(__webpack_require__(380));
	
	var Search = _interopRequire(__webpack_require__(382));
	
	var MODULE_PACKAGE_NATIVE = __webpack_require__(387).MODULE_PACKAGE_NATIVE;
	
	angular.module("artifactory.states", [AdminState.name, ArtifactState.name, BuildsState.name, BundlesState.name, HomeModule.name, OAuthErrorModule.name, notFound404.name, Forbidden403.name, Login.name, ChangePassword.name, ForgotPassword.name, UserProfile.name, ServerDown.name, ServerError5XX.name, BaseState.name, Search.name, MODULE_PACKAGE_NATIVE, "artifactory.services", "artifactory.dao", "cfp.hotkeys", "ui.router"]).run(changeStateHook);
	
	function changeStateHook(User, $rootScope, $q, JFrogNotifications, $location, $timeout, $state, TreeBrowserDao, ArtifactoryFeatures, FooterDao, ArtifactoryState, JFrogEventBus, OnBoardingWizard) {
	
	    var EVENTS = JFrogEventBus.getEventsDefinition();
	
	    JFrogEventBus.register(EVENTS.USER_LOGOUT, function (confirmDiscard) {
	        if (confirmDiscard === true) {
	            checkDiscardConfirmation($q).then(function () {
	                JFrogEventBus.dispatch(EVENTS.USER_LOGOUT);
	            });
	        }
	    });
	
	    $rootScope.$on("$locationChangeStart", function (e, newUrl) {
	        if (ArtifactoryState.getState("confirmDiscardModalOpen")) {
	            e.preventDefault();
	        }
	    });
	
	    $rootScope.$on("$locationChangeSuccess", function () {
	        if (window.ga) {
	            var gaTrackPage = ArtifactoryState.getState("gaTrackPage");
	            if (gaTrackPage && typeof gaTrackPage === "function") gaTrackPage();
	        }
	    });
	
	    var pendingOnboarding = false;
	    var firstStateChange = true;
	    $rootScope.$on("$stateChangeStart", function (e, toState, toParams, fromState, fromParams) {
	        if (firstStateChange) {
	            var _ret = (function () {
	                firstStateChange = false;
	                pendingOnboarding = true;
	                var pending = { toState: toState, toParams: toParams, search: $location.search() };
	                OnBoardingWizard.isSystemOnboarding().then(function (onBoarding) {
	                    pendingOnboarding = false;
	                    var redirectFromBintray = !!(pending.search.client_id && pending.search.code && pending.search.scope);
	                    var ssoRedirect = !!pending.search.redirectTo && pending.toState.name === "login";
	                    var resetPassword = !!(pending.toState.name === "reset-password" && pending.search.key);
	                    if (onBoarding && !redirectFromBintray && !resetPassword && !ssoRedirect) {
	                        $state.go("home").then(function () {
	                            OnBoardingWizard.show();
	                        });
	                    } else {
	                        $state.go(pending.toState.name, pending.toParams).then(function () {
	                            $location.search(pending.search);
	                        });
	                    }
	                });
	                e.preventDefault();
	                return {
	                    v: undefined
	                };
	            })();
	
	            if (typeof _ret === "object") return _ret.v;
	        }
	        var onboardingWizardOpen = ArtifactoryState.getState("onboardingWizardOpen");
	        if (toState.name !== "home" && toState.name !== "admin.repositories.list.edit" && (pendingOnboarding || onboardingWizardOpen === true)) {
	            e.preventDefault();
	            return;
	        }
	
	        if (fromState.name.startsWith("admin.") || fromState.name === "user_profile") {
	            if (!ArtifactoryState.getState("confirmDiscardModalOpen")) {
	                checkDiscardConfirmation($q, e).then(function () {
	                    $state.go(toState.name, toParams);
	                });
	            } else {
	                e.preventDefault();
	                return;
	            }
	        }
	        var saveAdminState = ArtifactoryState.getState("saveAdminState");
	
	        if (toState.name.startsWith("admin.") && !toState.name.match(/(?:.new|.edit)\b/) && saveAdminState && !e.defaultPrevented) {
	            ArtifactoryState.setState("lastAdminState", toState);
	            ArtifactoryState.setState("lastAdminStateParams", toParams);
	            ArtifactoryState.removeState("saveAdminState");
	        } else if (saveAdminState && !e.defaultPrevented) {
	            ArtifactoryState.removeState("saveAdminState");
	        }
	
	        if (fromState.name && toState.name && fromState.name != toState.name) {
	            JFrogEventBus.dispatch(EVENTS.CANCEL_SPINNER);
	        }
	
	        if (toState.name === "artifacts.browsers.search") {
	            //MOVED FROM artifacts.module.js to prevent error message (ui-router bug workaround)
	            JFrogEventBus.dispatch(EVENTS.SEARCH_URL_CHANGED, toParams);
	        } else if (fromState.name === "artifacts.browsers.search") {
	            JFrogEventBus.dispatch(EVENTS.CLEAR_SEARCH);
	        }
	
	        if (fromState.name.startsWith("artifacts.browsers.")) {
	            TreeBrowserDao.invalidateRoots();
	        }
	
	        if (toState.name === "change-password" && !toParams.username) {
	            e.preventDefault();
	            $state.go("login");
	        }
	
	        if (toState.name === "oauth_error") {
	            e.preventDefault();
	
	            var message = $location.search().message;
	            var gotoState = localStorage.stateBeforeOAuth;
	
	            if (gotoState === "login") {
	                $state.go(gotoState, { oauthError: message, location: "replace" });
	            } else if (gotoState === "user_profile") {
	                JFrogNotifications.create({ error: message });
	                $state.go(gotoState, { location: "replace" });
	            } else {
	                JFrogNotifications.create({ error: message });
	                $state.go("home", { location: "replace" });
	            }
	        }
	
	        if (toState.name.match(/^builds/) && !User.getCurrent().getCanDeploy()) {
	            toParams.tab = "published";
	        }
	
	        if (toState.name === "login" && $location.path() !== "/login" && $location.path() !== "/forgot-password" && $location.path() !== "/change-password" && $location.path() !== "/oauth_error" && !$location.path().startsWith("/resetpassword") && !$location.path().startsWith("/404") && !$location.path().startsWith("/403")) {
	            var afterLogin = ArtifactoryState.getState("urlAfterLogin");
	            if (!afterLogin) ArtifactoryState.setState("urlAfterLogin", $location.path());
	        }
	
	        // Permissions:
	
	        if (!User.getCurrent().canView(toState.name, toParams)) {
	            if (User.getCurrent().isProWithoutLicense()) {
	                $timeout(function () {
	                    return $location.path("admin/configuration/register_pro");
	                });
	            } else {
	                if ($location.path() !== "/login") ArtifactoryState.setState("urlAfterLogin", $location.path());
	                e.preventDefault();
	                if (User.getCurrent().name === "anonymous") {
	                    JFrogNotifications.create({ error: "You are not authorized to view this page" });
	                    $timeout(function () {
	                        return $location.path("/login");
	                    });
	                } else {
	                    $timeout(function () {
	                        return $location.path("/403");
	                    });
	                }
	            }
	        }
	        // Features per license:
	        else {
	            (function () {
	                var feature = toParams.feature;
	                // Must verify footer data is available before checking (for initial page load)
	                FooterDao.get().then(function () {
	                    if (ArtifactoryFeatures.isDisabled(feature) || ArtifactoryFeatures.isHidden(feature)) {
	                        JFrogNotifications.create({ error: "Page unavailable" });
	                        e.preventDefault();
	                        $timeout(function () {
	                            return $location.path("/home");
	                        });
	                    }
	                });
	            })();
	        }
	
	        if (!e.defaultPrevented) {
	            JFrogEventBus.dispatch(EVENTS.CLOSE_MODAL);
	            if (ArtifactoryState.getState("clearErrorsOnStateChange")) {
	                ArtifactoryState.removeState("clearErrorsOnStateChange");
	                JFrogEventBus.dispatch(EVENTS.CLOSE_NOTIFICATIONS);
	            }
	        }
	    });
	}
	
	function checkDiscardConfirmation($q, e) {
	
	    var defer = $q.defer();
	    var forms = $("form");
	    var changeDiscovered = false;
	    for (var i = 0; i < forms.length; i++) {
	        var _ret = (function (i) {
	            var form = forms[i];
	            var controller = angular.element(form).controller();
	            if (controller && controller._$modelSaver$_ && controller._$modelSaver$_.confirmOnLeave && !controller._$modelSaver$_.isModelSaved()) {
	                changeDiscovered = true;
	
	                controller._$modelSaver$_.ask().then(function () {
	                    controller._$modelSaver$_.confirmOnLeave = false;
	                    defer.resolve();
	                });
	
	                return "break";
	            }
	        })(i);
	
	        if (_ret === "break") break;
	    }
	
	    if (!changeDiscovered && !e) {
	        defer.resolve();
	    } else if (changeDiscovered && e) {
	        e.preventDefault();
	    }
	
	    return defer.promise;
	}

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var events = {
	    ACTIVATE_TREE_SEARCH: "tree:search:activate",
	    TREE_SEARCH_CHANGE: "tree:search:change",
	    TREE_NODE_SELECT: "tree:node:select",
	    TREE_NODE_OPEN: "tree:node:open",
	    TREE_SEARCH_KEYDOWN: "tree:search:keydown",
	    TREE_SEARCH_CANCEL: "tree:search:cancel",
	    TREE_SEARCH_EDIT: "tree:search:edit",
	    TREE_SEARCH_RUNNING: "tree:search:running",
	    TREE_COMPACT: "tree:compact",
	    TREE_REFRESH: "tree:refresh",
	    TREE_REFRESH_SORTING: "tree:refresh:sorting",
	    TREE_REFRESH_FILTER: "tree:refresh:filter",
	    TREE_REFRESH_FAVORITES: "tree:refresh:favorites",
	    TREE_NODE_CM_REFRESH: "tree:node:cm:refresh",
	    TREE_COLLAPSE_ALL: "tree:collapse:all",
	    TREE_DATA_IS_SET: "tree:hasdata",
	    SEARCH_COLLAPSE: "search:collapse",
	    SEARCH: "search",
	    CLEAR_SEARCH: "search:clear",
	
	    ACTION_WATCH: "action:watch", // node
	    ACTION_UNWATCH: "action:unwatch", // node
	    ACTION_COPY: "action:copy", // node, target
	    ACTION_MOVE: "action:move", // node, target
	    ACTION_COPY_STASH: "action:copystash", // repoKey
	    ACTION_MOVE_STASH: "action:movestash", // repoKey
	    ACTION_DISCARD_STASH: "action:discardstash", //
	    ACTION_DISCARD_FROM_STASH: "action:discardfromstash", //node
	    ACTION_REFRESH_STASH: "action:refreshstash", //
	    ACTION_EXIT_STASH: "action:exitstash", //
	    ACTION_DELETE: "action:delete", // node
	    ACTION_DELETE_CONTENT: "action:delete:content", // node
	    ACTION_REFRESH: "action:refresh", // node
	    ACTION_DEPLOY: "action:deploy", // repoKey
	    ACTION_FAVORITES: "action:markfavorites",
	    DO_FAVORITES: "action:dofavorites",
	
	    BUILDS_TAB_REFRESH: "builds:tab:refresh",
	
	    FOOTER_DATA_UPDATED: "footer:data:updated",
	
	    SHOW_SPINNER: "spinner:show",
	    HIDE_SPINNER: "spinner:hide",
	    CANCEL_SPINNER: "spinner:cancel",
	
	    USER_CHANGED: "user:changed",
	    USER_LOGOUT: "user:logout", //confirmDiscard (true/false)
	
	    TAB_NODE_CHANGED: "tabs:node:changed",
	
	    SEARCH_URL_CHANGED: "search:url:changed",
	
	    FOOTER_REFRESH: "footer:refresh",
	
	    REFRESH_SETMEUP_WIZARD: "refresh:setmeup:wizard",
	
	    REFRESH_PAGE_CONTENT: "refresh:page:content" };
	
	module.exports = events;

/***/ }),
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	    API_URL: "../ui",
	    AUTH_LOGIN: "/auth/login?_spring_security_remember_me=",
	    AUTH_CURRENT: "/auth/current",
	    AUTH_LOGOUT: "/auth/logout",
	    AUTH_IS_SAML: "/auth/issaml",
	    AUTH_REDIRECT: "/auth/redirect?redirectTo=",
	    AUTH_FORGOT_PASSWORD: "/auth/forgotpassword",
	    AUTH_VALIDATE_KEY: "/auth/validatetoken?key=",
	    AUTH_RESET_PASSWORD: "/auth/resetpassword?key=",
	    AUTH_LOGIN_DATA: "/auth/loginRelatedData",
	    AUTH_CAN_ANNOTATE: "/auth/canAnnotate?repoKey=",
	    BASIC_CONFIG: "/basicConfig",
	    CRYPTO: "/crypto",
	    SECURITY_CONFIG: "/securityconfig",
	    USERS: "/users",
	    GROUPS: "/groups",
	    GROUP_PERMISSION: "/groupPermission",
	    MAIL: "/mail",
	    REGISTER_PRO: "/registerlicense",
	    MANAGE_HA_LICENSES: "/manageLicenses",
	    PROXIES: "/proxies",
	    REVERSE_PROXIES: "/reverseProxies",
	    HTTPSSO: "/httpsso",
	    SSHSERVER: "/sshserver",
	    LICENSES: "/licenses",
	    HIGH_AVAILABILITY: "/highAvailability",
	    XRAY: "/xrayRepo",
	    XRAY_CONFIG: "/xrayConfig",
	    SAML_CONFIG: "/saml/config",
	    SAML_DOWNLOAD_ENCRYPTED_ASSERTION_CERT: "/saml/config/key/public",
	    SAML_LOGOUT: "/saml/logoutRequest",
	    OAUTH_LOGIN: "/oauth2/loginRequest",
	    BINTRAY_SETTING: "/bintraysetting",
	    PROPERTY_SETS: "/propertysets",
	    BROWSE_FILESYSTEM: "/browsefilesystem",
	    BACKUP: "/backup",
	    SYSTEM_INFO: "/systeminfo",
	    CONFIG_DESCRIPTOR: "/configdescriptor",
	    SECURITY_DESCRIPTOR: "/securitydescriptor",
	    INDEXER: "/indexer",
	    STORAGE_SUMMARY: "/storagesummary",
	    TREE_BROWSER: "/treebrowser",
	    REPO_DATA: "/repodata",
	    CRON_TIME: "/crontime",
	    DATE_FORMAT: "/validations/dateformat",
	    NAME_VALIDATOR: "/validations/name",
	    UNIQUE_ID_VALIDATOR: "/validations/uniqueid",
	    XML_NAME_VALIDATOR: "/validations/xmlname",
	    ARTIFACT_PERMISSIONS: "/artifactpermissions",
	    ARTIFACT_GENERAL: "/artifactgeneral",
	    ARTIFACT_GENERAL_BINTRAY: "/artifactgeneral/bintray",
	    ARTIFACT_GENERAL_BINTRAY_DIST: "/artifactgeneral/bintray/dist",
	    ARTIFACT_VIEW_SOURCE: "/archiveViewSource",
	    ARTIFACT_BUILDS: "/artifactbuilds",
	    ARTIFACT_XRAY: "/artifactxray",
	    ARTIFACT_ACTIONS: "/artifactactions",
	    ARTIFACT_PROPERTIES: "/artifactproperties",
	    PREDEFINE_VALUES: "/predefinevalues",
	    REPO_PROPERTY_SET: "/repopropertyset",
	    ARTIFACT_WATCHES: "/artifactwatches",
	    ARTIFACT_SEARCH: "/artifactsearch",
	    DEPENDENCY_DECLARATION: "/dependencydeclaration",
	    ARTIFACT: "/artifact",
	    FOOTER: "/auth/screen/footer",
	    VIEWS: "/views",
	    CROWD: "/crowd",
	    EXPORT: "/artifactexport",
	    IMPORT: "/artifactimport",
	    MAINTENANCE: "/maintenance",
	    LDAP: "/ldap",
	    OAUTH: "/oauth",
	    CHECKSUMS: "/checksums",
	    FILTERED_RESOURCE: "/filteredResource",
	    LDAP_GROUPS: "/ldapgroups",
	    PUSH_TO_BINTRAY: "/pushToBintray",
	    BINTRAY_DISTRIBUTION: "/distribution",
	    GENERAL_CONFIG: "/generalConfig",
	    ONBOARDING: "/onboarding",
	    SIGNINGKEYS: "/signingkeys",
	    TRUSTEDKEYS: "/security/trustedKeys",
	    SSLCERTIFICATES: "/admin/security/certificates",
	    ACCESSTOKENS: "/admin/security/accesstokens",
	    KEYSTORE: "/keystore",
	    USER_PROFILE: "/userProfile",
	    SSH_CLIENT: "/sshClient",
	    USER_API_KEY: "/userApiKey",
	    BUILDS: "/builds",
	    BUNDLES: "/bundles",
	    BUILDS_INFO: "/buildsinfo", /// JUST FOR MOCK, WILL BE REMOVED
	    PERMISSION_TARGETS: "/permissiontargets",
	    GENERAL_TAB_LICENSES: "/generalTabLicenses",
	    HOME_PAGE: "/home",
	    SYSTEM_LOGS: "/systemlogs",
	    SET_ME_UP: "/setMeUp",
	    SET_ME_UP_MAVEN: "/setMeUp/mavenSettings",
	    SET_ME_UP_GRADLE: "/setMeUp/gradleSettings",
	    SET_ME_UP_IVY: "/setMeUp/ivySettings",
	    SET_ME_UP_MAVEN_DISTRIBUTION: "/setMeUp/mavenDistributionManagement",
	    SET_ME_UP_MAVEN_SNIPPET: "/setMeUp/mavenSnippet",
	    SET_ME_UP_GRADLE_SNIPPET: "/setMeUp/gradleSnippet",
	    SET_ME_UP_IVY_SNIPPET: "/setMeUp/ivySnippet",
	    SET_ME_UP_REVERSE_PROXY_DATA: "/setMeUp/reverseProxyData",
	    REPOSITORIES: "/admin/repositories",
	    REPOSITORIES_LAYOUTS: "/admin/repolayouts",
	    STASH_RESULTS: "/stashResults",
	    SUPPORT_PAGE: "/userSupport",
	    SERVER_TIME: "/system/serverTime",
	    LICENSE_DETAILS: "/system/license",
	    BINARY_PROVIDERS_INFO: "/binary/providers/info",
	    DOCKER_STATUS: "/admin/repositories/getdockerstatus",
	    GLOBAL_REPLICATIONS_BLOCK: "/global/replications/config",
	    SUMOLOGIC: "/sumologic",
	    JCR_EULA: "/jcr/eula",
	    JCR_NEWSLETTER: "/jcr/subscription",
	    MINI_XRAY: "/jcr/xray" };

/***/ }),
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	                admin: {
	                                advanced: {
	                                                maintenance: {
	                                                                garbageCronExpression: "The Cron expression that determines the frequency of garbage collection.\nFor detailed information, see <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                cleanupCronExpression: "The Cron expression that determines the frequency of artifacts cleanup.\nFor detailed information, see <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                runNow: "Remove unreferenced binaries from the underlying datastore.\nArtifactory periodically runs garbage collection to remove unused (deleted) binaries from the datastore.\nYou may also run datastore cleanup manually using this button.",
	                                                                enableQuotaControl: "Enable control over the amount of storage space used for binaries to avoid running out of disk space.",
	                                                                storageSpaceLimit: "The maximum percentage of disk capacity that the partition containing the binaries folder is allowed to use.\nOnce this limit has been reached, deployment is rejected with a 413 error (request entity\ntoo large) and an error message is displayed in the UI (visible to admin users only).\nWhen using filesystem storage, the partition checked is the one containing the\n'$ARTIFACTORY_HOME/data/filestore' directory.\nWhen using database BLOB storage, the partition checked is the one containing the\n'$ARTIFACTORY_HOME/data/cache' directory.",
	                                                                storageSpaceWarning: "The percentage of disk space usage, by the partition containing the binaries folder, that will trigger a warning.\nOnce this limit is reached a warning is logged and a warning message is displayed in the UI\n(visible to admin users only).",
	                                                                cronExpressionCleanup: "The Cron expression that determines the frequency at which unused artifacts are cleaned up. For detailed information, see <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                runUnusedCachedArtifactsCleanup: "Remove unused artifacts from all remote repository caches\naccording to the 'Keep Unused Artifacts(Hours)' setting for each remote repository.\nArtifactory periodically cleans up unused artifacts from all remote repository caches.\nYou can also run the cleanup manually using this button.",
	                                                                cleanVirtualRepositoriesNow: "Clean up internal data used by virtual repositories.\nCached POM files older than the number of hours defined in the 'virtualCacheCleanup.maxAgeHours' system property will be deleted.\nThe default is 168 hours (one week). Artifacts accessed through virtual repositories will not be affected by this.",
	                                                                compressTheInternetDatabase: "When using the internal Derby database, use this to clean up fragmented space that may remain\nafter delete operations.\nNOTE! It is recommended to run this when Artifactory activity is low because compression may not run its full course when\nstorage is busy (although this has no detrimental effect on the storage).",
	                                                                pruneUnreferencedData: "Running Artifactory with the wrong file system permissions on storage folders, or running out of storage space,\ncan result in unreferenced binary files and empty folders present in the filestore or cache folders. This action\nremoves unreferenced files and empty folders."
	
	                                                },
	                                                storageSummary: {
	                                                                itemsCount: "The total number of items (both files and folders) in your system.",
	                                                                optimization: "The ratio of Binaries Size to Artifacts Size.\nThis reflects how much the usage of storage in your system has been reduced by Artifactory using checksum storage.",
	                                                                artifactsCount: "The total number of artifacts pointing to the physical binaries stored on your system.",
	                                                                storageDirectory: "If Storage Type is \"filesystem\" then this is the path to the physical file store.\nIf Storage Type is \"fullDb\" then this is the path to the directory that caches binaries when they are extracted from the database.\nIf Storage Type is \"S3\" then this is the path to the directory that caches binaries from S3.\n\nIf Storage Type is \"Advanced Configuration\" then these are the paths of the corresponding binary providers, supplied by the advanced configuration.",
	                                                                centralConfigurationDescriptor: "",
	                                                                securityConfigurationDescriptor: "",
	                                                                fileSystemStorage: "The storage percentage represents the used/available space on the mount point where the <a href=\"https://www.jfrog.com/confluence/display/RTF/Monitoring+Storage#MonitoringStorage-FileStore\" target=\"_blank\">Artifactory filestore data</a> is stored."
	                                                }
	                                },
	                                configuration: {
	                                                general: {
	                                                                serverName: "A name that uniquely identifies this artifactory server instance across the network.",
	                                                                customURLBase: "A hard-coded URL prefix used to calculate relative URLs.",
	                                                                fileUploadMaxSize: "The maximum size (in MB) allowed for artifacts uploaded through the web UI.\nSet to '0' for unlimited size.",
	                                                                bintrayMaxFilesUpload: "The maximum number of files that can be uploaded to Bintray in a single operation.",
	                                                                dateFormat: "The format used to display dates.\nFor a detailed explanation see: <a href=\"http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html\" target=\"_blank\">Joda DateTimeFormat</a>",
	                                                                globalOfflineMode: "If set, Artifactory does not try to access remote resources to fetch artifacts.\nOnly cached and local artifacts are served",
	                                                                showAvailableAddonsInfo: "When set, Artifactory displays information about available Add-ons. This overrides any user-specific setting to hide information.",
	                                                                folderDownloadMaxFiles: "The maximum amount of artifacts that can be downloaded under one folder.",
	                                                                folderDownloadMaxSize: "The maximum size (in MB) of a folder that is allowed to be downloaded.",
	                                                                folderDownloadMaxParallel: "The maximum amount of folder download requests Artifactory will allow to run together.",
	                                                                retentionPeriodDays: "The maximum number of days to keep artifacts in the trashcan.",
	                                                                allowPermDeletes: "When deleting, users will be given an option to bypass the trash can and delete artifacts permanently.",
	                                                                blockReplications: "When set, replication will not be triggered regardless of configuration.",
	                                                                blockPushReplications: " When set, push replication will not be triggered regardless of configuration.",
	                                                                blockPullReplications: "When set, pull replication will not be triggered regardless of configuration.",
	                                                                releaseBundlesCleanup: "The number of hours to wait before a release bundle is deemed “incomplete” and eligible for cleanup from the temporary folder. A value of 0 means automatic cleanup is disabled. \nNote that only release bundles that were partially distributed are eligible for cleanup.",
	                                                                signedUrlMaxValidForSecs: "The maximum number of seconds a signed URL can be valid.",
	                                                                downloadRedirectFileMinimumSize: "The minimal size of an artifact for which direct download from the cloud is enabled.\nRequests for artifacts smaller than this size are served through Artifactory as usual."
	                                                },
	                                                licenseForm: {
	                                                                licenseKey: "A unique short name identifying the license.",
	                                                                longName: "A descriptive name for the license.",
	                                                                URLs: "A URL (or URLs separated by semicolon) pointing to the license's homepage.",
	                                                                regExp: "A regular expression used to match licenses of this type against license details in artifact module information.\nFor regular expression syntax reference please refer to the Pattern javadoc."
	
	                                                },
	                                                propertySetsForm: {},
	                                                proxyForm: {
	                                                                systemDefault: "Make this proxy the default for new remote repositories and for internal HTTP requests.",
	                                                                redirectingProxyTargetHosts: "An optional list of host names to which the proxy may redirect requests.\nThe credentials of the proxy are reused by requests redirected to any of these hosts."
	
	                                                },
	                                                reverseProxy: {
	                                                                serverName: "The server name that will be used to access Artifactory.\nShould be correlated with the base URL value.",
	                                                                publicAppContext: "The path which will be publicly used to access Artifactory. If Artifactory is accessible on the root of the server leave empty.",
	                                                                artifactoryServerName: "The internal server name for Artifactory which will be used by the web server to access the Artifactory machine.\nIf the web server is installed on the same machine as Artifactory you can use localhost, otherwise use the IP or hostname.",
	                                                                artifactoryAppContext: "The path which will be used to access the Artifactory application. If Artifactory is accessible on the root of the server leave empty.",
	                                                                sslCertificate: "The full path of the certificate file on the web server.",
	                                                                sslKey: "The full path of the key file on the web server."
	                                                },
	                                                mail: {
	                                                                enable: "The activity state of the configuration.",
	                                                                from: "The \"from\" address header to use in all outgoing messages (optional). ",
	                                                                subjectPrefix: "A prefix to use for the subject of all outgoing messages.",
	                                                                artifactoryURL: "The Artifactory URL to to link to in all outgoing messages (optional)."
	                                                },
	                                                bintray: {
	                                                                bintrayUsername: "The default Bintray user name that will be used by Artifactory in cases where an Artifactory\nuser doesn't have Bintray credentials defined.",
	                                                                bintrayAPIKey: "The default Bintray API Key that will be used by Artifactory in cases where an Artifactory\nuser doesn't have Bintray credentials defined."
	                                                },
	                                                registerPro: {
	                                                                licenseKey: "The license key is required for using Artifactory Add-ons."
	                                                },
	                                                xray: {
	                                                                allowDownloadsBlocked: "Allows download of all artifacts, even those that<br>have been blocked for download by Xray.",
	                                                                allowWhenXrayUnavilable: "Overrides Artifactory’s default behavior of blocking artifact<br>download when Xray becomes unavailable.",
	                                                                bypassDefaultProxy: "Bypass the default system proxy configuration.",
	                                                                overrideDefaultProxy: "Choose a Proxy configuration to override the default system proxy.",
	                                                                blockUnscannedTimeoutSeconds: "When a repository is configured to block downloads of unscanned artifacts, this setting will \nmake every download request connection to remain open for the time configured (in seconds), allowing Xray sufficient time to scan the artifact and then return the artifact or block it based on scan results."
	                                                }
	                                },
	                                import_export: {
	                                                repositories: {
	                                                                createM2CompatibleExport: "Include Maven 2 repository metadata and checksum files as part of the export",
	                                                                outputVerboseLog: "Lowers the log level to debug and redirects the output from the standard log to the import-export log.\nYou can monitor the log in the <a href=\"./#/admin/advanced/system_logs\">'System Logs'</a> page.",
	                                                                targetLocalRepository: "Specifies the repository in which to place imported content.\nWhen importing to a single repository, the file structure within the folder you import from should be similar to:\nSELECTED_DIR\n|\n|--LIB_DIR_1\nBut when importing to all repositories, the file structure within the folder you import from should be similar to:\nSELECTED_DIR\n|\n|--REPOSITORY_NAME_DIR_1\n| |\n| |--LIB_DIR_1\n\nWhen importing to all repositories, make sure the names of the directories representing\nthe repositories in the archive, match the names of the target repositories in Artifactory.",
	                                                                repositoryZipFile: "The archive file from which to import content.\nWhen importing to a single repository, the file structure within the archive should be similar to:\nARCHIVE.ZIP\n|\n|--LIB_DIR_1\nWhen importing to all repositories, the file structure within the archive you import from should be similar to:\nARCHIVE.ZIP\n|\n|--REPOSITORY_NAME_DIR_1\n| |\n| |--LIB_DIR_1\nWhen importing to all repositories, make sure the names of the directories representing\nthe repositories in the archive, match the names of the target repositories in Artifactory.\nNOTE! Uploading the archive, does not import its content.\nTo import, select the Target Local Repository, upload the archive and click Import."
	                                                },
	                                                system: {
	                                                                excludeBuilds: "Exclude all builds from the export.",
	                                                                createM2CompatibleExport: "Include Maven 2 repository metadata and checksum files as part of the export.",
	                                                                outputVerboseLog: "Lowers the log level to debug and redirects the output from the standard log to the import-export log.\nYou can monitor the log in the <a href=\"./#/admin/advanced/system_logs\">'System Logs'</a> page."
	
	                                                },
	                                                stash: {
	                                                                createM2CompatibleExport: "Include Maven 2 repository metadata and checksum files as part of the export.",
	                                                                outputVerboseLog: "Lowers the log level to debug and redirects the output from the standard log to the import-export log.\nYou can monitor the log in the <a href=\"./#/admin/advanced/system_logs\">'System Logs'</a> page.",
	                                                                createArchive: "Export the results as a zip archive."
	                                                }
	                                },
	                                repositories: {
	                                                customURLBase: "A hard-coded URL prefix used to calculate relative URLs.",
	                                                localForm: {
	                                                                publicDescription: "Textual description of the repository. This description is displayed when the repository is selected in the Tree Browser.",
	                                                                internalDescription: "Additional notes that are only displayed in this form.",
	                                                                includesPattern: "List of artifact patterns to include when evaluating artifact requests in the form of x/y/**/z/*. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included (**/*).",
	                                                                excludedPattern: "List of artifact patterns to exclude when evaluating artifact requests, in the form of x/y/**/z/*. By default no artifacts are excluded.",
	                                                                repositoryLayout: "The layout that the repository should use to store and identify modules.",
	                                                                checksumPolicy: "Checksum policy determines how Artifactory behaves when a client checksum for a deployed resource is missing or conflicts with the locally calculated checksum (bad checksum).\nFor more details, please refer to <a href=\"https://www.jfrog.com/confluence/display/RTF/Local+Repositories#LocalRepositories-ChecksumPolicy\">Checksum Policy</a>.",
	                                                                mavenSnapshotVersionBehavior: "Specifies the naming convention for Maven SNAPSHOT versions.\nThe options are -\nUnique: Version number is based on a time-stamp (default)\nNon-unique: Version number uses a self-overriding naming pattern of artifactId-version-SNAPSHOT.type\nDeployer: Respects the settings in the Maven client that is deploying the artifact.",
	                                                                maxUniqueSnapshots: "The maximum number of unique snapshots of a single artifact to store.\nOnce the number of snapshots exceeds this setting, older versions are removed.\nA value of 0 (default) indicates there is no limit, and unique snapshots are not cleaned up.",
	                                                                maxUniqueTags: "The maximum number of unique tags of a single Docker image to store in this repository.\nOnce the number tags for an image exceeds this setting, older tags are removed. A value of 0 (default) indicates there is no limit.",
	                                                                blackedOut: "When set, the repository does not participate in artifact resolution and new artifacts cannot be deployed.",
	                                                                yumMetadataFolderDepth: "The depth, relative to the repository's root folder, where RPM metadata is created.\nThis is useful when your repository contains multiple RPM repositories under parallel hierarchies.\nFor example, if your RPMs are stored under 'fedora/linux/$releasever/$basearch', specify a depth of 4.",
	                                                                yumGroupFileNames: "A list of XML file names containing RPM group component definitions.\nArtifactory includes the group definitions as part of the calculated RPM metadata, as well as automatically generating a gzipped version of the group files, if required.",
	                                                                allowContentBrowsing: "When set, you may view content such as HTML or Javadoc files directly from Artifactory.\nThis may not be safe and therefore requires strict content moderation to prevent malicious users from uploading content that may compromise security (e.g., cross-site scripting attacks).",
	                                                                selectPropertySets: "Specifies the Property Sets to be used to construct the list of properties displayed when assigning properties to artifacts in this repository.\nThis is a convenience; not a restrictive measure. You can still assign any property to artifacts from the Properties tab.",
	                                                                cronExpressionReplication: "The Cron expression that determines when the next replication will be triggered. For detailed information, see <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                nextReplicationTime: "The next replication time based on the Cron expression.",
	                                                                enableEventReplication: "When set, each event will trigger replication of the artifacts changed in the event (e.g. add, delete, change property).",
	                                                                trivialLayout: "When set, the repository will use the deprecated trivial layout.",
	                                                                forceNugetAuth: "Force basic authentication credentials in order to use this repository.",
	                                                                pathPrefix: "Limit replication to artifacts matching this sub-path under the source repository.",
	                                                                syncDeletedArtifacts: "When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).",
	                                                                syncArtifactProperties: "When set, properties of replicated artifacts and folders will also be replicated.",
	                                                                syncArtifactStatistics: "When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.",
	                                                                dockerBlockPushingSchema1: "When set, Artifactory will block the pushing of Docker images with manifest v2 schema 1 to this repository.",
	                                                                priorityResolution: "Setting Priority Resolution takes precedence over the resolution order when resolving virtual repositories. \nSetting repositories with priority will cause metadata to be merged only from repositories set with a priority. If a package is not found in those repositories, Artifactory will merge from repositories marked as non-priority." },
	                                                remoteForm: {
	                                                                publicDescription: "Textual description of the repository.\nThis description is displayed when the repository is selected in the Tree Browser.",
	                                                                internalDescription: "Additional notes that are only displayed in this form. ",
	                                                                includesPattern: "List of artifact patterns to include when evaluating artifact requests in the form of x/y/**/z/*. When used, only artifacts matching one of the include patterns are served.\nBy default, all artifacts are included (**/*).",
	                                                                nuGetDownloadContextPath: "The context path prefix through which NuGet downloads are served.\nFor example, the NuGet Gallery download URL is 'https://nuget.org/api/v2/package', so the repository\nURL should be configured as 'https://nuget.org' and the download context path should be configured as 'api/v2/package'.",
	                                                                v3FeedUrl: "The URL to the NuGet v3 feed.\nFor example the feed URL for the official nuget.org repository is (also the default value): \n\"https://api.nuget.org/v3/index.json\"",
	                                                                eagerlyFetchJars: "When marked, the repository attempts to eagerly fetch the jar in the background each time a POM is requested.",
	                                                                eagerlyFetchSources: "When marked, the repository attempts to eagerly fetch the source jar in the background each time a jar is requested.",
	                                                                excludedPattern: "List of artifact patterns to exclude when evaluating artifact requests, in the form of x/y/**/z/*.\nBy default no artifacts are excluded.",
	                                                                dockerEnableTokenAuthentication: "Enable token (Bearer) based authentication.",
	                                                                checksumPolicy: "Checksum policy determines how Artifactory behaves when a client checksum for a deployed resource is missing or conflicts with the locally calculated checksum (bad checksum).\nFor more details, please refer to <a href=\"https://www.jfrog.com/confluence/display/RTF/Remote+Repositories#RemoteRepositories-ChecksumPolicy\">Checksum Policy</a>.",
	                                                                maxUniqueSnapshots: "The maximum number of unique snapshots of a single artifact to store.\nOnce the number of snapshots exceeds this setting, older versions are removed.\nA value of 0 (default) indicates there is no limit, and unique snapshots are not cleaned up.",
	                                                                listRemoteFolderItems: "Lists the items of remote folders in simple and list browsing. Required for dynamic resolution that depends on remote folder content information, such as remote Ivy version lookups. The remote content is cached according to the value of the\n'Retrieval Cache Period'.",
	                                                                blackedOut: "When set, the repository or its local cache do not participate in artifact resolution.",
	                                                                globalOfflineMode: "If set, Artifactory does not try to access remote resources to fetch artifacts. Only cached and local artifacts are served.",
	                                                                offline: "If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.",
	                                                                shareConfiguration: "If set, the configuration details of this remote repository can be publicly shared with remote clients such as other Artifactory servers.",
	                                                                repositoryLayout: "The layout that the repository should use to store and identify modules.",
	                                                                remoteLayoutMapping: "The layout that best matches that of the remote repository.\nPath-mapping takes place if the remote layout is different from the local layout.\nIn this case, remote module artifacts and descriptors are stored according to the local repository layout (e.g., Maven 1->Maven 2, or Maven 2->Ivy).",
	                                                                localAddress: "The local address to be used when creating connections.\nUseful for specifying the interface to use on systems with multiple network interfaces.",
	                                                                username: "Username for HTTP authentication.",
	                                                                password: "Password for HTTP authentication.",
	                                                                socketTimeout: "Network timeout (in ms) to use when establishing a connection and for unanswered requests.\nTiming out on a network operation is considered a retrieval failure.",
	                                                                lenientHostAuthentication: "Allow credentials of this repository to be used on requests redirected to any other host.",
	                                                                enableCookieManagement: "Enables cookie management if the remote repository uses cookies to manage client state.",
	                                                                keepUnusedArtifacts: "The number of hours to wait before an artifact is deemed \"unused\" and eligible for cleanup from the repository.\nA value of 0 means automatic cleanup of cached artifacts is disabled.",
	                                                                assumedOfflineLimit: "The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time, an online check is attempted in order to reset the offline status.\nA value of 0 means the repository is never assumed offline.",
	                                                                retrievalCachePeriod: "This value refers to the number of seconds to cache metadata files before checking for newer versions on remote server. A value of 0 indicates no caching.",
	                                                                missedRetrievalCachePeriod: "The number of seconds to cache artifact retrieval misses (artifact not found).     A value of 0 indicates no caching.",
	                                                                queryParams: "Custom HTTP query parameters that will be automatically included in all remote resource requests.\nFor example: param1=val1&ampparam2=val2&ampparam3=val3",
	                                                                allowContentBrowsing: "When set, you may view content such as HTML or Javadoc files directly from Artifactory.\nThis may not be safe and therefore requires strict content moderation to prevent malicious users from uploading content that may compromise security (e.g., cross-site scripting attacks).",
	                                                                storeArtifactsLocally: "When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory servers.",
	                                                                synchronizeArtifactoryProperties: "When set, remote artifacts are fetched along with their properties.",
	                                                                selectPropertySets: "Specifies the Property Sets to be used to construct the list of properties displayed when assigning properties to artifacts in this repository.\nThis is a convenience; not a restrictive measure. You can still assign any property to artifacts from the Properties tab.",
	                                                                cronExpression: "The Cron expression that determines artifact cleanup frequency. For detailed information, see <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                cronExpressionReplication: "The Cron expression that determines when the next replication will be triggered. For detailed information, see <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html\" target=\"_blank\">The CronTrigger Tutorial</a>.",
	                                                                syncDeletes: "Delete artifacts and folders that no longer exist in the source repository.",
	                                                                syncProperties: "When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.",
	                                                                pathPrefix: "Limit replication to artifacts matching this sub-path under the source repository.",
	                                                                bowerRegistryURL: "The remote Bower registry URL to communicate with.\nUsually the default value (https://bower.herokuapp.com) will be correct unless the remote resource is an Artifactory instance. In this case the value should match the remote repository URL.",
	                                                                nugetFeedContextPath: "The context path prefix through which the NuGet feeds are served.\nFor example, the NuGet Gallery feed URL is 'https://nuget.org/api/v2', so the repository URL should be configured as 'https://nuget.org' and the feed context path should be configured as 'api/v2'.",
	                                                                nugetDownloadContextPath: "The context path prefix through which NuGet downloads are served.\nFor example, the NuGet Gallery download URL is 'https://nuget.org/api/v2/package', so the repository\nURL should be configured as 'https://nuget.org' and the download context path should be configured as 'api/v2/package'.",
	                                                                smartSyncStatistics: "If set, download statistics for the artifact at the remote Artifactory instance will be updated each time a cached item is downloaded from your repository.",
	                                                                smartSyncProperties: "If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance.",
	                                                                smartListRemoteFolderItems: "If set, Artifactory lets you navigate the contents of the repository at the remote Artifactory instance, for all package types, even if the artifacts have not been cached in this repository.",
	                                                                originAbsenceDetection: "If set, Artifactory will check that cached artifacts' sources are available in the origin repository.",
	                                                                propagateQueryParams: "If set, the query params passed with the request to Artifactory, will be passed on to the remote repo.",
	                                                                rejectInvalidJars: "Reject the caching of jar files that are found to be invalid.\nFor example, pseudo jars retrieved behind a \"captive portal\".",
	                                                                enableEventReplication: "When set, in addition to running replication based on its Cron expression, each event on the remote repository will trigger replication of the artifacts changed in the event (e.g. add, delete, change property).\nTo set event replication, the remote replication source must be an Artifactory repository. The Artifactory version must be 5.5 or above.",
	                                                                enableEventReplicationDisabledNoEnterprise: "When set, in addition to running replication based on its Cron expression, each event on the remote repository will trigger replication of the artifacts changed in the event (e.g. add, delete, change property).\nTo set event replication, you need an Enterprise license.",
	                                                                blockMismatchingMimeTypes: "If set, artifacts will fail to download if a mismatch is detected between requested and received mimetype, according to the list specified in the system properties file under blockedMismatchingMimeTypes. You can override by adding mimetypes to the override list below.",
	                                                                bypassHeadRequests: "Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources, HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked, Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.",
	                                                                foreignLayersCachingPatterns: "Optional include patterns to match external URLs. Ant-style path expressions are supported (*, **, ?).\nFor example, specifying **/github.com/** will only allow downloading foreign layers from github.com host.",
	                                                                pypiRepositorySuffix: "Usually should be left as a default for 'simple', unless the remote is a PyPI server that has custom registry suffix, like +simple in DevPI",
	                                                                dockerBlockPushingSchema1: "When set, Artifactory will block the pulling of Docker images with manifest v2 schema 1 from the remote repository (i.e. the upstream). It will be possible to pull images with manifest v2 schema 1 that exist in the cache.",
	                                                                retrievalCacheTimeout: "This value refers to the number of seconds to wait for retrieval from the remote before serving locally cached artifact or fail the request" },
	                                                virtualForm: {
	                                                                publicDescription: "Textual description of the repository.\nThis description is displayed when the repository is selected in the Tree Browser.",
	                                                                internalDescription: "Additional notes that are only displayed in this form. ",
	                                                                cleanupRepositoryReferencesinPOM: "(1) Discard Active References - Removes repository elements that are declared directly under project or under a profile in the same POM that is activeByDefault.\n(2) Discard Any References - Removes all repository elements regardless of whether they are included in an active profile or not.\n(3) Nothing - Does not remove any repository elements declared in the POM.",
	                                                                pathSuffix: "An optional sub-path inside the local repository where P2 metadata files reside.\nWhen left empty, P2 metadata files (content, artifacts, compositeContent, etc.) are assumed to reside directly under the repository's root.\nIf you have a Tycho repository deployed as a single archive, specify the archive's root path. For example: 'eclipse-repository.zip!'. ",
	                                                                includesPattern: "List of artifact patterns to include when evaluating artifact requests in the form of x/y/**/z/*. When used, only artifacts matching one of the include patterns are served.\nBy default, all artifacts are included (**/*).",
	                                                                excludedPattern: "List of artifact patterns to exclude when evaluating artifact requests, in the form of x/y/**/z/*.\nBy default no artifacts are excluded.",
	                                                                resolvedRepositories: "The resolved list of repositories.\nRepositories starting with an exclamation mark ('!') indicate that not all tokens can be mapped between the layout of this virtual repository and the marked repository.\nPath translations may not work as expected.",
	                                                                artifactoryRequestCanRetrieveRemoteArtifacts: "Determines whether artifact requests coming from other instance of Artifactory can be fulfilled by accessing this virtual repository's remote repositories, or by only accessing its caches (default).",
	                                                                resolveDockerTagsByTimestamp: "When enabled, in cases where the same Docker tag exists in two or more of the aggregated repositories, Artifactory will return the tag that has the latest timestamp.",
	                                                                externalDependenciesPatterns: "Optional include patterns to match external dependencies. Ant-style path expressions are supported (*, **, ?).\nFor example, specifying **/github.com/** will only allow external dependencies from github.com host.",
	                                                                externalDependenciesPatternsGo: "An allow list of Ant-style path patterns that determine which remote VCS roots Artifactory will follow to download remote modules from, when presented with 'go-import' meta tags in the remote repository response. By default, this is set to '**', which means that remote modules may be downloaded from any external VCS source.",
	                                                                enableGoImportMetaTag: "When checked (default), Artifactory will automatically follow remote VCS roots in 'go-import' meta tags to download remote modules.",
	                                                                cleanupRepositoryReferencesInPOMs: "(1) Discard Active References - Removes repository elements that are declared directly under a project or a profile in the same POM that is activeByDefault.\n(2) Discard Any References - Removes all repository elements regardless of whether they are included in an active profile or not.\n(3) Nothing - Does not remove any repository elements declared in the POM.",
	                                                                virtualRetrievalCachePeriod: "This value refers to the number of seconds to cache metadata files before checking for newer versions on aggregated repositories. A value of 0 indicates no caching.",
	                                                                virtualDebianDefaultArchitectures: "Specifies the architectures which will be indexed for the included remote repositories, For example: i386, arm64.",
	                                                                keyPair: "A named key-pair that is used to sign artifacts automatically.",
	                                                                forceMavenAuth: "User authentication is required when accessing the repository. An anonymous request will display an HTTP 401 error. This is also enforced when aggregated repositories support anonymous requests."
	
	                                                },
	                                                distributionForm: {
	                                                                includesPattern: "Properties on distributed artifacts with key that matches the list below will be added as a version attributes in Bintray.",
	                                                                repositoryVisibility: "Creating private Bintray repositories is available for <a href=\"https://www.jfrog.com/bintray/bintray-private-repo/\" target=\"_blank\">premium Bintray</a> accounts.",
	                                                                distributeProduct: "When set, the ${productName} token will be replaced in the distribution rules with the product name configured below. Also, Artifactory will create a <a href=\"https://bintray.com/docs/usermanual/uploads/uploads_products.html\" target=\"_blank\">Bintray product</a> and link the deployed packages to the product."
	                                                },
	                                                layoutsForm: {
	                                                                artifactPathPattern: "Please refer to: <a href=\"https://www.jfrog.com/confluence/display/RTF/Repository+Layouts#RepositoryLayouts-ModulesandPathPatternsusedbyRepositoryLayouts\" target=\"_blank\">Path Patterns</a> in the Artifactory Wiki documentation.",
	                                                                distinctiveDescriptorPathPattern: "Please refer to: <a href=\"https://www.jfrog.com/confluence/display/RTF/Repository+Layouts#RepositoryLayouts-DescriptorPathPatterns\" target=\"_blank\">Descriptor Path Patterns</a> in the Artifactory Wiki documentation.",
	                                                                folderIntegrationRevisionRegExp: "A regular expression matching the integration revision string appearing in a folder name\nas part of the artifact's path. For example, 'SNAPSHOT', in Maven.\nNote! Take care not to introduce any regexp capturing groups within this expression.\nIf not applicable use '.*'.",
	                                                                fileIntegrationRevisionRegExp: "A regular expression matching the integration revision string appearing in a file name\nas part of the artifact's path. For example, 'SNAPSHOT|(?:(?:[0-9]{8}.[0-9]{6})-(?:[0-9]+))',\nin Maven.\nNote! Take care not to introduce any regexp capturing groups within this expression.\nIf not applicable use '.*'."
	                                                },
	                                                reverseProxy: {
	                                                                registryPort: "This port will be binded to the Docker registry."
	                                                },
	                                                rulesPopup: {
	                                                                repositoryFilterTooltip: "<b>Repository Filter</b> -(Optional) Rule will only apply to repositories matching the regular expression." + "You can reuse the capture values in anyone of the Bintray output fields. <a href=\"https://www.jfrog.com/confluence/display/RTF/Distribution+Repository#DistributionRepository-RepositoryandPathFilterParameters\" target=\"_blank\"> Click here </a> to read more about this field.",
	                                                                pathFilterToolip: "<b>Path Filter</b> - (Optional) Rule will only apply to artifacts with path matching the regular expression" + "You can reuse the capture values in anyone of the Bintray output fields. <a href=\"https://www.jfrog.com/confluence/display/RTF/Distribution+Repository#DistributionRepository-RepositoryandPathFilterParameters\" target=\"_blank\"> Click here </a> to read more about this field." },
	                                                downloadRedirectConfig: "When set, download requests to this repository will redirect the client to download the artifact directly from the cloud storage provider. Available in Enterprise+ and Edge licenses only."
	                                },
	                                security: {
	                                                general: {
	                                                                hideExistenceOfUnauthorizedResources: "When set, Artifactory hides the existence of unauthorized resources by sending a 404\nresponse (not found) to requests for resources that are not accessible by the user. Otherwise,\nthe response implies that the resource exists, but is protected,  by requesting authentication\nfor anonymous requests (401), or by denying an authenticated request for unauthorized users.",
	                                                                passwordEncryptionPolicy: "Determines the password requirements from users identified to Artifactory from a remote client such as Maven.\nThe options are:\n(1) Supported (default): Users can authenticate using secure encrypted passwords or clear-text passwords.\n(2) Required: Users must authenticate using secure encrypted passwords. Clear-text authentication fails.\n(3) Unsupported: Only clear-text passwords can be used for authentication.",
	                                                                buildGlobalBasicReadAllowed: "When checked, all users can view the published modules for all builds in the system regardless of any specific permissions applied to a particular build.",
	                                                                encrypt: "Artifactory will generate a Master Encryption Key and encrypt all passwords in your configuration.",
	                                                                decrypt: "Artifactory will decrypt all passwords in your configuration.",
	                                                                passwordMaxAge: "The time interval in which users will be obligated to change their password",
	                                                                notifyByMail: "Users will receive an email notification X days before password will expire.\nMail server must be enabled and configured correctly."
	                                                },
	                                                usersForm: {
	                                                                disableInternalPassword: "When set, user's password is cleared which means that only external authentication is allowed (for example via an LDAP server)."
	                                                },
	                                                permissionsForm: {
	                                                                repoPatterns: "Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\nAnt-style path expressions are supported (*, **, ?).\nFor example: \"org/apache/**\"",
	                                                                buildPatterns: {
	                                                                                includePatterns: "Use Ant-style wildcard patterns to specify build names (i.e. artifact paths) in the build info repository (without a leading slash) that will be included in this permission target.\nAnt-style path expressions are supported (*, **, ?).\nFor example, an \"apache/**\" pattern will include the \"apache\" build info in the permission.",
	                                                                                excludePatterns: "Use Ant-style wildcard patterns to specify build names (i.e. artifact paths) in the build info repository (without a leading slash) that will be excluded from this permission target.\nAnt-style path expressions are supported (*, **, ?).\nFor example, an \"apache/**\" pattern will exclude the \"apache\" build info from the permission."
	                                                                },
	                                                                adminIcon: {
	                                                                                user: "Users with admin privileges cannot be added to a Permission Target",
	                                                                                group: "Groups with admin privileges cannot be added to a Permission Target" },
	
	                                                                repositoriesPermissions: "<b>Read</b> - Allows reading and downloading of artifacts\n<b>Annotate</b> - Allows annotating artifacts and folders with metadata and properties\n<b>Upload / Cache</b> - Allows uploading artifacts to local repositories and caching artifacts from remote repositories\n<b>Delete / Overwrite</b> - Allows deletion or overwriting of artifacts\n<b>Manage</b> - Allows changing repository permission settings for other users on this permission target",
	                                                                buildsPermissions: "<b>Read</b> - Allows reading and downloading of build info artifacts and viewing the corresponding build in the Builds page\n<b>Annotate</b> - Allows annotating build info artifacts and folders with metadata and properties\n<b>Upload</b> - Allows uploading and promoting build info artifacts\n<b>Delete</b> - Allows deletion of build info artifacts\n<b>Manage</b> -  Allows changing build info permission settings for other users on this permission target\n" },
	                                                LDAPSettingsForm: {
	                                                                LDAPURL: "Location of the LDAP server in the following format:\nldap://myserver:myport/dc=sampledomain,dc=com",
	                                                                allowUserToAccessProfile: "Auto created users will have access to their profile page and will be able to perform actions such as generating an API key.",
	                                                                userDNPattern: "A DN pattern that can be used to log users directly in to LDAP.\nThis pattern is used to create a DN string for 'direct' user authentication where the pattern is relative to the base DN in the LDAP URL.\nThe pattern argument {0} is replaced with the username. This only works if anonymous binding is allowed and a direct user DN can\nbe used, which is not the default case for Active Directory (use User DN search filter instead).\nExample: uid={0},ou=People",
	                                                                pagingSupportEnabled: "When set, supports paging results for the LDAP server. This feature requires that the LDAP server supports a PagedResultsControl configuration.",
	                                                                autoCreateArtifactoryUsers: "When set, users are automatically created when using LDAP. Otherwise, users are transient\nand associated with auto-join groups defined in Artifactory.",
	                                                                emailAttribute: "An attribute that can be used to map a user's email address to a user created\nautomatically in Artifactory.",
	                                                                searchFilter: "A filter expression used to search for the user DN used in LDAP authentication.\nThis is an LDAP search filter (as defined in 'RFC 2254') with optional arguments.\nIn this case, the username is the only argument, and is denoted by '{0}'.\nPossible examples are:\n(uid={0}) - This searches for a username match on the attribute.\nAuthentication to LDAP is performed from the DN found if successful.",
	                                                                searchBase: "(Optional) A context name to search in relative to the base DN of the LDAP URL. For example, 'ou=users'\nWith the LDAP Group Add-on enabled, it is possible to enter multiple search base entries\nseparated by a pipe ('|') character.",
	                                                                manageDN: "The full DN of the user that binds to the LDAP server to perform user searches.\nOnly used with \"search\" authentication.\n",
	                                                                managerPassword: "The password of the user that binds to the LDAP server to perform the search.\nOnly used with \"search\" authentication.",
	                                                                subTreeSearch: "When set, enables deep search through the sub tree of the LDAP URL + search base."
	                                                },
	                                                LDAPGroupsForm: {
	                                                                settingsName: "LDAP group key.",
	                                                                LDAPSetting: "Select the LDAP setting you want to use for group retrieval",
	                                                                "static": "Groups have a multi-value member attribute containing user DNs or User IDs.",
	                                                                dynamic: "Users have a mutli-value member attribute containing DNs or names of imported groups.\nDefault group association strategy for Active Directory.",
	                                                                hierarchy: "User DN contains one or more hierarchical name attributes of imported groups.\nFor example: cn=joe,ou=sales,ou=europe,dc=acme,dc=com implies Joe's membership in the 'sales' and 'europe' groups.",
	                                                                groupMemberAttribute: "A multi-value attribute on the group entry containing user DNs or IDs of the group members (e.g., uniqueMember,member).",
	                                                                groupNameAttribute: "Attribute on the group entry denoting the group name. Used when importing groups.",
	                                                                descriptionAttribute: "An attribute on the group entry which denoting the group description. Used when importing groups.",
	                                                                filter: "The LDAP filter used to search for group entries. Used when importing groups.",
	                                                                searchBase: "A search base for group entry DNs, relative to the DN on the LDAP server's URL (and not relative to the LDAP Setting's \"Search Base\"). Used when importing groups."
	                                                },
	                                                crowd_integration: {
	                                                                sessionValidationInterval: "The time window (min) during which the session does not need to be validated.",
	                                                                useJIRAUserServer: "Authenticate using credentials instead of the default session, token-based authentication.\nThis is required when using the JIRA User Server.",
	                                                                autoCreateArtifactoryUsers: "When set, authenticated users are automatically created in Artifactory.\nWhen not set, for every request from a Crowd user, the user is temporarily associated with default groups (if such groups are defined),\nand the permissions for these groups apply. Without automatic user creation, you must manually create the user in Artifactory to manage\nuser permissions not attached to their default groups.",
	                                                                allowUserToAccessProfile: "Auto created users will have access to their profile page and will be able to perform actions such as generating an API key.",
	                                                                useDefaultProxyConfiguration: "If a default proxy definition exists, it is used to pass through to the Crowd Server."
	
	                                                },
	                                                SAMLSSOSettings: {
	                                                                SAMLLoginURL: "The identity provider login URL (when you try to login, the service provider redirects to this URL).",
	                                                                SAMLLogoutURL: "The identity provider logout URL (when you try to logout, the service provider redirects to this URL).",
	                                                                SAMLServiceProviderName: "The Artifactory name in the SAML federation.",
	                                                                SAMLCertificate: "The certificate for SAML Authentication.\nNOTE! The certificate must contain the public key to allow Artifactory to verify sign-in requests.",
	                                                                autoCreateArtifactoryUsers: "When set, authenticated users are automatically created in Artifactory.\nWhen not set, for every request from a SAML user, the user is temporarily associated with default groups (if such groups are defined),\nand the permissions for these groups apply. Without automatic user creation, you must manually create the user inside Artifactory to manage\nuser permissions not attached to their default groups.",
	                                                                allowUserToAccessProfile: "Auto created users will have access to their profile page and will be able to perform actions such as generating an API key.",
	                                                                useEncryptedAssertion: "When set, an X.509 public certificate will be created by Artifactory. Download this certificate and upload it to your IDP and choose your own encryption algorithm. This process will let you encrypt the assertion section in your SAML response.",
	                                                                autoRedirect: "When set, clicking on the login link will direct users to the configured SAML login URL.",
	                                                                syncGroups: "When set, in addition to the groups the user is already associated with, he will also be associated with the groups returned in the SAML login " + "response. Note that the user's association with the returned groups is not persistent. It is only valid for the current login session.",
	                                                                groupAttribute: "The group attribute in the SAML login XML response.",
	                                                                emailAttribute: "If Auto Create Artifactory Users is enabled or an internal user exists, Artifactory will set the user's email to the value in this attribute that is returned by the SAML login XML response.",
	                                                                verifyAudienceRestriction: "Set this flag to specify who the assertion is intended for. The \"audience\" will be the service provider and is typically a URL but can technically be formatted as any string of data."
	                                                },
	                                                OAuthSSO: {
	                                                                id: "Your OAuth2 id, given by the provider.",
	                                                                secret: "Your OAuth2 shared secret, given by the provider.",
	                                                                domain: "Google App domain accepted for authentication.",
	                                                                basicUrl: "The url used to acquire a token via basic auth.",
	                                                                authUrl: "The url used for the initial authentication step.",
	                                                                apiUrl: "The url used for api access, if needed to get user data.",
	                                                                tokenUrl: "The url used to acquire a token from the provider.",
	                                                                allowUserToAccessProfile: "Auto created users will have access to their profile page and will be able to perform actions such as generating an API key."
	                                                },
	                                                HTTPSSO: {
	                                                                artifactoryIsProxiedByASecureHTTPServer: "When set, Artifactory trusts incoming requests and reuses the remote user originally set on the request by the SSO of the HTTP server.\nThis is useful if you want to use existing enterprise SSO integrations, such as the powerful authentication schemes provided by Apache (mod_auth_ldap, mod_auth_ntlm, mod_auth_kerb, etc.).\nWhen Artifactory is deployed as a webapp on Tomcat behind Apache:\nIf using mod_jk, be sure to use the \"JkEnvVar REMOTE_USER\" directive in Apache's configuration.",
	                                                                remoteUserRequestVariable: "The name of the HTTP request variable to use for extracting the user identity.\nDefault is: REMOTE_USER.",
	                                                                autoCreateArtifactoryUsers: "When set, authenticated users are automatically created in Artifactory.\nWhen not set, for every request from an SSO user, the user is temporarily associated with default groups (if such groups are defined),\nand the permissions for these groups apply. Without automatic user creation, you must manually create the user inside Artifactory to manage\nuser permissions not attached to their default groups.",
	                                                                allowUserToAccessProfile: "Auto created users will have access to their profile page and will be able to perform actions such as generating an API key.",
	                                                                autoAssociateLDAPGroups: "When set, the user will be associated with the groups returned in the LDAP login response. Note that the user's association with the returned groups is persistent if the 'Auto Create Artifactory Users' is set."
	                                                },
	                                                SSHSERVER: {
	                                                                enableSshServer: "Enable SSH authentication.",
	                                                                serverPublicKey: "SSH Public Key to identify your server.",
	                                                                serverPrivateKey: "SSH Private Key to identify your server.",
	                                                                sshServerPort: "The port to use for SSH authentication. Default: 1337",
	                                                                customURLBase: "A hard-coded URL prefix used to calculate relative URLs."
	                                                },
	                                                signingKeys: {
	                                                                passPhrase: "Pass phrase required to use the installed keys. It can be saved or supplied with the REST API calls.\nThe \"Verify\" button checks that the keys and pass phrase match, and can be used to verify the pass phrase without saving it.\nIf keys are saved, we highly recommend using the Master Encryption Key feature."
	                                                }
	
	                                },
	                                services: {
	                                                backupsForm: {
	                                                                cronExpression: "The Cron expression that determines backup frequency. For detailed information, see <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html\" target=\"_blank\">The CronTrigger Tutorial</a>",
	                                                                serverPathForBackup: "The directory to which local repository data is backed up as files.\nThe default is $ARTIFACTORY_HOME/backup/[backup_key]",
	                                                                sendMailToAdminsIfThereAreBackupErrors: "Requires properly configured email settings and valid email addresses for admin users.",
	                                                                precalculateSpaceBeforeBackup: "If set, Artifactory will verify that the backup target location has enough disk space available to hold the backed up data. If there is not enough space available, Artifactory will abort the backup and write a message in the log file. Applicable only to non-incremental backups.",
	                                                                excludeBuilds: "Exclude all builds from the backup.",
	                                                                excludeNewRepositories: "Automatically exclude new repositories from the backup.",
	                                                                retentionPeriod: "The maximum number of hours to keep old backups in the destination directory.\nSetting the \"Incremental\" checkbox, indicates that backups are incrementally written\n(delta only) to the same directory: ${backupDir}/current. This \"in place\" backup is suitable\nfor file-system based backup support. In this mode, cleanup of old backups is inactive.\nThe default is 168 hours (7 days).",
	                                                                backUpToAZipArchive: "When set, the backup output should be a zip archive.\nOtherwise the output is to a directory (default)."
	
	                                                },
	                                                mavenIndexer: {
	                                                                cronExpression: "The Cron expression that determines indexer frequency. For detailed information, see <a href=\"https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html\" target=\"_blank\">The CronTrigger Tutorial</a>"
	                                                }
	                                },
	                                logAnalytics: {
	                                                newConnection: "Use this option if you don't have a Client ID and Secret for Artifactory."
	                                }
	                },
	                artifacts: {
	                                deploy: {
	                                                targetRepo: "The target repository to which the artifact should be deployed.",
	                                                targetPath: "The relative path in the target repository. You can add key-value matrix parameters to deploy the artifacts with properties.\nFor more details, please refer to <a href=\"https://www.jfrog.com/confluence/display/RTF/Using+Properties+in+Deployment+and+Resolution#UsingPropertiesinDeploymentandResolution-IntroducingMatrixParameters\" target=\"_blank\"> Introducing Matrix Parameters</a>.",
	                                                deployAsMaven: "Deploy a Maven artifact where the target deployment path is based on Maven attributes.\nIf you want to specify the target deployment path manually, unset this option.",
	                                                deployAsDebian: "Deploying a Debian file to a Debian repository requires coordinates. Setting this flag lets you configure the Debian file coordinates",
	                                                noDeployPermission: "You do not have deploy permission" },
	                                pushToBintray: {
	                                                bintrayPackageName: "A target package name under the repository. You must create the package in Bintray first if it does not exist.",
	                                                bintrayPackageVersion: "A target version under the package.If the version does not yet exist in Bintray, it is automatically created."
	                                },
	                                browse: {
	                                                created: "The time this artifact was deployed to or cached in Artifactory.",
	                                                lastModified: "The time this artifact was modified. If this value is not available, the artifact's 'Created' value is used.\nThis can occur if the artifact is deployed without the 'X-Artifactory-Last-Modified' request header.",
	                                                licenses: "Scans the archive for a textual license file. The following file names are searched for:\nlicense,LICENSE,license.txt,LICENSE.txt,LICENSE.TXT\n(You can override this list by using the 'artifactory.archive.licenseFile.names' property).",
	                                                filtered: "Set this to have Artifactory serve the file as a filtered resource.\nA filtered textual resource is processed by the <a href=\"https://freemarker.apache.org/\" target=\"_blank\">FreeMarker</a> engine before being returned to clients.\nThe context accessible to the template includes:\nProperties ,Security and Request. Javadocs can be found in the <a href=\"https://repo.jfrog.org/artifactory/libs-releases-local/org/artifactory/artifactory-papi/%5BRELEASE%5D/artifactory-papi-%5BRELEASE%5D-javadoc.jar!/index.html\" target=\"_blank\">Artifactory Public API</a>.",
	                                                lastReplicationStatus: "Displays the result of the latest run of this repository's scheduled replication.\nCan be one of the following:\nNever ran: Replication has not yet run.\nIncomplete: Replication has not yet completed or was interrupted.\nCompleted with errors: Replication errors were logged.\nCompleted with warnings: Replication warnings were logged.\nCompleted successfully: No errors or warnings logged.\nInconsistent: Replication status cannot be interpreted.",
	                                                recursive: "When checked, the property will be added to the selected folder and to all of the artifacts, folders and sub-folders under this folder."
	                                },
	                                search: {
	                                                stash: "The Stash lets you store search results for later use.\nOnce it is populated, you can add, subtract or intersect new search results to assemble just the right set of artifacts you need.\nThe Stash Browser displays all the artifacts in your stash and provides a convenient way to perform bulk operations.\nYou can copy or move the entire Stash to a repository, or perform actions on individual items."
	                                },
	
	                                general: {
	                                                /*name: 'Copy this link to navigate directly to this item in the tree browser.',*/
	                                                created: "The time this artifact was deployed to or cached in Artifactory",
	                                                filtered: "Set this to have Artifactory serve the file as a filtered resource.\nA filtered textual resource is processed by the <a href=\"https://freemarker.apache.org/\" target=\"_blank\">FreeMarker</a> engine before being returned to clients.\nThe context accessible to the template includes:\nProperties ,Security and Request. Javadocs can be found in the <a href=\"https://repo.jfrog.org/artifactory/libs-releases-local/org/artifactory/artifactory-papi/%5BRELEASE%5D/artifactory-papi-%5BRELEASE%5D-javadoc.jar!/index.html\" target=\"_blank\">Artifactory Public API</a>."
	                                },
	                                selectTargetPathModal: {
	                                                targetRepoInput: ["Selects the target repository for the transferred items.", "Repositories starting with an exclamation mark ('!') indicate that not all tokens", "can be mapped between the layouts of the source repository and the marked repository.", "Path translations may not work as expected."].join(" "),
	                                                copyToCustomCheckbox: {
	                                                                copy: ["Enable copying and renaming to a custom target path. WARNING: This will cause", "the operation to suppress cross-layout translation when copying to different layouts.", "This means that your client may not be able to resolve the artifacts even in cases of a same-layout move."].join(" "),
	                                                                move: ["Enable moving and renaming to a custom target path. WARNING: This will cause", "the operation to suppress cross-layout translation when moving to different layouts.", "This means that your client may not be able to resolve the artifacts even in cases of a same-layout move."].join(" ")
	                                                },
	                                                customPathInput: {
	                                                                copy: ["Type the path in the target repository where the selected source should be copied to.", "NOTE: Copy operations are executed using Unix conventions (e.g.copying org/jfrog/example from", "a source repository to org/jfrog/example in a target repository will result in the contents of the source", "being copied to org/jfrog/example/example). To achieve the same path in the target repository, copy", "the source into one folder up in the hierarchy (i.e. copy source org/jfrog/example into target org/jfrog).", "If you leave the Target Path empty, the source will be moved into the target repository's root folder."].join(" "),
	                                                                move: ["Type the path in the target repository where the selected source should be moved to.", "NOTE: Move operations are executed using Unix conventions (e.g. moving org/jfrog/example from", "a source repository to org/jfrog/example in a target repository will result in the contents of the source", "being moved to org/jfrog/example/example). To achieve the same path in the target repository, move", "the source into one folder up in the hierarchy (i.e. move source org/jfrog/example into target org/jfrog).", "If you leave the Target Path empty, the source will be moved into the target repository's root folder."].join(" ")
	                                                }
	
	                                }
	                },
	                builds: {
	                                summary: "An artifact license can have one of the following statuses:\nUnapproved: The license found is not approved.\nUnknown: License information was found but cannot be related to any license managed in Artifactory.\nNot Found: No license information could be found for the artifact.\nNeutral: The license found is not approved, however another approved license was found for the artifact.\nApproved: The license found is approved.",
	                                includePublishedArtifacts: "Include the build's published module artifacts in the license report if they are also used as dependencies for other modules in this build.",
	                                IncludeDependenciesOfTheFollowingScopes: "Include the build's published module dependencies in the license report.\nYou can optionally select the dependency scopes to include.",
	                                autoFindLicenses: "Automatically extract license data from artifacts' module information.\nWhen an artifact has conflicting licenses already attached, you can select whether\nto override these licenses with the ones found.",
	                                name: "The Code Center application name. Click on the link to navigate to this application in Code Center."
	                },
	                userProfile: {
	                                apiKey: "Your API key can be used to authenticate you when using the REST API.\nTo use the API key, add the following header to all REST API calls: 'X-JFrog-Art-Api: &ltYOUR_API_KEY&gt'"
	                }
	
	};

/***/ }),
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	    localChecksumPolicy: {
	        CLIENT: "Verify against client checksums",
	        SERVER: "Trust server generated checksums"
	    },
	    remoteChecksumPolicy: {
	        GEN_IF_ABSENT: "Generate if absent",
	        FAIL: "Fail",
	        IGNORE_AND_GEN: "Ignore and generate",
	        PASS_THRU: "Ignore and pass-through"
	    },
	    snapshotRepositoryBehavior: {
	        UNIQUE: "Unique",
	        NONUNIQUE: "Non-unique",
	        DEPLOYER: "Deployer"
	    },
	    pomCleanupPolicy: {
	        discard_active_reference: "Discard active references",
	        discard_any_reference: "Discard any reference",
	        nothing: "Nothing"
	    },
	    dockerApiVersion: {
	        V1: "V1",
	        V2: "V2"
	    },
	    vcsGitProvider: {
	        GITHUB: "GitHub",
	        BITBUCKET: "BitBucket",
	        STASH: "Stash / Private BitBucket",
	        OLDSTASH: "Stash / Private BitBucket (prior to 5.1.0)",
	        ARTIFACTORY: "Artifactory",
	        CUSTOM: "Custom"
	    },
	    defaultLayouts: {
	        maven: "maven-2-default",
	        ivy: "ivy-default",
	        gradle: "gradle-default",
	        nuget: "nuget-default",
	        npm: "npm-default",
	        bower: "bower-default",
	        composer: "composer-default",
	        conan: "conan-default",
	        puppet: "puppet-default",
	        vcs: "vcs-default",
	        sbt: "sbt-default"
	    },
	    REPO_TYPE: {
	        LOCAL: "local",
	        REMOTE: "remote",
	        VIRTUAL: "virtual",
	        DISTRIBUTION: "distribution"
	    },
	    repoPackageTypes: [{
	        serverEnumName: "Bower",
	        value: "bower",
	        text: "Bower",
	        icon: "bower",
	        repoType: ["local", "remote", "virtual"],
	        description: "Bower package manager is optimized for front-end development. A Bower repository will allow you to easily manage your Bower packages and proxy remote Bower repositories."
	    }, {
	        serverEnumName: "Chef",
	        value: "chef",
	        text: "Chef",
	        icon: "chef",
	        repoType: ["local", "remote", "virtual"],
	        description: "Chef Description" // TODO
	    }, {
	        serverEnumName: "CocoaPods",
	        value: "cocoapods",
	        text: "CocoaPods",
	        icon: "cocoapods",
	        repoType: ["local", "remote"],
	        description: "CocoaPods is an application level dependency manager for the Objective-C programming language and any other languages that run on the Objective-C runtime, that provides a standard format for managing external libraries."
	    }, {
	        serverEnumName: "Conan",
	        value: "conan",
	        text: "Conan",
	        icon: "conan",
	        repoType: ["local", "remote", "virtual"],
	        description: "Conan is a portable package manager, intended for C and C++ developers, but it is able to manage builds from source, dependencies, and precompiled binaries for any language."
	    }, {
	        serverEnumName: "Conda",
	        value: "conda",
	        text: "Conda",
	        icon: "conda",
	        repoType: ["local", "remote", "virtual"]
	    }, {
	        serverEnumName: "CRAN",
	        value: "cran",
	        text: "CRAN",
	        icon: "cran",
	        repoType: ["local", "remote", "virtual"],
	        description: ""
	    }, {
	        serverEnumName: "Debian",
	        value: "debian",
	        text: "Debian",
	        icon: "debian",
	        repoType: ["local", "remote", "virtual"],
	        description: "A Debian repository will allow you to host, cache and distribute your packages for Debian based operating systems such as Ubuntu."
	    }, {
	        serverEnumName: "Docker",
	        value: "docker",
	        text: "Docker",
	        icon: "docker",
	        repoType: ["local", "remote", "virtual"],
	        description: "Docker allows you to package an application with all of its dependencies into a standardized unit for software development. A Docker repository will allow you to easily and securely manage your Docker images."
	    }, {
	        serverEnumName: "Gems",
	        value: "gems",
	        text: "Gems",
	        icon: "gems",
	        repoType: ["local", "remote", "virtual"],
	        description: "A RubyGems repository allows you to easily download, install, and use ruby software packages in your system. Gems can be used to extend or modify functionality in Ruby applications."
	    }, {
	        serverEnumName: "GitLfs",
	        value: "gitlfs",
	        text: "Git LFS",
	        icon: "git-lfs",
	        repoType: ["local", "remote", "virtual"],
	        description: "Git LFS replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents in an Artifactory repository. This allows you to work with the same Git workflow, but with better access control, faster download and more repository space."
	    }, {
	        serverEnumName: "Go",
	        value: "go",
	        text: "Go",
	        icon: "golang",
	        repoType: ["local", "remote", "virtual"],
	        description: ""
	    }, {
	        serverEnumName: "Gradle",
	        value: "gradle",
	        text: "Gradle",
	        icon: "gradle",
	        repoType: ["local", "remote", "virtual"],
	        description: "Gradle is a build automation tool which lets model your problem domain declaratively using a powerful and expressive domain-specific language (DSL) implemented in Groovy."
	    }, {
	        serverEnumName: "Helm",
	        value: "helm",
	        text: "Helm",
	        icon: "helm",
	        repoType: ["local", "remote", "virtual"],
	        description: ""
	    }, {
	        serverEnumName: "Ivy",
	        value: "ivy",
	        text: "Ivy",
	        icon: "ivy",
	        repoType: ["local", "remote", "virtual"],
	        description: "Apache Ivy is a popular dependency manager focusing on flexibility and simplicity. Ivy offers full integration with ant, and a strong transitive dependency management engine."
	    }, {
	        serverEnumName: "Maven",
	        value: "maven",
	        text: "Maven",
	        icon: "maven",
	        repoType: ["local", "remote", "virtual"],
	        description: "Apache Maven is a build automation tool which provides useful project information from your project’s sources."
	    }, {
	        serverEnumName: "Npm",
	        value: "npm",
	        text: "npm",
	        icon: "npm",
	        repoType: ["local", "remote", "virtual"],
	        description: "npm package manager makes it easy for JavaScript developers to share, reuse code, and update code. Host your own node.js packages in Artifactory and proxy remote npm repositories. Use npm against a single in-house repository under your control for your all npm needs."
	    }, {
	        serverEnumName: "NuGet",
	        value: "nuget",
	        text: "NuGet",
	        icon: "nuget",
	        repoType: ["local", "remote", "virtual"],
	        description: "NuGet is the package manager for Microsoft development platforms including .NET. Host and proxy NuGet packages in Artifactory, and pull libraries from Artifactory into your various Visual Studio .NET applications."
	    }, {
	        serverEnumName: "Opkg",
	        value: "opkg",
	        text: "Opkg",
	        icon: "opkg",
	        repoType: ["local", "remote"],
	        description: "Opkg is a lightweight package management system based upon ipkg. It is intended for use on embedded Linux devices, and is commonly used for IoT."
	    }, {
	        serverEnumName: "Composer",
	        value: "composer",
	        text: "PHP Composer",
	        icon: "composer",
	        repoType: ["local", "remote"],
	        description: "Composer is a dependency manager for PHP."
	    }, {
	        serverEnumName: "P2",
	        value: "p2",
	        text: "P2",
	        icon: "p2",
	        repoType: ["remote", "virtual"],
	        description: "P2 provides a provisioning platform for Eclipse and Equinox-based applications."
	    }, {
	        serverEnumName: "Pypi",
	        value: "pypi",
	        text: "PyPI",
	        icon: "pypi",
	        repoType: ["local", "remote", "virtual"],
	        description: "The Python Package Index for the Python programming language. Transparently resolve PyPI distribution locations, whether local or remote. Exercise fine-grained access control to all PyPI resources with comprehensive security measures and full support for pip."
	    }, {
	        serverEnumName: "Puppet",
	        value: "puppet",
	        text: "Puppet",
	        icon: "puppet",
	        repoType: ["local", "remote", "virtual"],
	        description: "A repository of puppet modules."
	    }, {
	        serverEnumName: "SBT",
	        value: "sbt",
	        text: "SBT",
	        icon: "sbt",
	        repoType: ["local", "remote", "virtual"],
	        description: "Sbt is a build tool for the Scala community and Java projects. Sbt uses advanced concepts to provide flexible and powerful build definitions."
	    }, {
	        serverEnumName: "Vagrant",
	        value: "vagrant",
	        text: "Vagrant",
	        icon: "vagrant",
	        repoType: ["local"],
	        description: "Vagrant provides easy-to-configure, reproducible, and portable work environments built on top of industry-standard technology and controlled by a single consistent workflow."
	    }, {
	        serverEnumName: "VCS",
	        value: "vcs",
	        text: "VCS",
	        icon: "vcs",
	        repoType: ["remote"],
	        description: "A VCS remote repository gives you stable and reliable access to your source code with security and access control, along with smart search capabilities for any of the supported version control systems."
	    }, {
	        serverEnumName: "YUM",
	        value: "yum",
	        text: "RPM",
	        icon: "rpm",
	        repoType: ["local", "remote", "virtual"],
	        description: "An RPM repository will allow you to host, cache and distribute your RPM packages."
	    }, {
	        serverEnumName: "Generic",
	        value: "generic",
	        text: "Generic",
	        icon: "generic",
	        repoType: ["local", "remote", "virtual"],
	        description: "A generic repository can be used to host and proxy any type of file."
	    }, {
	        serverEnumName: "BuildInfo",
	        value: "buildinfo",
	        text: "Build Info",
	        icon: "builds-new",
	        repoType: []
	    }, {
	        serverEnumName: "Support",
	        value: "supportbundle",
	        text: "Support Bundle",
	        icon: "support",
	        repoType: []
	    }],
	    sslCertificate: {
	        subject: "Subject",
	        issuer: "Issuer",
	        certificate: "Certificate",
	        common_name: "Common Name",
	        organization: "Organization",
	        unit: "Unit",
	        issued_on: "Issued On",
	        valid_until: "Valid Until",
	        fingerprint: "Fingerprint",
	        dateFields: ["issued_on", "valid_until"] }
	};

/***/ }),
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	// For debugging only:
	window._aolSimulate = function (value) {
	    localStorage._aol = value ? "true" : "false";
	};
	window._aolOff = function () {
	    delete localStorage._aol;
	};
	window._licenseSimulate = function (value) {
	    localStorage._license = value;
	};
	window._licenseOff = function () {
	    delete localStorage._license;
	};
	
	// Order of license levels
	var LICENSES_LEVELS = {
	    OSS: 1,
	    ConanCE: 1,
	    JCR: 1,
	    PRO: 2,
	    ENT: 2,
	    EDGE: 3,
	    ENTPLUS: 5
	};
	
	// Minimum license needed per feature
	var FEATURES = {
	    // This is the default for all other features:
	    "default": {
	        license: "OSS"
	    },
	    // features:
	    gradle: {
	        license: "OSS",
	        label: "Gradle",
	        path: "gradle" // TODO: Add valid path
	    },
	    maven: {
	        license: "OSS",
	        label: "Maven",
	        path: "maven" // TODO: Add valid path
	    },
	    sbt: {
	        license: "OSS",
	        label: "SBT",
	        path: "sbt" // TODO: Add valid path
	    },
	    ivy: {
	        license: "OSS",
	        label: "Ivy",
	        path: "ivy" // TODO: Add valid path
	    },
	    stash: {
	        license: "PRO",
	        label: "Smart search",
	        path: "search"
	    },
	
	    properties: {
	        license: "JCR",
	        label: "Properties",
	        path: "properties"
	    },
	    builds: {
	        license: "PRO",
	        label: "Builds",
	        path: "build"
	    },
	
	    watches: {
	        license: "PRO",
	        label: "Watches",
	        path: "watches"
	    },
	    diff: {
	        license: "PRO",
	        label: "Build Diff",
	        path: "build"
	    },
	
	    licenses: {
	        license: "PRO",
	        label: "Licenses",
	        path: "license"
	    },
	    publishedmodule: {
	        license: "PRO",
	        label: "Published Module",
	        path: "build"
	    },
	
	    highavailability: {
	        license: "ENT",
	        label: "High Availability",
	        path: "ha"
	    },
	    crowd: {
	        license: "PRO",
	        label: "Crowd",
	        path: "sso"
	    },
	    samlsso: {
	        license: "PRO",
	        label: "Saml & SSO",
	        path: "sso"
	    },
	    oauthsso: {
	        license: "PRO",
	        label: "OAuth SSO",
	        path: "sso" // ???
	    },
	    httpsso: {
	        license: "PRO",
	        label: "Http SSO",
	        path: "sso"
	    },
	    signingkeys: {
	        license: "PRO",
	        label: "Signing Keys & WebStart",
	        path: "webstart"
	    },
	    trustedkeys: {
	        license: "EDGE",
	        label: "Trusted Keys",
	        path: "trustedkeys"
	    },
	    replications: {
	        license: "PRO",
	        label: "Replications",
	        path: "replication"
	    },
	    distribution: {
	        license: "OSS",
	        label: "Distribution Repository",
	        path: "distribution"
	    },
	    "distribution-map-properties": {
	        license: "PRO",
	        label: "Map Properties to Bintray Version Attributes"
	    },
	    ldap: {
	        license: "PRO",
	        label: "LDAP Groups",
	        path: "ldap"
	    },
	    register_pro: {
	        license: "PRO",
	        label: "Register Pro",
	        path: "register pro"
	    },
	    sha256: {
	        license: "PRO",
	        label: "Sha256 Calculation",
	        path: "sha256"
	    },
	    supportpage: {
	        license: "PRO",
	        label: "Support Page"
	    },
	    reverse_proxies: {
	        license: "JCR",
	        label: "Reverse Proxies"
	    },
	    xray: {
	        license: "PRO",
	        label: "Xray Integration"
	    },
	    accesstokens: {
	        license: "OSS",
	        label: "Access Tokens",
	        path: "accesstokens"
	    },
	
	    // repo types:
	    bower: {
	        license: "PRO",
	        label: "Bower",
	        path: "bower"
	    },
	    chef: {
	        license: "PRO",
	        label: "Chef",
	        path: "chef"
	    },
	    cocoapods: {
	        license: "PRO",
	        label: "CocoaPods",
	        path: "cocoapods"
	    },
	    composer: {
	        license: "PRO",
	        label: "Composer",
	        path: "composer"
	    },
	    conan: {
	        license: "ConanCE",
	        label: "Conan",
	        path: "conan"
	    },
	    conda: {
	        license: "PRO",
	        label: "Conda",
	        path: "conda"
	    },
	    cran: {
	        license: "PRO",
	        label: "CRAN",
	        path: "cran"
	    },
	    debian: {
	        license: "PRO",
	        label: "Debian",
	        path: "debian"
	    },
	    docker: {
	        license: "JCR",
	        label: "Docker",
	        path: "docker"
	    },
	    gems: {
	        license: "PRO",
	        label: "Gems",
	        path: "gems"
	    },
	    gitlfs: {
	        license: "PRO",
	        label: "GitLfs",
	        path: "gitlfs"
	    },
	    npm: {
	        license: "PRO",
	        label: "Npm",
	        path: "npm"
	    },
	    nuget: {
	        license: "PRO",
	        label: "NuGet",
	        path: "nuget"
	    },
	    opkg: {
	        license: "PRO",
	        label: "Opkg",
	        path: "opkg"
	    },
	    p2: {
	        license: "PRO",
	        label: "P2",
	        path: "p2"
	    },
	    puppet: {
	        license: "PRO",
	        label: "Puppet",
	        path: "puppet"
	    },
	    helm: {
	        license: "JCR",
	        label: "Helm",
	        path: "helm"
	    },
	    go: {
	        license: "PRO",
	        label: "Go",
	        path: "go"
	    },
	    pypi: {
	        license: "PRO",
	        label: "pypi",
	        path: "pypi"
	    },
	    vagrant: {
	        license: "PRO",
	        label: "Vagrant",
	        path: "vagrant"
	    },
	    vcs: {
	        license: "PRO",
	        label: "VCS",
	        path: "vcs"
	    },
	    yum: {
	        license: "PRO",
	        label: "RPM",
	        path: "yum"
	    },
	    sshserver: {
	        license: "OSS",
	        label: "SSH Authentication"
	    },
	    sslcertificates: {
	        license: "PRO",
	        label: "SSL Certificates"
	    },
	    "native-ui": {
	        license: "JCR",
	        label: "Package Viewer"
	    },
	    bundles: {
	        license: "ENTPLUS",
	        label: "Release Bundles"
	    }
	};
	
	exports.FEATURES = FEATURES;
	// Features that are hidden for AOL
	var HIDDEN_AOL_FEATURES = ["backups", "highavailability", "httpsso", "proxies", "register_pro", "indexer", "services", "systeminfo", "maintenance", "configdescriptor", "securitydescriptor", "system", "mail", "supportpage", "reverse_proxies", "sshserver"];
	
	exports.HIDDEN_AOL_FEATURES = HIDDEN_AOL_FEATURES;
	var HIDDEN_EDGE_FEATURES = ["replications", "distribution", "builds", "xray", "licenses", "sslcertificates"];
	
	exports.HIDDEN_EDGE_FEATURES = HIDDEN_EDGE_FEATURES;
	// Features that are not hidden for dedicated AOL
	var SHOW_ON_DEDICATED_AOL = ["indexer", "xray"];
	
	exports.SHOW_ON_DEDICATED_AOL = SHOW_ON_DEDICATED_AOL;
	// Features that are hidden for OSS
	var HIDDEN_OSS_FEATURES = ["register_pro"];
	
	exports.HIDDEN_OSS_FEATURES = HIDDEN_OSS_FEATURES;
	// Service for accessing allowed features and licenses
	
	var ArtifactoryFeatures = exports.ArtifactoryFeatures = (function () {
	    function ArtifactoryFeatures(FooterDao, ArtifactoryState, $location, $q, GoogleAnalytics) {
	        var _this = this;
	
	        _classCallCheck(this, ArtifactoryFeatures);
	
	        this.footerDao = FooterDao;
	        this.ArtifactoryState = ArtifactoryState;
	        this.$location = $location;
	        this.GoogleAnalytics = GoogleAnalytics;
	        var defer = $q.defer();
	        this.whenReady = defer.promise;
	        this.footerDao.get().then(function () {
	            _this.GoogleAnalytics._setUpGA();
	            defer.resolve();
	        });
	    }
	
	    _createClass(ArtifactoryFeatures, {
	        getAllowedLicense: {
	            value: function getAllowedLicense(featureName) {
	                featureName = featureName && featureName.toLowerCase();
	                var feature = FEATURES[featureName] || FEATURES["default"];
	                return feature.license;
	            }
	        },
	        isEnabled: {
	            value: function isEnabled(feature) {
	                if (!feature) {
	                    return true;
	                }
	                var allowedLicense = this.getAllowedLicense(feature);
	                var currentLicense = this.getCurrentLicense();
	                if (feature === "trustedkeys" && !this.isEdgeNode() && !this.isEnterprisePlus()) {
	                    return false;
	                }
	                if (LICENSES_LEVELS[currentLicense] === 1 && LICENSES_LEVELS[allowedLicense] === 1) {
	                    if ((currentLicense === "ConanCE" || currentLicense === "JCR") && _.includes(["ivy", "sbt", "gradle", "maven"], feature)) {
	                        return false;
	                    }
	                    if ((currentLicense === "OSS" || currentLicense === "ConanCE") && _.includes(["docker", "helm"], feature)) {
	                        return false;
	                    }
	                    if ((currentLicense === "OSS" || currentLicense === "JCR") && feature === "conan") {
	                        return false;
	                    }
	                    if (currentLicense === "JCR" && feature === "reverse_proxies") {
	                        return true;
	                    }
	                }
	
	                return LICENSES_LEVELS[currentLicense] >= LICENSES_LEVELS[allowedLicense];
	            }
	        },
	        isDisabled: {
	            value: function isDisabled(feature) {
	                return !this.isEnabled(feature);
	            }
	        },
	        isHidden: {
	            value: function isHidden(feature) {
	                if (!feature) {
	                    return false;
	                }
	                feature = feature.toLowerCase();
	                if (feature === "httpsso" && this.isAol() && this.footerDao.getInfo().httpSsoEnabledAOL) {
	                    return;
	                }return this.isAol() && _.includes(HIDDEN_AOL_FEATURES, feature) && !(this.isDedicatedAol() && _.includes(SHOW_ON_DEDICATED_AOL, feature)) || this.isOss() && _.includes(HIDDEN_OSS_FEATURES, feature) || this.isEdgeNode() && _.includes(HIDDEN_EDGE_FEATURES, feature) || this.isNonCommercial() && _.includes(HIDDEN_OSS_FEATURES, feature);
	            }
	        },
	        isVisible: {
	            value: function isVisible(feature) {
	                return !this.isHidden(feature);
	            }
	        },
	        isAol: {
	            value: function isAol() {
	                if (localStorage._aol != undefined) {
	                    return localStorage._aol === "true";
	                } // For debugging only
	                return this.footerDao.getInfo() && this.footerDao.getInfo().isAol;
	            }
	        },
	        isDedicatedAol: {
	            value: function isDedicatedAol() {
	                return this.footerDao.getInfo() && this.footerDao.getInfo().isDedicatedAol;
	            }
	        },
	        isCloudProviderConfigured: {
	            value: function isCloudProviderConfigured() {
	                return this.footerDao.getInfo() && this.footerDao.getInfo().isCloudProviderConfigured;
	            }
	        },
	        getCurrentLicense: {
	            value: function getCurrentLicense() {
	                return this.footerDao.getInfo() && this.footerDao.getInfo().versionID;
	            }
	        },
	        isOss: {
	            value: function isOss() {
	                return this.getCurrentLicense() === "OSS";
	            }
	        },
	        isEnterprisePlus: {
	            value: function isEnterprisePlus() {
	                return this.getCurrentLicense() === "ENTPLUS";
	            }
	        },
	        isEdgeNode: {
	            value: function isEdgeNode() {
	                return this.getCurrentLicense() === "EDGE";
	            }
	        },
	        isConanCE: {
	            value: function isConanCE() {
	                return this.getCurrentLicense() == "ConanCE";
	            }
	        },
	        isJCR: {
	            value: function isJCR() {
	                return this.getCurrentLicense() == "JCR";
	            }
	        },
	        isJCRDemo: {
	            value: function isJCRDemo() {
	
	                return this.isJCR() && localStorage.JCRDemo;
	            }
	        },
	        isNonCommercial: {
	            value: function isNonCommercial() {
	                return this.isOss() || this.isConanCE() || this.isJCR();
	            }
	        },
	        getFeatureName: {
	            value: function getFeatureName(feature) {
	                feature = feature && feature.toLowerCase();
	                return FEATURES[feature].label;
	            }
	        },
	        getFeatureLink: {
	            value: function getFeatureLink(feature) {
	                feature = feature && feature.toLowerCase();
	                if (FEATURES[feature] && FEATURES[feature].path) {
	                    return "http://service.jfrog.org/artifactory/addons/info/" + FEATURES[feature].path;
	                }
	            }
	        },
	        getGlobalName: {
	            value: function getGlobalName() {
	                return this.isJCR() ? "JFrog Container Registry" : "Artifactory";
	            }
	        }
	    });
	
	    return ArtifactoryFeatures;
	})();

/***/ }),
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	    Watch: { title: "Watch", icon: "icon-watch" },
	    Unwatch: { title: "Unwatch", icon: "icon-unwatch" },
	    Download: { title: "Download", icon: "icon-download" },
	    DownloadFolder: { title: "Download", icon: "icon-download" },
	    View: { title: "View", icon: "icon-view" },
	    Delete: { title: "Delete", icon: "icon-clear" },
	    DeletePermanently: { title: "Delete Permanently", icon: "icon-clear" },
	    Copy: { title: "Copy", icon: "icon-copy" },
	    Move: { title: "Move", icon: "icon-move" },
	    CopyStash: { title: "Copy Stash to Repository", icon: "icon-copy" },
	    MoveStash: { title: "Move Stash to Repository", icon: "icon-move" },
	    ShowInTree: { title: "Show In Tree", icon: "icon-show-in-tree" },
	    DiscardFromStash: { title: "Discard from Stash", icon: "icon-delete-content" },
	    DiscardStash: { title: "Discard Search Results", icon: "icon-delete-content" },
	    DeleteContent: { title: "Delete Content", icon: "icon-clear" },
	    CopyContent: { title: "Copy Content", icon: "icon-copy" },
	    MoveContent: { title: "Move Content", icon: "icon-move" },
	    DeleteVersions: { title: "Delete Versions", icon: "icon-delete-versions" },
	    Refresh: { title: "Refresh", icon: "icon-refresh" },
	    UploadToBintray: { title: "Push to Bintray", icon: "icon-bintray" },
	    Distribute: { title: "Distribute to Bintray", icon: "icon-distribution-repo" },
	    Redistribute: { title: "Redistribute", icon: "icon-distribution-repo" },
	    Zap: { title: "Zap Cache", icon: "icon-zap" },
	    ZapCaches: { title: "Zap Caches", icon: "icon-zap" },
	    RecalculateIndex: { title: "Recalculate Index", icon: "icon-re-index" },
	    CalculateDebianCoordinates: { title: "Calculate Coordinates", icon: "icon-re-index" },
	    NativeBrowser: { title: "Native Browser", icon: "icon-simple-browser" },
	    EmptyTrash: { title: "Empty Trash Can", icon: "icon-trash" },
	    SearchTrash: { title: "Search Trash Can", icon: "icon-search" },
	    Restore: { title: "Restore", icon: "icon-trashcan-restore" },
	    IgnoreAlert: { title: "Ignore Alert", icon: "icon-xray-ignore-alert" },
	    UnignoreAlert: { title: "Un-Ignore Alert", icon: "icon-xray-alert" },
	    Favorites: { title: "Add to Favorites", icon: "icon-star" }
	};

/***/ }),
/* 170 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by tomere on 2/22/2017.
	 */
	"use strict";
	
	module.exports = {
	    actions: {
	        distribute: {
	            noRepos: {
	                admin: {
	                    message: "No distribution repositories are configured. To distribute artifacts and builds, <a class=\"jf-link\" href=\"#/admin/repositories/distribution\">create a Distribution repository</a>.\n                              To learn about distribution repositories, refer to the Artifactory <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Distribution+Repository\">User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                    messageType: "alert-info"
	                },
	                nonAdmin: {
	                    message: "No distribution repositories are configured.\n                              To learn about distribution repositories, refer to the Artifactory <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Distribution+Repository\">User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                    messageType: "alert-info"
	                }
	            },
	            inOfflineMode: {
	                message: "Global offline mode is enabled. To allow distribution, disable the global offline mode through the General Configuration page.",
	                messageType: "alert-danger"
	            },
	            noPermissions: {
	                message: "You do not have distribute and deploy permissions.",
	                messageType: "alert-danger"
	            }
	        },
	        deploy: {
	            deployToDistRepoErrorMessage: {
	                message: "File(s) cannot be directly deployed to a distribution repository. Instead, use the \"Distribute\" action on the relevant repository or select an alternative target repository.",
	                messageType: "alert-danger"
	            },
	            deployPermissionsErrorMessage: {
	                message: "You do not have deploy permission",
	                messageType: "alert-danger"
	            },
	            hasNoDefaultDeployRepo: {
	                message: "This virtual repository is not configured with a default deployment repository. To learn about configuring virtual repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Deploying+Artifacts#DeployingArtifacts-DeployingtoaVirtualRepository\" target=\"_blank\">Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                messageType: "alert-warning"
	            },
	            cannotDeployToRemote: {
	                message: "Cannot deploy to a remote repository. To learn about remote repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Remote+Repositories\" target=\"_blank\">Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                messageJCR: "Cannot deploy to a remote repository. To learn about remote repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/JCR/Remote+Repositories\" target=\"_blank\">JFrog Container Registry User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                messageType: "alert-danger"
	            },
	            cannotDeployToTrashCan: {
	                message: "Cannot deploy to Trash Can. To learn about the Trash Can, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Browsing+Artifactory#BrowsingArtifactory-TrashCan\" target=\"_blank\">Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                messageType: "alert-danger"
	            } }
	    },
	    set_me_up: {
	        puppet: {
	            puppetClientVersion: "If you are using Puppet version 4.9.1 and below, you need to modify your reverse proxy configuration. For details, refer to <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Puppet+Repositories#PuppetRepositories-UsingPuppet4.9.1andBelow\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>."
	        },
	        hasNoDeployPermissions: {
	            message: "You do not have deploy permissions to this repository"
	        },
	        hasNoRepositoriesOfType: {
	            message: "No repositories match the selected tool"
	        }
	    },
	    xray_tab: {
	        blocked_artifact: "Xray has a policy blocking this artifact for download.",
	        blocked_artifact_ignored: "Artifactory’s Xray configuration has overridden Xray’s policy blocking the download of this artifact."
	    }
	};

/***/ }),
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var Configuration = _interopRequire(__webpack_require__(182));
	
	var Repositories = _interopRequire(__webpack_require__(210));
	
	var Advanced = _interopRequire(__webpack_require__(217));
	
	var Dashboard = _interopRequire(__webpack_require__(235));
	
	var ImportExport = _interopRequire(__webpack_require__(236));
	
	var Security = _interopRequire(__webpack_require__(242));
	
	var Services = _interopRequire(__webpack_require__(282));
	
	var AdminController = __webpack_require__(289).AdminController;
	
	function adminConfig($stateProvider) {
	    $stateProvider.state("admin", {
	        url: "/admin",
	        parent: "app-layout",
	        templateUrl: "states/admin/admin.html",
	        controller: "AdminController as Admin"
	    });
	}
	
	module.exports = angular.module("admin.module", [Configuration.name, Repositories.name, Advanced.name, Dashboard.name, ImportExport.name, Security.name, Services.name]).config(adminConfig).controller("AdminController", AdminController);

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var Licenses = _interopRequire(__webpack_require__(183));
	
	var Mail = _interopRequire(__webpack_require__(186));
	
	var Xray = _interopRequire(__webpack_require__(188));
	
	var Proxies = _interopRequire(__webpack_require__(191));
	
	var ReverseProxies = _interopRequire(__webpack_require__(194));
	
	var RegisterPro = _interopRequire(__webpack_require__(197));
	
	var Bintray = _interopRequire(__webpack_require__(199));
	
	var General = _interopRequire(__webpack_require__(201));
	
	var PropertySets = _interopRequire(__webpack_require__(203));
	
	var HighAvailability = _interopRequire(__webpack_require__(207));
	
	var AdminConfigurationController = __webpack_require__(209).AdminConfigurationController;
	
	/**
	 * configuration and state definition
	 * @param $stateProvider
	 */
	function configurationConfig($stateProvider) {
	
	  $stateProvider.state("admin.configuration", {
	    url: "/configuration",
	    template: "<ui-view></ui-view>",
	    controller: "AdminConfigurationController as AdminConfiguration"
	  });
	}
	
	/**
	 * Module definition
	 */
	module.exports = angular.module("admin.configuration", [Licenses.name, Mail.name, Xray.name, Proxies.name, ReverseProxies.name, RegisterPro.name, Bintray.name, General.name, PropertySets.name, HighAvailability.name]).config(configurationConfig).controller("AdminConfigurationController", AdminConfigurationController);

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationLicensesController = __webpack_require__(184).AdminConfigurationLicensesController;
	
	var AdminConfigurationLicenseFormController = __webpack_require__(185).AdminConfigurationLicenseFormController;
	
	function licensesConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.licenses", {
	        url: "/licenses",
	        params: { feature: "licenses" },
	        templateUrl: "states/admin/configuration/licenses/licenses.html",
	        controller: "AdminConfigurationLicensesController as AdminConfigurationLicenses"
	    }).state("admin.configuration.licenses.edit", {
	        parent: "admin.configuration",
	        url: "/licenses/{licenseName}/edit",
	        params: { feature: "licenses" },
	        templateUrl: "states/admin/configuration/licenses/license_form.html",
	        controller: "AdminConfigurationLicenseFormController as AdminLicenseForm"
	    }).state("admin.configuration.licenses.new", {
	        parent: "admin.configuration",
	        url: "/licenses/new",
	        params: { feature: "licenses" },
	        templateUrl: "states/admin/configuration/licenses/license_form.html",
	        controller: "AdminConfigurationLicenseFormController as AdminLicenseForm"
	    });
	}
	
	module.exports = angular.module("configuration.licenses", ["ui.router"]).config(licensesConfig).controller("AdminConfigurationLicensesController", AdminConfigurationLicensesController).controller("AdminConfigurationLicenseFormController", AdminConfigurationLicenseFormController);

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var API = _interopRequire(__webpack_require__(98));
	
	var AdminConfigurationLicensesController = exports.AdminConfigurationLicensesController = (function () {
	    function AdminConfigurationLicensesController($scope, $window, JFrogModal, LicensesDao, JFrogGridFactory, ArtifactoryState, uiGridConstants) {
	        _classCallCheck(this, AdminConfigurationLicensesController);
	
	        this.$window = $window;
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.licensesDao = LicensesDao;
	        this.$scope = $scope;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	
	        this._createGrid();
	        this._initLicenses();
	
	        //clear 'prevState' in ArtifactoryState, used to return from license form to another state (Builds->Licenses)
	        ArtifactoryState.setState("prevState", undefined);
	    }
	
	    _createClass(AdminConfigurationLicensesController, {
	        _initLicenses: {
	            value: function _initLicenses() {
	                var _this = this;
	
	                this.licensesDao.getLicense().$promise.then(function (licenses) {
	                    _this.licenses = licenses;
	                    _this.gridOption.setGridData(_this.licenses.data);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getCloumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        deleteLicense: {
	            value: function deleteLicense(license) {
	                var _this = this;
	
	                var json = { licenseskeys: [license.name] };
	                this.modal.confirm("Are you sure you want to delete " + license.name + "?").then(function () {
	                    _this.licensesDao["delete"](json).$promise.then(function () {
	                        return _this.updateListTable();
	                    });
	                });
	            }
	        },
	        deleteSelectedLicenses: {
	            value: function deleteSelectedLicenses() {
	                var _this = this;
	
	                //Get All selected licenses
	                var selectedRows = this.gridOption.api.selection.getSelectedGridRows();
	                //Create an array of the selected licenses keys
	                var names = _.map(selectedRows, function (row) {
	                    return row.entity.name;
	                });
	                //Create Json for the bulk request
	                var json = { licenseskeys: names };
	                //console.log('Bulk delete....');
	                //Ask for confirmation before delete and if confirmed then delete bulk of licenses
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " licenses?").then(function () {
	                    _this.licensesDao["delete"](json).$promise.then(function () {
	                        return _this.updateListTable();
	                    });
	                });
	            }
	        },
	        updateListTable: {
	            value: function updateListTable() {
	                var _this = this;
	
	                this.licensesDao.getLicense().$promise.then(function (licenses) {
	                    _this.licenses = licenses;
	                    _this.gridOption.setGridData(_this.licenses.data);
	                    if (_this.modalInstance) {
	                        _this.closeModal();
	                    }
	                });
	            }
	        },
	        setStatus: {
	            value: function setStatus(row) {
	                var _this = this;
	
	                if (row.approved) {
	                    row.approved = false;
	                    row.status = "Unapproved";
	                } else {
	                    row.approved = true;
	                    row.status = "Approved";
	                }
	                this.licensesDao.update(row).$promise.then(function () {
	                    return _this.updateListTable();
	                });
	            }
	        },
	        exportLicenses: {
	            value: function exportLicenses() {
	                this.$window.open("" + API.API_URL + "/licenseexport", "_self", "");
	            }
	        },
	        getCloumns: {
	            value: function getCloumns() {
	                return [{
	                    name: "License Key",
	                    displayName: "License Key",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.licenses.edit({licenseName: row.entity.name})\" id=\"license-key\" class=\"jf-link text-center ui-grid-cell-contents\">{{row.entity.name}}</a></div>",
	                    width: "15%"
	                }, {
	                    name: "Name",
	                    displayName: "Name",
	                    field: "longName",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"license-name\"><span>{{row.entity.longName}}</span></div>",
	                    width: "40%"
	
	                }, {
	                    name: "URL",
	                    displayName: "URL",
	                    field: "url",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" ><a class=\"jf-link\" href=\"{{row.entity.url}}\" target=\"_blank\" id=\"license-url\">{{row.entity.url}}</a></div>",
	                    width: "30%"
	                }, {
	                    name: "Status",
	                    displayName: "Status",
	                    field: "status",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><jf-switch-toggle texton=\"Approved\" id=\"license-status\" textoff=\"Unapproved\" ng-click=\"grid.appScope.AdminConfigurationLicenses.setStatus(row.entity)\" ng-class=\"{'on': row.entity.approved, 'off': !row.entity.approved}\"></jf-switch-toggle></div>",
	                    width: "15%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (license) {
	                        return _this.deleteLicense(license);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedLicenses();
	                    }
	                }];
	            }
	        }
	    });
	
	    return AdminConfigurationLicensesController;
	})();

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminConfigurationLicenseFormController = exports.AdminConfigurationLicenseFormController = (function () {
	    function AdminConfigurationLicenseFormController($stateParams, LicensesDao, $state, ArtifactoryState, ArtifactoryModelSaver) {
	        var _this = this;
	
	        _classCallCheck(this, AdminConfigurationLicenseFormController);
	
	        this.state = $state;
	        this.isNew = !$stateParams.licenseName;
	        this.licensesDao = LicensesDao;
	        this.artifactoryState = ArtifactoryState;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["license"]);
	
	        this.TOOLTIP = TOOLTIP.admin.configuration.licenseForm;
	
	        if (this.isNew) {
	            this.license = new LicensesDao();
	        } else {
	            this.license = LicensesDao.getSingleLicense({ name: $stateParams.licenseName });
	            this.license.$promise.then(function (data) {
	                _this.ArtifactoryModelSaver.save();
	            });
	        }
	    }
	
	    _createClass(AdminConfigurationLicenseFormController, {
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	
	                var whenSaved = this.isNew ? this.license.$create() : this.license.$update();
	                whenSaved.then(function () {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this._end();
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                var prevState = this.artifactoryState.getState("prevState");
	                if (prevState) {
	                    this.state.go(prevState.state, prevState.params);
	                } else {
	                    this.state.go("^.licenses");
	                }
	            }
	        },
	        testRegex: {
	            value: function testRegex(value) {
	
	                var regex = new RegExp("^[A-Za-z0-9._-]*$");
	                return regex.test(value);
	            }
	        }
	    });
	
	    return AdminConfigurationLicenseFormController;
	})();

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationMailController = __webpack_require__(187).AdminConfigurationMailController;
	
	function mailConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.mail", {
	        params: { feature: "mail" },
	        url: "/mail",
	        templateUrl: "states/admin/configuration/mail/mail.html",
	        controller: "AdminConfigurationMailController as AdminConfigurationMail"
	    });
	}
	
	module.exports = angular.module("configuration.mail", []).config(mailConfig).controller("AdminConfigurationMailController", AdminConfigurationMailController);

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminConfigurationMailController = exports.AdminConfigurationMailController = (function () {
	    function AdminConfigurationMailController(MailDao, JFrogEventBus, $timeout, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminConfigurationMailController);
	
	        this.mailDao = MailDao.getInstance();
	        this.JFrogEventBus = JFrogEventBus;
	        this.getMailData();
	        this.mailSettingsForm = null;
	        this.testReceiptForm = null;
	        this.TOOLTIP = TOOLTIP.admin.configuration.mail;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["mail"]);
	        this.$timeout = $timeout;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	    }
	
	    _createClass(AdminConfigurationMailController, {
	        getMailData: {
	            value: function getMailData() {
	                var _this = this;
	
	                this.mailDao.get().$promise.then(function (mail) {
	                    _this.mail = mail;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	                });
	            }
	        },
	        save: {
	            value: function save(form) {
	                var _this = this;
	
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED, form.$name);
	                if (this.mailSettingsForm.$valid) {
	                    this.mailDao.update(this.mail).$promise.then(function () {
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getMailData();
	                });
	            }
	        },
	        testReceipt: {
	            value: function testReceipt(form) {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED, form.$name);
	                if (this.testReceiptForm.$valid) {
	                    this.mailDao.save(this.mail);
	                }
	            }
	        }
	    });
	
	    return AdminConfigurationMailController;
	})();

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationXrayController = __webpack_require__(189).AdminConfigurationXrayController;
	
	function xrayConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.xray", {
	        params: { feature: "xray" },
	        url: "/xray",
	        templateUrl: "states/admin/configuration/xray/xray.html",
	        controller: "AdminConfigurationXrayController as AdminConfigurationXray"
	    });
	}
	
	module.exports = angular.module("configuration.xray", []).config(xrayConfig).controller("AdminConfigurationXrayController", AdminConfigurationXrayController);

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var FIELD_OPTIONS = _interopRequire(__webpack_require__(135));
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminConfigurationXrayController = exports.AdminConfigurationXrayController = (function () {
	    function AdminConfigurationXrayController($scope, $timeout, XrayDao, ProxiesDao, FooterDao, JFrogModal, JFrogGridFactory, JFrogEventBus, commonGridColumns) {
	        var _this = this;
	
	        _classCallCheck(this, AdminConfigurationXrayController);
	
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.commonGridColumns = commonGridColumns;
	        this.xrayDao = XrayDao;
	        this.proxiesDao = ProxiesDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.footerDao = FooterDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.notConnnectedToXrayMessage = CONFIG_MESSAGES.admin.configuration.xray.notConnnectedToXrayMessage;
	        this.TOOLTIP = TOOLTIP;
	        this.proxyOptions = [""];
	        this.proxy = "";
	        this.bypassDefaultProxy = false;
	        this.createGrid();
	        this.getData();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.getData();
	        });
	    }
	
	    _createClass(AdminConfigurationXrayController, {
	        getData: {
	            value: function getData() {
	                var _this = this;
	
	                this.xrayDao.getIndex().$promise.then(function (data) {
	                    _.forEach(data, function (row) {
	
	                        var rowPackageType = _.find(FIELD_OPTIONS.repoPackageTypes, function (type) {
	                            return type.value == row.pkgType.toLowerCase();
	                        });
	
	                        row.packageIcon = rowPackageType.icon;
	                        row.repoType = row.type.charAt(0).toUpperCase() + row.type.slice(1);
	                        if (row.pkgType === "YUM") {
	                            row.pkgType = "RPM";
	                        }
	                    });
	
	                    _this.indexedRepos = data;
	                    _this.gridOptions.setGridData(data);
	                });
	                this.xrayDao.getNoneIndex().$promise.then(function (data) {
	
	                    _.forEach(data, function (row) {
	
	                        var rowPackageType = _.find(FIELD_OPTIONS.repoPackageTypes, function (type) {
	                            return type.value == row.pkgType.toLowerCase();
	                        });
	
	                        row.packageIcon = rowPackageType.icon;
	                        row.repoType = row.type.charAt(0).toUpperCase() + row.type.slice(1);
	                    });
	
	                    _this.unindexedRepos = data;
	                });
	                this.xrayDao.getIntegrationConfig().$promise.then(function (data) {
	                    _this.xrayEnabled = data.xrayEnabled;
	                    _this.xrayAllowWhenUnavailable = data.xrayAllowWhenUnavailable;
	                    _this.xrayAllowBlocked = data.xrayAllowBlocked;
	                    if (typeof data.blockUnscannedTimeoutSeconds === "undefined") {
	                        _this.blockUnscannedTimeoutSeconds = 60;
	                    } else {
	                        _this.blockUnscannedTimeoutSeconds = data.blockUnscannedTimeoutSeconds;
	                    }
	
	                    _this.bypassDefaultProxy = data.bypassDefaultProxy;
	                    _this.proxy = data.proxy;
	                });
	                this.proxiesDao.getProxyKeys().$promise.then(function (proxies) {
	                    _.forEach(proxies, function (o) {
	                        _this.proxyOptions.push(o);
	                    });
	                });
	            }
	        },
	        createGrid: {
	            value: function createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setMultiSelect().setButtons(this.getActions()).setRowTemplate("default").setBatchActions(this.getBatchActions());
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    width: "40%"
	                }, {
	                    name: "Repository Type",
	                    displayName: "Repository Type",
	                    field: "type",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.repoType}}</div>",
	                    width: "30%"
	                }, {
	                    name: "Package Type",
	                    displayName: "Package Type",
	                    field: "pkgType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.pkgType", "row.entity.packageIcon", "repo-type-icon"),
	                    width: "30%"
	                }];
	            }
	        },
	        getActions: {
	            value: function getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Remove",
	                    callback: function (row) {
	                        return _this.removeIndexes(row);
	                    },
	                    visibleWhen: function () {
	                        return _this.xrayEnabled;
	                    }
	                }];
	            }
	        },
	        getBatchActions: {
	            value: function getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Remove",
	                    callback: function () {
	                        return _this.bulkRemove();
	                    },
	                    visibleWhen: function () {
	                        return _this.xrayEnabled;
	                    }
	                }];
	            }
	        },
	        add: {
	            value: function add() {
	                var _this = this;
	
	                if (this.xrayEnabled === true) {
	                    (function () {
	                        var modalScope = _this.$scope.$new();
	                        var modalInstance = undefined;
	
	                        modalScope.availableRepos = _.cloneDeep(_this.unindexedRepos);
	                        modalScope.indexedRepos = _.cloneDeep(_this.indexedRepos) || [];
	
	                        modalScope.save = function (indexed) {
	                            _this.xrayDao.updateRepositories({}, indexed).$promise.then(function () {
	                                _this.getData();
	                                modalInstance.close();
	                            });
	                        };
	
	                        modalInstance = _this.modal.launchModal("add_xray_index_modal", modalScope);
	                    })();
	                }
	            }
	        },
	        removeIndexes: {
	            value: function removeIndexes(repos) {
	                var _this = this;
	
	                if (_.isArray(repos)) {
	                    this.xrayDao.removeIndex({}, repos).$promise.then(function () {
	                        _this.getData();
	                    });
	                } else {
	                    this.xrayDao.removeIndex({}, [{ name: repos.name, type: repos.type }]).$promise.then(function () {
	                        _this.getData();
	                    });
	                }
	            }
	        },
	        bulkRemove: {
	            value: function bulkRemove() {
	                var selectedRows = this.gridOptions.api.selection.getSelectedRows();
	                var removeList = _.map(selectedRows, function (obj) {
	                    return _.pick(obj, ["name", "type"]);
	                });
	                this.removeIndexes(removeList);
	            }
	        },
	        _updateFooter: {
	            value: function _updateFooter() {
	                this.JFrogEventBus.dispatch(EVENTS.FOOTER_REFRESH);
	            }
	        },
	        xrayEnabledChange: {
	            value: function xrayEnabledChange() {
	                var _this = this;
	
	                if (this.xrayEnabled === false) {
	                    this.modal.confirm("If disabled, Artifactory will not generate events for Xray and your artifacts will not be indexed or scanned.<br /><br />Are you sure you want to disable Xray integration?", "Disable Xray Integration", { confirm: "Disable" }).then(function () {
	                        _this.enableDisableXrayIntegration(false);
	                    })["catch"](function () {
	                        _this.$timeout(function () {
	                            _this.xrayEnabled = true;
	                            _this.getData();
	                        });
	                    });
	                } else {
	                    this.enableDisableXrayIntegration(true);
	                }
	            }
	        },
	        enableDisableXrayIntegration: {
	            value: function enableDisableXrayIntegration(action) {
	                var _this = this;
	
	                this.xrayEnabled = action;
	                if (!this.xrayEnabled) {
	                    this.xrayAllowWhenUnavailable = this.xrayAllowBlocked = false;
	                }
	                this.xrayDao.setXrayEnabled({}, { xrayEnabled: this.xrayEnabled }).$promise.then(function () {
	                    _this.getData();
	                });
	            }
	        },
	        setAllowWhenUnavailable: {
	            value: function setAllowWhenUnavailable() {
	                this.xrayDao.xrayAllowWhenUnavailable({}, { xrayAllowWhenUnavailable: this.xrayAllowWhenUnavailable }).$promise;
	            }
	        },
	        setAllowBlockedDownload: {
	            value: function setAllowBlockedDownload() {
	                this.xrayDao.xrayAllowBlocked({}, { xrayAllowBlocked: this.xrayAllowBlocked }).$promise;
	            }
	        },
	        setBypassDefaultProxy: {
	            value: function setBypassDefaultProxy() {
	                this.xrayDao.setBypassDefaultProxy({}, { bypassDefaultProxy: this.bypassDefaultProxy }).$promise;
	            }
	        },
	        updateBlockUnscannedTimeout: {
	            value: function updateBlockUnscannedTimeout() {
	                this.xrayDao.blockUnscannedTimeout({ seconds: this.blockUnscannedTimeoutSeconds }).$promise;
	            }
	        },
	        updateProxy: {
	            value: function updateProxy() {
	                this.xrayDao.updateXrayProxy(this.proxy).$promise;
	            }
	        }
	    });
	
	    return AdminConfigurationXrayController;
	})();

/***/ }),
/* 190 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by tomere on 2/22/2017.
	 */
	"use strict";
	
	module.exports = {
	    admin: {
	        repositories: {
	            local: {
	                noReplicationsMessage: "This repository has not been configured for replication. To learn about replicating repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Repository+Replication\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                noReposMessage: "Artifactory has not been configured with local repositories. To learn about local repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Local+Repositories\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                noReposMessageJCR: "JFrog Container Registry has not been configured with local repositories. To learn about local repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/JCR/Local+Repositories\" target=\"_blank\">JFrog Container Registry User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            remote: {
	                noReposMessage: "Artifactory has not been configured with remote repositories. To learn about remote repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Remote+Repositories\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                noXrayIntegrationMessage: "This Artifactory instance is not connected to <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/XRAY/Welcome+to+JFrog+Xray\" target=\"_blank\">Xray <i class=\"icon icon-external-link\"></i></a>.",
	                noXrayIntegrationMessageJCR: "This JFrog Container Registry instance is not connected to <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/XRAY/Welcome+to+JFrog+Xray\" target=\"_blank\">Xray <i class=\"icon icon-external-link\"></i></a>."
	            },
	            virtual: {
	                noReposMessage: "Artifactory has not been configured with virtual repositories. To learn about virtual repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Virtual+Repositories\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                noReposMessageJCR: "JFrog Container Registry has not been configured with virtual repositories. To learn about virtual repositories, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/JCR/Virtual+Repositories\" target=\"_blank\">JFrog Container Registry User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            distribution: {
	                noReposMessage: "Bintray Distribution repositories can be used to distribute your products or packages with <a class=\"jf-link\" href=\"https://bintray.com\" target=\"_blank\">JFrog Bintray <i class=\"icon icon-external-link\"></i></a> - the universal distribution platform.",
	                noReposMessageJCR: "Bintray Distribution repositories can be used to distribute your products or packages with <a class=\"jf-link\" href=\"https://bintray.com\" target=\"_blank\">JFrog Bintray <i class=\"icon icon-external-link\"></i></a> - the universal distribution platform.",
	                ePlusNoReposMessage: "Release bundle repositories store release bundles that have either been received or created for distribution using <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/DIST/Welcome+to+JFrog+Distribution\" target=\"_blank\">JFrog Distribution <i class=\"icon icon-external-link\"></i></a>."
	            }
	        },
	        configuration: {
	            propertySets: {
	                noSetsMessage: "Artifactory has not been configured with property sets. To learn about configuring Artifactory to work with property sets <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Properties#Properties-PropertySets\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                noSetsMessageJCR: "JFrog Container Registry has not been configured with property sets. To learn about configuring JFrog Container Registry to work with property sets <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/JCR/Properties\" target=\"_blank\">JFrog Container Registry User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            proxies: {
	                noSetsMessage: "Artifactory has not been configured with proxy servers. To learn about configuring Artifactory to work with proxy servers, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Managing+Proxies\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            xray: {
	                notConnnectedToXrayMessage: "This Artifactory instance is not connected to Xray. To connect this instance to Xray and index artifacts for analysis, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/XRAY/Welcome+to+JFrog+Xray\" target=\"_blank\">Xray User Guide <i class=\"icon icon-external-link\"></i></a>"
	            },
	            ha: {
	                haNotConfiguredMessage: "High Availability license is installed but HA feature is not configured.<br>\n                                      Visit <a class=\"jf-link\" target=\"_blank\" href=\"https://www.jfrog.com/confluence/display/RTF/Installation+and+Setup#InstallationandSetup-ConfiguringArtifactoryHA\">Artifactory High Availability Installation and Setup <i class=\"icon icon-external-link\"></i></a> page in <a class=\"jf-link\" target=\"_blank\" href=\"https://www.jfrog.com/confluence/display/RTF/Welcome+to+Artifactory\">JFrog's wiki <i class=\"icon icon-external-link\"></i></a> for detailed instructions."
	            }
	        },
	        security: {
	            general: {
	                passwordDecrypted: "All passwords in your configuration are currently visible in plain text. To encrypt the passwords through REST API, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Artifactory+REST+API#ArtifactoryRESTAPI-DeactivateArtifactoryKeyEncryption\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                passwordEncrypted: "All passwords in your configuration are currently encrypted. To decrypt the passwords through REST API, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Artifactory+REST+API#ArtifactoryRESTAPI-ActivateArtifactoryKeyEncryption\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>."
	
	            },
	            users: {
	                userForm: {
	                    userIsAdmin: "This user has Admin privileges and is, therefore, not restricted by any of the permission targets specified in the table below." } },
	            groups: {
	                noGroupsMessage: "No groups found. To learn about managing groups in Artifactory, refer to the Artifactory User Guide.  <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Managing+Users#ManagingUsers-CreatingandEditingGroups\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>.",
	                groupForm: {
	                    groupIsAdmin: "This group has Admin privileges and is, therefore, not restricted by any of the permission targets specified in the table below." } },
	            accessTokens: {
	                noTokensMessage: "Artifactory has no access tokens to display. To learn how to generate access tokens, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Access+Tokens\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>." },
	            ldap: {
	                noLdapConfigurationMessage: "Artifactory has not been configured with an LDAP server. To learn about configuring Artifactory to work with LDAP, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Managing+Security+with+LDAP\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>."
	            }
	        },
	        services: {
	            backups: {
	                noBackupsMessage: "Artifactory has not been configured with backups jobs. To learn about backing up Artifactory, refer to the <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Managing+Backups\" target=\"_blank\">JFrog Artifactory User Guide <i class=\"icon icon-external-link\"></i></a>."
	            }
	        },
	        advanced: {
	            logAnalytics: {
	                sumoLogicIntegrationMessage: "The JFrog Artifactory / Sumo Logic integration gives you a centralized overview of your artifact repositories with the ability to drill down and quickly identify recent changes, check application dependencies and identify potential issues. Through dashboards, queries and searches that are pre-enabled out-of-the-box, Sumo Logic allows you to analyze all data that Artifactory generates. For a complete overview, <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/RTF/Log+Analytics\" target=\"_blank\">click here <i class=\"icon icon-external-link\"></i></a>.",
	                sumoLogicIntegrationMessageJCR: "The JFrog Container Registry / Sumo Logic integration gives you a centralized overview of your artifact repositories with the ability to drill down and quickly identify recent changes, check application dependencies and identify potential issues. Through dashboards, queries and searches that are pre-enabled out-of-the-box, Sumo Logic allows you to analyze all data that JFrog Container Registry generates. For a complete overview, <a class=\"jf-link\" href=\"https://www.jfrog.com/confluence/display/JCR/Log+Analytics\" target=\"_blank\">click here <i class=\"icon icon-external-link\"></i></a>." }
	        }
	    },
	    builds: {
	        noBuildsDataMessage: "No builds have been published to Artifactory. To learn about build integration, refer to the",
	        callToAction: "JFrog Artifactory User Guide",
	        actionUrl: "https://www.jfrog.com/confluence/display/RTF/Build+Integration"
	    }
	};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationProxiesController = __webpack_require__(192).AdminConfigurationProxiesController;
	
	var AdminConfigurationProxyFormController = __webpack_require__(193).AdminConfigurationProxyFormController;
	
	function proxiesConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.proxies", {
	        params: { feature: "Proxies" },
	        url: "/proxies",
	        templateUrl: "states/admin/configuration/proxies/proxies.html",
	        controller: "AdminConfigurationProxiesController as AdminConfigurationProxies"
	    }).state("admin.configuration.proxies.new", {
	        params: { feature: "Proxies" },
	        parent: "admin.configuration",
	        url: "/proxies/new",
	        templateUrl: "states/admin/configuration/proxies/proxy_form.html",
	        controller: "AdminConfigurationProxyFormController as ProxyForm"
	    }).state("admin.configuration.proxies.edit", {
	        params: { feature: "Proxies" },
	        parent: "admin.configuration",
	        url: "/proxies/:proxyKey/edit",
	        templateUrl: "states/admin/configuration/proxies/proxy_form.html",
	        controller: "AdminConfigurationProxyFormController as ProxyForm"
	    });
	}
	
	module.exports = angular.module("configuration.proxies", []).config(proxiesConfig).controller("AdminConfigurationProxiesController", AdminConfigurationProxiesController).controller("AdminConfigurationProxyFormController", AdminConfigurationProxyFormController);

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var AdminConfigurationProxiesController = exports.AdminConfigurationProxiesController = (function () {
	    function AdminConfigurationProxiesController($scope, ProxiesDao, JFrogGridFactory, JFrogModal, $q, uiGridConstants, commonGridColumns) {
	        _classCallCheck(this, AdminConfigurationProxiesController);
	
	        this.gridOptions = {};
	        this.commonGridColumns = commonGridColumns;
	        this.uiGridConstants = uiGridConstants;
	        this.proxiesDao = ProxiesDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.proxies = {};
	        this.noSetsMessage = CONFIG_MESSAGES.admin.configuration.proxies.noSetsMessage;
	        this._createGrid();
	        this._initProxies();
	    }
	
	    _createClass(AdminConfigurationProxiesController, {
	        _initProxies: {
	            value: function _initProxies() {
	                var _this = this;
	
	                this.proxiesDao.get().$promise.then(function (proxies) {
	                    _this.proxies = proxies;
	                    _this.gridOptions.setGridData(proxies);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setMultiSelect().setButtons(this._getButtons()).setBatchActions(this._getBatchActions()).setRowTemplate("default");
	            }
	        },
	        deleteSelectedProxies: {
	            value: function deleteSelectedProxies() {
	                var _this = this;
	
	                var selectedRows = this.gridOptions.api.selection.getSelectedRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " proxies?").then(function () {
	                    //Create an array of the selected propertySet names
	                    var keys = _.map(selectedRows, function (row) {
	                        return row.key;
	                    });
	                    //Create Json for the bulk request
	                    var json = { proxyKeys: keys };
	                    //console.log('Bulk delete....');
	                    //Delete bulk of property set
	                    _this.proxiesDao["delete"](json).$promise.then(function () {
	                        return _this._initProxies();
	                    });
	                }).then(function () {
	                    return _this._initProxies();
	                });
	            }
	        },
	        deleteProxy: {
	            value: function deleteProxy(key) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete the proxy '" + key + "'?<br>Any configurations with this proxy on resources such as remote repositories and replications will be removed.").then(function () {
	                    return _this._doDeleteProxy(key);
	                }).then(function () {
	                    return _this._initProxies();
	                });
	            }
	        },
	        _doDeleteProxy: {
	            value: function _doDeleteProxy(key) {
	
	                var json = { proxyKeys: [key] };
	                //console.log(json);
	                return this.proxiesDao["delete"](json).$promise;
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "key",
	                    name: "Key",
	                    displayName: "Key",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" ui-sref=\"^.proxies.edit({proxyKey: row.entity.key})\">{{ COL_FIELD }}</a></div>",
	                    width: "30%"
	                }, {
	                    field: "host",
	                    name: "Host",
	                    displayName: "Host",
	                    width: "45%"
	                }, {
	                    field: "port",
	                    name: "Port",
	                    displayName: "Port",
	                    width: "10%"
	                }, {
	                    field: "defaultProxy",
	                    name: "Default Proxy",
	                    displayName: "Default Proxy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.defaultProxy"),
	                    width: "15%"
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedProxies();
	                    }
	                }];
	            }
	        },
	        _getButtons: {
	            value: function _getButtons() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteProxy(row.key);
	                    }
	                }];
	            }
	        }
	    });
	
	    return AdminConfigurationProxiesController;
	})();

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var $state = undefined,
	    $stateParams = undefined,
	    ProxiesDao = undefined,
	    JFrogModal = undefined,
	    ArtifactoryModelSaver = undefined;
	
	var AdminConfigurationProxyFormController = exports.AdminConfigurationProxyFormController = (function () {
	    function AdminConfigurationProxyFormController(_$state_, _$stateParams_, _ProxiesDao_, _JFrogModal_, _ArtifactoryModelSaver_) {
	        _classCallCheck(this, AdminConfigurationProxyFormController);
	
	        ProxiesDao = _ProxiesDao_;
	        $stateParams = _$stateParams_;
	        $state = _$state_;
	        JFrogModal = _JFrogModal_;
	        ArtifactoryModelSaver = _ArtifactoryModelSaver_.createInstance(this, ["proxy"]);;
	
	        this.isNew = !$stateParams.proxyKey;
	        this.formTitle = "" + (this.isNew && "New" || "Edit " + $stateParams.proxyKey) + " Proxy";
	        this.TOOLTIP = TOOLTIP.admin.configuration.proxyForm;
	        this._initProxy();
	    }
	
	    _createClass(AdminConfigurationProxyFormController, {
	        _initProxy: {
	            value: function _initProxy() {
	                var _this = this;
	
	                if (this.isNew) {
	                    this.proxy = {};
	                } else {
	                    ProxiesDao.getSingleProxy({ key: $stateParams.proxyKey }).$promise.then(function (proxy) {
	                        _this.proxy = proxy;
	                        _this.proxy.redirectedToHostsArray = _this.proxy.redirectedToHosts ? _this.proxy.redirectedToHosts.split(",") : [];
	                        ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        onChangeDefault: {
	            value: function onChangeDefault() {
	                var _this = this;
	
	                if (!this.proxy.defaultProxy) {
	                    return;
	                }JFrogModal.confirm("Do you wish to use this proxy with existing remote repositories (and override any assigned proxies)?", "", { confirm: "OK" })["catch"](function () {
	                    return _this.proxy.defaultProxy = false;
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	
	                this.proxy.redirectedToHosts = this.proxy.redirectedToHostsArray ? this.proxy.redirectedToHostsArray.join(",") : undefined;
	
	                var whenSaved = this.isNew ? ProxiesDao.save(this.proxy) : ProxiesDao.update(this.proxy);
	                whenSaved.$promise.then(function () {
	                    ArtifactoryModelSaver.save();
	                    _this._end();
	                    _this.savePending = false;
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.proxies");
	            }
	        }
	    });
	
	    return AdminConfigurationProxyFormController;
	})();

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationReverseProxiesController = __webpack_require__(195).AdminConfigurationReverseProxiesController;
	
	var AdminConfigurationReverseProxyFormController = __webpack_require__(196).AdminConfigurationReverseProxyFormController;
	
	function reverseProxiesConfig($stateProvider) {
	    $stateProvider
	    /*
	                .state('admin.configuration.reverse_proxies', {
	                    params: {feature: 'ReverseProxies'},
	                    url: '/reverse_proxies',
	                    templateUrl: 'states/admin/configuration/reverse_proxies/reverse_proxies.html',
	                    controller: 'AdminConfigurationReverseProxiesController as AdminConfigurationReverseProxies'
	                })
	                .state('admin.configuration.reverse_proxies.new', {
	                    params: {feature: 'ReverseProxies'},
	                    parent: 'admin.configuration',
	                    url: '/reverse_proxies/new',
	                    templateUrl: 'states/admin/configuration/reverse_proxies/reverse_proxy_form.html',
	                    controller: 'AdminConfigurationReverseProxyFormController as ReverseProxyForm'
	                })
	                .state('admin.configuration.reverse_proxies.edit', {
	                    params: {feature: 'ReverseProxies'},
	                    parent: 'admin.configuration',
	                    url: '/reverse_proxies/:reverseProxyKey/edit',
	                    templateUrl: 'states/admin/configuration/reverse_proxies/reverse_proxy_form.html',
	                    controller: 'AdminConfigurationReverseProxyFormController as ReverseProxyForm'
	                })
	    */
	    .state("admin.configuration.reverse_proxy", {
	        params: { feature: "ReverseProxies", reverseProxyKey: "nginx" },
	        parent: "admin.configuration",
	        url: "/reverse_proxy",
	        templateUrl: "states/admin/configuration/reverse_proxies/reverse_proxy_form.html",
	        controller: "AdminConfigurationReverseProxyFormController as ReverseProxyForm"
	    });
	}
	
	module.exports = angular.module("configuration.reverse_proxies", []).config(reverseProxiesConfig).controller("AdminConfigurationReverseProxiesController", AdminConfigurationReverseProxiesController).controller("AdminConfigurationReverseProxyFormController", AdminConfigurationReverseProxyFormController);

/***/ }),
/* 195 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminConfigurationReverseProxiesController = exports.AdminConfigurationReverseProxiesController = (function () {
	    function AdminConfigurationReverseProxiesController($scope, ReverseProxiesDao, JFrogGridFactory, JFrogModal, $q, uiGridConstants, commonGridColumns) {
	        _classCallCheck(this, AdminConfigurationReverseProxiesController);
	
	        this.gridOptions = {};
	        this.commonGridColumns = commonGridColumns;
	        this.uiGridConstants = uiGridConstants;
	        this.reverseProxiesDao = ReverseProxiesDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.$scope = $scope;
	        this.$q = $q;
	
	        this._createGrid();
	        this._initReverseProxies();
	    }
	
	    _createClass(AdminConfigurationReverseProxiesController, {
	        _initReverseProxies: {
	            value: function _initReverseProxies() {
	                var _this = this;
	
	                this.reverseProxiesDao.get().$promise.then(function (reverseProxies) {
	                    _this.gridOptions.setGridData(reverseProxies);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setMultiSelect().setButtons(this._getButtons()).setBatchActions(this._getBatchActions()).setRowTemplate("default");
	            }
	        },
	        deleteSelectedReverseProxies: {
	            value: function deleteSelectedReverseProxies() {
	                var _this = this;
	
	                var selectedRows = this.gridOptions.api.selection.getSelectedRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " reverse proxies?").then(function () {
	                    var keys = _.map(selectedRows, function (row) {
	                        return row.key;
	                    });
	                    _this.reverseProxiesDao["delete"]({ proxyKeys: keys }).$promise.then(function () {
	                        return _this._initReverseProxies();
	                    });
	                }).then(function () {
	                    return _this._initReverseProxies();
	                });
	            }
	        },
	        deleteReverseProxy: {
	            value: function deleteReverseProxy(key) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete the reverse proxy '" + key + "'?").then(function () {
	                    return _this._doDeleteReverseProxy(key);
	                }).then(function () {
	                    return _this._initReverseProxies();
	                });
	            }
	        },
	        _doDeleteReverseProxy: {
	            value: function _doDeleteReverseProxy(key) {
	                return this.reverseProxiesDao["delete"]({ proxyKeys: [key] }).$promise;
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "key",
	                    name: "Key",
	                    displayName: "Key",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" ui-sref=\"^.reverse_proxies.edit({reverseProxyKey: row.entity.key})\">{{ COL_FIELD }}</a></div>",
	                    width: "30%"
	                }, {
	                    field: "webServerType",
	                    name: "Web Server Type",
	                    displayName: "Web Server Type",
	                    width: "20%"
	                }, {
	                    field: "serverName",
	                    name: "Server Name",
	                    displayName: "Server Name",
	                    width: "50%"
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedReverseProxies();
	                    }
	                }];
	            }
	        },
	        _getButtons: {
	            value: function _getButtons() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteReverseProxy(row.key);
	                    }
	                }];
	            }
	        }
	    });
	
	    return AdminConfigurationReverseProxiesController;
	})();

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var API = _interopRequire(__webpack_require__(98));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var $state = undefined,
	    $stateParams = undefined,
	    $timeout = undefined,
	    ReverseProxiesDao = undefined,
	    JFrogModal = undefined,
	    ArtifactoryModelSaver = undefined,
	    ArtifactViewsDao = undefined,
	    HaDao = undefined,
	    JFrogIFrameDownload = undefined,
	    ArtifactoryFeatures = undefined;
	
	var AdminConfigurationReverseProxyFormController = exports.AdminConfigurationReverseProxyFormController = (function () {
	    function AdminConfigurationReverseProxyFormController(_$state_, _$stateParams_, _$timeout_, _ReverseProxiesDao_, _JFrogModal_, _ArtifactoryModelSaver_, _ArtifactViewsDao_, _HaDao_, _JFrogIFrameDownload_, _ArtifactoryFeatures_) {
	        _classCallCheck(this, AdminConfigurationReverseProxyFormController);
	
	        ReverseProxiesDao = _ReverseProxiesDao_;
	        $stateParams = _$stateParams_;
	        $state = _$state_;
	        $timeout = _$timeout_;
	        JFrogModal = _JFrogModal_;
	        ArtifactoryModelSaver = _ArtifactoryModelSaver_.createInstance(this, ["reverseProxy"]);
	        ArtifactViewsDao = _ArtifactViewsDao_;
	        HaDao = _HaDao_;
	        JFrogIFrameDownload = _JFrogIFrameDownload_;
	        this.features = _ArtifactoryFeatures_;
	
	        this.selectizeConfig = {
	            sortField: "text",
	            create: false,
	            maxItems: 1
	        };
	
	        this.webServerTypeOptions = [{ text: "Embedded Tomcat", value: "DIRECT", icon: "tomcat" }, { text: "Nginx", value: "NGINX", icon: "nginx" }, { text: "Apache", value: "APACHE", icon: "apache" }];
	        this.dockerReverseProxyMethodSelectizeOptions = [{ text: "Repository Path", value: "REPOPATHPREFIX" }, { text: "Port", value: "PORTPERREPO" }, { text: "Sub Domain", value: "SUBDOMAIN" }];
	
	        this.formTitle = "HTTP Settings";
	        this.TOOLTIP = TOOLTIP.admin.configuration.reverseProxy;
	
	        this._checkHaConfiguration();
	
	        this._initReverseProxy();
	    }
	
	    _createClass(AdminConfigurationReverseProxyFormController, {
	        _checkHaConfiguration: {
	            value: function _checkHaConfiguration() {
	                var _this = this;
	
	                HaDao.query().$promise.then(function (ha) {
	                    _this.haConfigured = ha.length > 0;
	                });
	            }
	        },
	        _initReverseProxy: {
	            value: function _initReverseProxy() {
	                var _this = this;
	
	                ReverseProxiesDao.get({ key: "dummy" }).$promise.then(function (reverseProxy) {
	                    _this.reverseProxy = reverseProxy;
	                    _this.internalIp = _this.reverseProxy.serverName === "localhost" || _this.reverseProxy.serverName === "127.0.0.1";
	                    // console.log(this.reverseProxy);
	                    _this.reverseProxy.key = "nginx";
	                    _this.reverseProxy.serverNameExpression = "*." + (_this.reverseProxy.serverName ? _this.reverseProxy.serverName : "<SERVER_NAME>");
	
	                    _this.reverseProxy.httpPort = _this.reverseProxy.httpPort || 80;
	                    if (_this.reverseProxy.publicAppContext === undefined) _this.reverseProxy.publicAppContext = "artifactory";
	                    // default which is good for embedded tomcat docker.
	                    // this.reverseProxy.artifactoryServerName = this.reverseProxy.artifactoryServerName || 'localhost';
	                    _this.reverseProxy.artifactoryPort = _this.reverseProxy.artifactoryPort || 8081;
	                    if (_this.reverseProxy.artifactoryAppContext === undefined) _this.reverseProxy.artifactoryAppContext = "artifactory";
	                    if (!_this.reverseProxy.useHttp && !_this.reverseProxy.useHttps) _this.reverseProxy.useHttp = true;
	                    _this.reverseProxy.httpsPort = _this.reverseProxy.httpsPort || 443;
	                    _this.reverseProxy.upStreamName = _this.reverseProxy.upStreamName || "artifactory";
	
	                    // this.reverseProxy.dockerReverseProxyMethod = this.reverseProxy.dockerReverseProxyMethod || 'NOVALUE';
	
	                    _this.reverseProxy.webServerType = _.find(_this.webServerTypeOptions, { value: _this.reverseProxy.webServerType });
	                    // if none specified : default to
	                    if (!_this.reverseProxy.webServerType) {
	                        _this.reverseProxy.webServerType = _this.webServerTypeOptions[0];
	                    }
	
	                    ArtifactoryModelSaver.save();
	
	                    $timeout(function () {
	                        _this.gotData = true;
	                    });
	                });
	            }
	        },
	        onChangeServerName: {
	            value: function onChangeServerName() {
	                this.reverseProxy.serverNameExpression = "*." + (this.reverseProxy.serverName ? this.reverseProxy.serverName : "<SERVER_NAME>");
	            }
	        },
	        save: {
	            value: function save() {
	                var publicAppContext = this.reverseProxy.publicAppContext;
	                var artifactoryAppContext = this.reverseProxy.artifactoryAppContext;
	                this.reverseProxy.publicAppContext = publicAppContext.endsWith("/") ? publicAppContext.substr(0, publicAppContext.length - 1) : publicAppContext;
	                this.reverseProxy.artifactoryAppContext = artifactoryAppContext.endsWith("/") ? artifactoryAppContext.substr(0, artifactoryAppContext.length - 1) : artifactoryAppContext;
	
	                this.reverseProxy.publicAppContext = this.reverseProxy.publicAppContext.startsWith("/") ? this.reverseProxy.publicAppContext.substr(1) : this.reverseProxy.publicAppContext;
	                this.reverseProxy.artifactoryAppContext = this.reverseProxy.artifactoryAppContext.startsWith("/") ? this.reverseProxy.artifactoryAppContext.substr(1) : this.reverseProxy.artifactoryAppContext;
	
	                var payload = _.cloneDeep(this.reverseProxy);
	
	                payload.webServerType = payload.webServerType.value;
	                payload.key = payload.webServerType.toLowerCase();
	
	                if (payload.dockerReverseProxyMethod !== "SUBDOMAIN") delete payload.serverNameExpression;
	
	                if (!payload.useHttps) {
	                    delete payload.httpsPort;
	                    delete payload.sslKey;
	                    delete payload.sslCertificate;
	                }
	                if (!payload.useHttp) {
	                    delete payload.httpPort;
	                }
	
	                // console.log("save");
	                // console.log(payload);
	                // console.log(this.reverseProxy);
	                var whenSaved = ReverseProxiesDao.save(payload);
	                whenSaved.$promise.then(function () {
	                    ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        viewSnippet: {
	            value: function viewSnippet() {
	                if (!this.canViewSnippet()) {
	                    return;
	                }ArtifactViewsDao.getDockerProxySnippet({}, { repoKey: "dummy" }).$promise.then(function (data) {
	                    var message = "To use your reverse proxy configuration, copy the snippet below and place it in the sites-enabled folder and reload your reverse proxy server. This will affect Artifactory's reverse proxy configuration, and Docker repositories if you have any configured.";
	                    JFrogModal.launchCodeModal("Reverse Proxy Configuration Snippet", data.template, { name: "text" }, message, "Snippet");
	                });
	            }
	        },
	        downloadSnippet: {
	            value: function downloadSnippet() {
	                if (!this.canViewSnippet()) {
	                    return;
	                }JFrogIFrameDownload("" + API.API_URL + "/views/dockerproxy/dummy?download=true");
	            }
	        },
	        canViewSnippet: {
	            value: function canViewSnippet() {
	                return ArtifactoryModelSaver.isModelSaved() && this.reverseProxyEditForm.$valid;
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;
	
	                ArtifactoryModelSaver.ask(true).then(function () {
	                    _this._initReverseProxy();
	                });
	
	                //        this._end();
	            }
	        },
	        getDockerServerAndPort: {
	
	            // helper representaton functions.
	
	            value: function getDockerServerAndPort() {
	                var name = this.reverseProxy.serverName;
	                var port = this.reverseProxy.httpPort;
	                if (this.reverseProxy.useHttps) {
	                    port = this.reverseProxy.httpsPort;
	                }
	
	                if (this.internalIp) {
	                    name = "<Artifactory Host IP Address>";
	                }
	
	                if (!name) {
	                    name = "<SERVER_NAME>";
	                }
	                if (!port) {
	                    port = "<PORT>";
	                }
	
	                return name + ":" + port;
	            }
	        },
	        isProxyEnabled: {
	            value: function isProxyEnabled() {
	                if (!this.reverseProxy) {
	                    return false;
	                }
	                if (!this.reverseProxy.webServerType) {
	                    return false;
	                }
	
	                if (this.reverseProxy.webServerType.value === "DIRECT") {
	                    return false;
	                }
	                return true;
	            }
	        },
	        changeServerProvider: {
	            value: function changeServerProvider() {
	                if (this.reverseProxy.webServerType.value === "DIRECT") {
	                    this.reverseProxy.useHttps = false;
	                }
	            }
	
	            /*
	                _end() {
	                    $state.go('^.reverse_proxies');
	                }
	            */
	
	        }
	    });
	
	    return AdminConfigurationReverseProxyFormController;
	})();

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationRegisterController = __webpack_require__(198).AdminConfigurationRegisterController;
	
	function registerProConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.register_pro", {
	        params: { feature: "register_pro" },
	        url: "/artifactory_licenses",
	        templateUrl: "states/admin/configuration/register_pro/register_pro.html",
	        controller: "AdminConfigurationRegisterController as AdminConfigurationRegister"
	    });
	}
	
	module.exports = angular.module("configuration.register_pro", []).config(registerProConfig).controller("AdminConfigurationRegisterController", AdminConfigurationRegisterController);

/***/ }),
/* 198 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminConfigurationRegisterController = exports.AdminConfigurationRegisterController = (function () {
	    function AdminConfigurationRegisterController(User, $state, FooterDao) {
	        _classCallCheck(this, AdminConfigurationRegisterController);
	
	        this.$state = $state;
	        this.User = User;
	        this.footerDao = FooterDao;
	        this.initHa();
	    }
	
	    _createClass(AdminConfigurationRegisterController, {
	        initHa: {
	            value: function initHa() {
	                var _this = this;
	
	                this.footerDao.get().then(function (footerData) {
	                    _this.isHaConfigured = footerData.haConfigured;
	                });
	            }
	        }
	    });
	
	    return AdminConfigurationRegisterController;
	})();

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationBintrayController = __webpack_require__(200).AdminConfigurationBintrayController;
	
	function bintrayConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.bintray", {
	        url: "/bintray",
	        templateUrl: "states/admin/configuration/bintray/bintray.html",
	        controller: "AdminConfigurationBintrayController as AdminConfigurationBintray"
	    });
	}
	
	module.exports = angular.module("configuration.bintray", []).config(bintrayConfig).controller("AdminConfigurationBintrayController", AdminConfigurationBintrayController);

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminConfigurationBintrayController = exports.AdminConfigurationBintrayController = (function () {
	    function AdminConfigurationBintrayController(BintrayDao) {
	        _classCallCheck(this, AdminConfigurationBintrayController);
	
	        this.bintrayDao = BintrayDao.getInstance();
	        this.TOOLTIP = TOOLTIP.admin.configuration.bintray;
	        this._init();
	    }
	
	    _createClass(AdminConfigurationBintrayController, {
	        _init: {
	            value: function _init() {
	                var _this = this;
	
	                this.bintrayDao.get().$promise.then(function (data) {
	                    _this.bintray = data;
	                    _this.bintray.fileUploadLimit = data.fileUploadLimit || 0;
	                });
	            }
	        },
	        save: {
	            value: function save(bintray) {
	                this.bintrayDao.update(bintray);
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._init();
	            }
	        },
	        fullCredentials: {
	            value: function fullCredentials() {
	                return this.bintray && this.bintray.userName && this.bintray.apiKey;
	            }
	        },
	        testBintray: {
	            value: function testBintray() {
	                this.bintrayDao.save(this.bintray).$promise.then(function (data) {});
	            }
	        }
	    });
	
	    return AdminConfigurationBintrayController;
	})();

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationGeneralController = __webpack_require__(202).AdminConfigurationGeneralController;
	
	function generalConfig($stateProvider) {
	
	    $stateProvider.state("admin.configuration.general", {
	        url: "/general",
	        params: { focusOnBaseUrl: false },
	        templateUrl: "states/admin/configuration/general/general.html",
	        controller: "AdminConfigurationGeneralController as AdminConfiguration"
	    });
	}
	
	module.exports = angular.module("configuration.general", []).config(generalConfig).controller("AdminConfigurationGeneralController", AdminConfigurationGeneralController);

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var API = _interopRequire(__webpack_require__(98));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminConfigurationGeneralController = exports.AdminConfigurationGeneralController = (function () {
	    function AdminConfigurationGeneralController($scope, $q, $timeout, $stateParams, FileUploader, JFrogNotifications, GeneralConfigDao, FooterDao, JFrogEventBus, ArtifactoryModelSaver, ArtifactActionsDao, JFrogModal, ArtifactoryFeatures) {
	        _classCallCheck(this, AdminConfigurationGeneralController);
	
	        this.$scope = $scope;
	        this.$q = $q;
	        this.$timeout = $timeout;
	        this.$stateParams = $stateParams;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.generalConfigDao = GeneralConfigDao;
	        this.footerDao = FooterDao;
	        this.FileUploader = FileUploader;
	        this.modal = JFrogModal;
	        this.features = ArtifactoryFeatures;
	        this.logoType = "File";
	        this.defaultLogoUrl = "images/artifactory_logo.467.svg";
	        if (this.features.isJCR()) this.defaultLogoUrl = "images/jcr_logo.467.svg";
	        this.logoEndPoint = "" + API.API_URL + "/generalConfig/logo";
	        this.TOOLTIP = TOOLTIP.admin.configuration.general;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["generalConfigData"]);
	
	        this.deleteUserLogo = false;
	
	        this._initUploader();
	
	        this._getGeneralConfigData();
	    }
	
	    _createClass(AdminConfigurationGeneralController, {
	        customMessageToggle: {
	            value: function customMessageToggle() {
	                this.toggleColorPicker();
	            }
	        },
	        toggleColorPicker: {
	            value: function toggleColorPicker() {
	                $(".color-picker-input").prop("disabled", !this.generalConfigData.systemMessageEnabled);
	            }
	        },
	        _getGeneralConfigData: {
	            value: function _getGeneralConfigData() {
	                var _this = this;
	
	                this.generalConfigDao.get().$promise.then(function (data) {
	                    _this.generalConfigData = data;
	                    _this.blockReplications = data.blockPushReplications || data.blockPullReplications;
	                    _this.generalConfigData.systemMessageTitleColor = _this.generalConfigData.systemMessageTitleColor.toUpperCase();
	
	                    if (_this.features.isJCR() && _this.generalConfigData.subscription && _this.generalConfigData.subscription.emails.length) {
	                        _this.emails = _this.generalConfigData.subscription.emails.join(",");
	                    }
	
	                    _this.ArtifactoryModelSaver.save();
	                    _this._getCurrentImage();
	                    if (_this.generalConfigData.systemMessageEnabled == false) {
	                        _this.toggleColorPicker();
	                    }
	                });
	            }
	        },
	        _getCurrentImage: {
	            value: function _getCurrentImage() {
	                var _this = this;
	
	                this._userLogoExists().then(function () {
	                    $(".artifactory-logo img")[0].src = _this.logoEndPoint;
	                })["catch"](function () {
	                    if (_this.generalConfigData.logoUrl) {
	                        _this.logoUrlInput = _this.generalConfigData.logoUrl;
	                        $(".artifactory-logo img")[0].src = _this.generalConfigData.logoUrl;
	                    } else {
	                        $(".artifactory-logo img")[0].src = _this.defaultLogoUrl;
	                    }
	                });
	            }
	        },
	        _updateGeneralConfigData: {
	            value: function _updateGeneralConfigData() {
	                var _this = this;
	
	                this.generalConfigDao.update(this.generalConfigData).$promise.then(function (data) {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.JFrogEventBus.dispatch(EVENTS.FOOTER_DATA_UPDATED);
	                });
	            }
	        },
	        _deleteUploadedPicture: {
	            value: function _deleteUploadedPicture() {
	                this.generalConfigDao.deleteLogo().$promise.then(function (data) {});
	            }
	        },
	        _initUploader: {
	            value: function _initUploader() {
	                this.uploader = new this.FileUploader();
	
	                this.uploader.url = this.logoEndPoint;
	                this.uploader.headers = { "X-Requested-With": "artUI" };
	                this.uploader.onSuccessItem = this.onUploadSuccess.bind(this);
	            }
	        },
	        isSelectedLogoType: {
	            value: function isSelectedLogoType(type) {
	                return this.logoType === type;
	            }
	        },
	        onUploadSuccess: {
	            value: function onUploadSuccess() {
	                //        console.log('onUploadSuccess');
	                //        this.generalConfigData.logoUrl = this.logoEndPoint;
	                this.logoUrlInput = undefined;
	                this._updateGeneralConfigData();
	                this.uploader.clearQueue();
	            }
	        },
	        onAfterAddingFile: {
	            value: function onAfterAddingFile(fileItem) {
	                var _this = this;
	
	                this.assertImage(fileItem._file).then(function () {
	                    _this.logoFile = fileItem.file.name;
	                    _this.showPreview(fileItem._file);
	                })["catch"](function (err) {
	                    _this.artifactoryNotifications.create({ error: err });
	                    _this.uploader.clearQueue();
	                });
	            }
	        },
	        assertImage: {
	            value: function assertImage(file) {
	
	                var deferred = this.$q.defer();
	
	                var reader = new FileReader();
	                reader.onload = function (e) {
	                    var buffer = reader.result;
	                    var uInt8View = new Uint8Array(buffer);
	                    var int32Sample = uInt8View[3] + uInt8View[2] * 256 + uInt8View[1] * (256 * 256) + uInt8View[0] * (256 * 256 * 256);
	
	                    switch (int32Sample) {
	                        case 2303741511: //png
	                        case 1195984440: //gif
	                        case 1112360694: //bmp
	                        case 4292411360:case 4292411361:
	                            //jpg
	                            //case 1010792557: case 1014199911: //svg
	                            deferred.resolve();
	                            break;
	                        default:
	                            deferred.reject("Not an image file!");
	                            break;
	                    }
	                };
	                reader.readAsArrayBuffer(file);
	
	                return deferred.promise;
	            }
	        },
	        showPreview: {
	            value: function showPreview(file) {
	                if (typeof FileReader !== "undefined" && /image/i.test(file.type)) {
	                    var img = $(".artifactory-logo img")[0];
	                    var reader = new FileReader();
	                    reader.onload = (function (theImg) {
	                        return function (evt) {
	                            theImg.src = evt.target.result;
	                        };
	                    })(img);
	                    reader.readAsDataURL(file);
	                }
	            }
	        },
	        clearLookAndFeel: {
	            value: function clearLookAndFeel() {
	                var _this = this;
	
	                this.generalConfigData.logoUrl = ""; //this.defaultLogoUrl;
	                this.logoUrlInput = undefined;
	                this.uploader.clearQueue();
	                this.logoFile = undefined;
	
	                this.deleteUserLogo = true;
	
	                this.$timeout(function () {
	                    $(".artifactory-logo img")[0].src = _this.defaultLogoUrl;
	                });
	            }
	        },
	        clear: {
	            value: function clear() {
	                this.generalConfigData.customUrlBase = "";
	                this.clearLookAndFeel();
	            }
	        },
	        save: {
	            value: function save() {
	                if (this.isSelectedLogoType("File") && this.uploader.queue.length) {
	                    this.uploader.uploadAll();
	                } else {
	                    if (this.deleteUserLogo) this._deleteUploadedPicture();
	                    this._updateGeneralConfigData();
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.clear();
	                    _this._getGeneralConfigData();
	                });
	            }
	        },
	        onChangeLogoUrl: {
	            value: function onChangeLogoUrl() {
	                var _this = this;
	
	                var form = this.$scope.formGeneral;
	                if (this.logoUrlInput && !form.logoUrlInput.$invalid) {
	                    this._imageExists(this.logoUrlInput).then(function () {
	                        _this.generalConfigData.logoUrl = _this.logoUrlInput;
	                        _this.deleteUserLogo = true;
	                    })["catch"](function (err) {
	                        return console.log(err);
	                    });
	                }
	            }
	        },
	        _userLogoExists: {
	            value: function _userLogoExists() {
	                var deferred = this.$q.defer();
	                this.footerDao.get(true).then(function (footerData) {
	                    if (footerData.userLogo) {
	                        deferred.resolve();
	                    } else {
	                        deferred.reject();
	                    }
	                });
	                return deferred.promise;
	            }
	        },
	        _imageExists: {
	            value: function _imageExists(url) {
	                var deferred = this.$q.defer();
	                var img = new Image();
	                img.onload = function () {
	                    deferred.resolve();
	                };
	                img.onerror = function () {
	                    deferred.reject("no image found");
	                };
	                img.src = url;
	                return deferred.promise;
	            }
	        },
	        emptyTrashcan: {
	            value: function emptyTrashcan() {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to empty the trash can?", "Empty Trash", { confirm: "Empty Trash" }).then(function () {
	                    return _this.artifactActionsDao.perform({ action: "emptytrash" }, {});
	                });
	            }
	        },
	        onChangeBlockReplications: {
	            value: function onChangeBlockReplications() {
	                this.generalConfigData.blockPushReplications = this.blockReplications;
	                this.generalConfigData.blockPullReplications = this.blockReplications;
	            }
	        },
	        onChangePushPullReplications: {
	            value: function onChangePushPullReplications() {
	                this.blockReplications = this.generalConfigData.blockPushReplications || this.generalConfigData.blockPullReplications;
	            }
	        },
	        onChangeFolderDownload: {
	            value: function onChangeFolderDownload() {
	                this.generalConfigData.folderDownloadEnabledForAnonymous = false;
	            }
	        },
	        onChangeEmails: {
	            value: function onChangeEmails() {
	                var emails = _.map(this.emails.split(","), function (email) {
	                    return email.trim();
	                });
	                this.generalConfigData.subscription = { emails: emails };
	            }
	        }
	    });
	
	    return AdminConfigurationGeneralController;
	})();

	//            console.log(data);

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationPropertySetsController = __webpack_require__(204).AdminConfigurationPropertySetsController;
	
	var AdminConfigurationPropertySetFormController = __webpack_require__(205).AdminConfigurationPropertySetFormController;
	
	var PropertyFormModalFactory = __webpack_require__(206).PropertyFormModalFactory;
	
	function propertySetsConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.property_sets", {
	        params: { feature: "properties" },
	        url: "/property_sets",
	        controller: "AdminConfigurationPropertySetsController as PropertySets",
	        templateUrl: "states/admin/configuration/property_sets/property_sets.html"
	    }).state("admin.configuration.property_sets.edit", {
	        params: { feature: "properties" },
	        parent: "admin.configuration",
	        url: "/property_sets/{propertySetName}/edit",
	        templateUrl: "states/admin/configuration/property_sets/property_set_form.html",
	        controller: "AdminConfigurationPropertySetFormController as PropertySetForm"
	    }).state("admin.configuration.property_sets.new", {
	        params: { feature: "properties" },
	        parent: "admin.configuration",
	        url: "/property_sets/new",
	        templateUrl: "states/admin/configuration/property_sets/property_set_form.html",
	        controller: "AdminConfigurationPropertySetFormController as PropertySetForm"
	    });
	}
	
	module.exports = angular.module("configuration.property_sets", []).config(propertySetsConfig).controller("AdminConfigurationPropertySetsController", AdminConfigurationPropertySetsController).controller("AdminConfigurationPropertySetFormController", AdminConfigurationPropertySetFormController).factory("PropertyFormModal", PropertyFormModalFactory);

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var $timeout = undefined,
	    Property = undefined,
	    PropertySet = undefined,
	    uiGridConstants = undefined;
	
	var AdminConfigurationPropertySetsController = exports.AdminConfigurationPropertySetsController = (function () {
	    function AdminConfigurationPropertySetsController($scope, PropertySetsDao, JFrogGridFactory, ArtifactoryFeatures, _$timeout_, _Property_, _PropertySet_, JFrogModal, _uiGridConstants_) {
	        _classCallCheck(this, AdminConfigurationPropertySetsController);
	
	        $timeout = _$timeout_;
	        this.propertySetsDao = PropertySetsDao;
	        this.$scope = $scope;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.features = ArtifactoryFeatures;
	        Property = _Property_;
	        PropertySet = _PropertySet_;
	        uiGridConstants = _uiGridConstants_;
	        this.propertySets = {};
	        this.noSetsMessage = this.features.isJCR() ? CONFIG_MESSAGES.admin.configuration.propertySets.noSetsMessageJCR : CONFIG_MESSAGES.admin.configuration.propertySets.noSetsMessage;
	        this._createGrid();
	        this._initPropertySets();
	    }
	
	    _createClass(AdminConfigurationPropertySetsController, {
	        _initPropertySets: {
	            value: function _initPropertySets() {
	                var _this = this;
	
	                this.propertySetsDao.query().$promise.then(function (propertySets) {
	                    _this.propertySets = propertySets.map(function (propertySet) {
	                        return new PropertySet(propertySet);
	                    });
	                    _this.gridOptions.setGridData(_this.propertySets);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        deletePropertySet: {
	            value: function deletePropertySet(propertySet) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete the property set '" + propertySet.name + "?'").then(function () {
	                    var json = { propertySetNames: [propertySet.name] };
	                    _this.propertySetsDao["delete"](json).$promise.then(function () {
	                        return _this._initPropertySets();
	                    });
	                });
	            }
	        },
	        deleteSelectedPropertySets: {
	            value: function deleteSelectedPropertySets() {
	                var _this = this;
	
	                //Get All selected users
	                var selectedRows = this.gridOptions.api.selection.getSelectedGridRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " property sets?").then(function () {
	                    //Create an array of the selected propertySet names
	                    var names = selectedRows.map(function (row) {
	                        return row.entity.name;
	                    });
	                    //Delete bulk of property sets
	                    _this.propertySetsDao["delete"]({ propertySetNames: names }).$promise.then(function () {
	                        return _this._initPropertySets();
	                    });
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "name",
	                    name: "Property Set Name",
	                    displayName: "Property Set Name",
	                    sort: {
	                        direction: uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.property_sets.edit({propertySetName: row.entity.name})\" class=\"jf-link text-center ui-grid-cell-contents\">{{row.entity.name}}</a></div>"
	                }, {
	                    field: "propertiesCount",
	                    name: "Properties Count",
	                    displayName: "Properties Count"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (propertySet) {
	                        return _this.deletePropertySet(propertySet);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedPropertySets();
	                    }
	                }];
	            }
	        }
	    });
	
	    return AdminConfigurationPropertySetsController;
	})();

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	// Injectables:
	var $q = undefined,
	    $scope = undefined,
	    $state = undefined,
	    $stateParams = undefined,
	    JFrogGridFactory = undefined,
	    PropertySetsDao = undefined,
	    PropertyFormModal = undefined,
	    Property = undefined,
	    PropertySet = undefined,
	    uiGridConstants = undefined,
	    JFrogModal = undefined,
	    ArtifactoryModelSaver = undefined;
	
	var AdminConfigurationPropertySetFormController = exports.AdminConfigurationPropertySetFormController = (function () {
	    function AdminConfigurationPropertySetFormController(_$stateParams_, _$scope_, _PropertySetsDao_, _$state_, _JFrogGridFactory_, _PropertyFormModal_, ArtifactoryState, _$q_, _Property_, _PropertySet_, _uiGridConstants_, _JFrogModal_, _ArtifactoryModelSaver_) {
	        _classCallCheck(this, AdminConfigurationPropertySetFormController);
	
	        $scope = _$scope_;
	        $state = _$state_;
	        $stateParams = _$stateParams_;
	        Property = _Property_;
	        PropertySet = _PropertySet_;
	        JFrogModal = _JFrogModal_;
	        ArtifactoryModelSaver = _ArtifactoryModelSaver_.createInstance(this, ["propertySet"]);;
	
	        this.isNew = !$stateParams.propertySetName;
	        PropertySetsDao = _PropertySetsDao_;
	        PropertyFormModal = _PropertyFormModal_;
	        JFrogGridFactory = _JFrogGridFactory_;
	        $q = _$q_;
	        uiGridConstants = _uiGridConstants_;
	
	        this.TOOLTIP = TOOLTIP.admin.configuration.propertySetsForm;
	        this._createGrid();
	        this._initPropertySet();
	        ArtifactoryState.setState("prevState", $state.current);
	    }
	
	    _createClass(AdminConfigurationPropertySetFormController, {
	        _initPropertySet: {
	            value: function _initPropertySet() {
	                var _this = this;
	
	                var promise = undefined;
	                if (this.isNew) {
	                    promise = $q.when();
	                } else {
	                    promise = PropertySetsDao.get({ name: $stateParams.propertySetName }).$promise;
	                }
	                promise.then(function (propertySet) {
	                    _this.propertySet = new PropertySet(propertySet);
	                    ArtifactoryModelSaver.save();
	                    _this.gridOptions.setGridData(_this.propertySet.properties);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = JFrogGridFactory.getGridInstance($scope).setColumns(this.getColumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	
	                var whenSaved = this.isNew ? PropertySetsDao.save(this.propertySet) : PropertySetsDao.update(this.propertySet);
	                whenSaved.$promise.then(function () {
	                    ArtifactoryModelSaver.save();
	                    _this._end();
	                    _this.savePending = false;
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.property_sets");
	            }
	        },
	        editProperty: {
	            value: function editProperty(property) {
	                // (Adam) Don't take the actual property object because it's different after filtering the GRID
	                // Instead, we find the property in the original propertySet
	                property = this.propertySet.getPropertyByName(property.name);
	                this._launchPropertyEditor(property, false);
	            }
	        },
	        newProperty: {
	            value: function newProperty(e) {
	                e.preventDefault();
	                var property = new Property();
	                this._launchPropertyEditor(property, true);
	            }
	        },
	        _launchPropertyEditor: {
	            value: function _launchPropertyEditor(property, isNew) {
	                var _this = this;
	
	                new PropertyFormModal(this.propertySet, property, isNew).launch().then(function () {
	                    if (isNew) {
	                        _this.propertySet.addProperty(property);
	                    }
	                    // (Adam) Must reset the data, because of the filter
	                    _this.gridOptions.setGridData(_this.propertySet.properties);
	                });
	            }
	        },
	        _doDeleteProperty: {
	            value: function _doDeleteProperty(property) {
	                this.propertySet.removeProperty(property.name);
	            }
	        },
	        deleteProperty: {
	            value: function deleteProperty(property) {
	                var _this = this;
	
	                JFrogModal.confirm("Are you sure you want to delete the property '" + property.name + "?'").then(function () {
	                    _this._doDeleteProperty(property);
	                    _this.gridOptions.setGridData(_this.propertySet.properties);
	                });
	            }
	        },
	        deleteSelectedProperties: {
	            value: function deleteSelectedProperties() {
	                var _this = this;
	
	                var selectedRows = this.gridOptions.api.selection.getSelectedGridRows();
	                JFrogModal.confirm("Are you sure you want to delete " + selectedRows.length + " properties?").then(function () {
	                    selectedRows.forEach(function (row) {
	                        return _this._doDeleteProperty(row.entity);
	                    });
	                    _this.gridOptions.setGridData(_this.propertySet.properties);
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "name",
	                    name: "Property Name",
	                    displayName: "Property Name",
	                    sort: {
	                        direction: uiGridConstants.ASC
	                    },
	                    cellTemplate: "\n                    <div class=\"ui-grid-cell-contents\">\n                        <a  href=\"\"\n                            ng-click=\"grid.appScope.PropertySetForm.editProperty(row.entity)\"\n                            class=\"jf-link text-center ui-grid-cell-contents\">{{row.entity.name}}</a>\n                    </div>"
	                }, {
	                    name: "Value Type",
	                    displayName: "Value Type",
	                    field: "propertyType",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.getDisplayType() }}</div>"
	                }, {
	                    field: "predefinedValues",
	                    name: "Predefined Values",
	                    displayName: "Predefined Values",
	                    cellTemplate: "\n                    <div style=\"padding-left: 10px;  white-space: nowrap; overflow-x: auto;\">\n                        <div class=\"item\" ng-repeat=\"value in row.entity.predefinedValues\">\n                            {{value.value}}<span ng-if=\"value.defaultValue\"> (default)</span>\n                        </div>\n                    </div>\n                "
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (propertySet) {
	                        return _this.deleteProperty(propertySet);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedProperties();
	                    }
	                }];
	            }
	        }
	    });
	
	    return AdminConfigurationPropertySetFormController;
	})();

/***/ }),
/* 206 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.PropertyFormModalFactory = PropertyFormModalFactory;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	// modal
	var $rootScope = undefined;
	var JFrogModal = undefined;
	var Property = undefined,
	    PropertySet = undefined;
	
	var PropertyFormModal = (function () {
	    function PropertyFormModal(propertySet, property, isNew) {
	        _classCallCheck(this, PropertyFormModal);
	
	        this.scope = $rootScope.$new();
	        this.scope.PropertyForm = this;
	        this.isNew = isNew;
	        this.originalProperty = property;
	        this.property = angular.copy(this.originalProperty);
	        this.propertySet = propertySet;
	        this.propertyTypes = Property.propertyTypes;
	    }
	
	    _createClass(PropertyFormModal, {
	        launch: {
	            value: function launch() {
	                this.modalInstance = JFrogModal.launchModal("property_form_modal", this.scope);
	                return this.modalInstance.result;
	            }
	        },
	        save: {
	            value: function save() {
	                angular.copy(this.property, this.originalProperty);
	                this.modalInstance.close();
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.modalInstance.dismiss();
	            }
	        },
	        isPropertyUnique: {
	            value: function isPropertyUnique(propertyName) {
	                return propertyName === this.originalProperty.name || !this.propertySet.getPropertyByName(propertyName);
	            }
	        },
	        isPredefinedValuesValid: {
	            value: function isPredefinedValuesValid() {
	                if (this.property.propertyType === "ANY_VALUE") {
	                    return true; // Any Value allows no predefined values
	                } else {
	                    return this.property.predefinedValues.length; // Other types must have predefined values
	                }
	            }
	        },
	        isDefaultValuesValid: {
	            value: function isDefaultValuesValid(propertyType) {
	                if (propertyType === "MULTI_SELECT") {
	                    return true;
	                }return this.property.getDefaultValues().length < 2;
	            }
	        },
	        invalidateType: {
	            value: function invalidateType() {
	                // By changing the property we use in ui-validate-watch, we force the validation on propertyType to run again
	                this.propertyTypeWatch = this.propertyTypeWatch || 0;
	                this.propertyTypeWatch++;
	            }
	        },
	        getPredefinedValuesStr: {
	            value: function getPredefinedValuesStr() {
	                // This is for watching the propertyType value
	                return JSON.stringify(this.property.predefinedValues);
	            }
	        },
	        removeValue: {
	            value: function removeValue(value) {
	                _.remove(this.property.predefinedValues, value);
	                this.invalidateType();
	            }
	        },
	        addValue: {
	            value: function addValue() {
	                this.newValue = $("#newPredefinedValueName").val();
	                this.errorMessage = null;
	
	                if (this._isValueEmpty(this.newValue)) {
	                    this.errorMessage = "Must input value";
	                } else if (!this._isValueUnique(this.newValue)) {
	                    this.errorMessage = "Value already exists";
	                } else {
	                    this.property.addPredefinedValue(this.newValue);
	                    this.newValue = null;
	                    $("#newPredefinedValueName").val("");
	                    this.invalidateType();
	                }
	            }
	        },
	        _isValueEmpty: {
	            value: function _isValueEmpty(text) {
	                return _.isEmpty(text);
	            }
	        },
	        _isValueUnique: {
	            value: function _isValueUnique(text) {
	                return !this.property.getPredefinedValue(text);
	            }
	        }
	    });
	
	    return PropertyFormModal;
	})();
	
	function PropertyFormModalFactory(_$rootScope_, _JFrogModal_, _Property_, _PropertySet_) {
	    Property = _Property_;
	    PropertySet = _PropertySet_;
	    $rootScope = _$rootScope_;
	    JFrogModal = _JFrogModal_;
	    return PropertyFormModal;
	}

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminConfigurationHAController = __webpack_require__(208).AdminConfigurationHAController;
	
	function haConfig($stateProvider) {
	    $stateProvider.state("admin.configuration.ha", {
	        params: { feature: "highavailability" },
	        url: "/ha",
	        templateUrl: "states/admin/configuration/ha/ha.html",
	        controller: "AdminConfigurationHAController as AdminConfigurationHA"
	    });
	}
	
	module.exports = angular.module("configuration.ha", []).config(haConfig).controller("AdminConfigurationHAController", AdminConfigurationHAController);

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var HaDao = undefined,
	    $scope = undefined,
	    artifactoryGridFactory = undefined,
	    modal = undefined;
	
	var AdminConfigurationHAController = exports.AdminConfigurationHAController = (function () {
	    function AdminConfigurationHAController(_$scope_, _JFrogModal_, _HaDao_, _JFrogGridFactory_, _ArtifactoryState_) {
	        _classCallCheck(this, AdminConfigurationHAController);
	
	        HaDao = _HaDao_;
	        $scope = _$scope_;
	        artifactoryGridFactory = _JFrogGridFactory_;
	        modal = _JFrogModal_;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.admin.configuration.ha;
	
	        this.gridOptions = {};
	        this._createGrid();
	        this._initHa();
	    }
	
	    _createClass(AdminConfigurationHAController, {
	        _initHa: {
	            value: function _initHa() {
	                var _this = this;
	
	                HaDao.query().$promise.then(function (ha) {
	                    _this.ha = ha;
	                    _this.gridOptions.setGridData(_this.ha);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = artifactoryGridFactory.getGridInstance($scope).setColumns(this._getColumns()).setButtons(this._getActions()).setRowTemplate("default");
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "id",
	                    name: "Node ID",
	                    displayName: "Node ID",
	                    width: "7%" }, {
	                    field: "startTime",
	                    name: "Start Time",
	                    displayName: "Start Time",
	                    width: "9%"
	                }, {
	                    field: "url",
	                    name: "URL",
	                    displayName: "URL",
	                    width: "18%",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" target=\"_blank\" href=\"{{ COL_FIELD }}\">{{ COL_FIELD }}</a></div>"
	                }, {
	                    field: "memberShipPort",
	                    name: "Membership Port",
	                    displayName: "Membership Port",
	                    width: "11%"
	                }, {
	                    field: "state",
	                    name: "State",
	                    displayName: "State",
	                    width: "11%",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ COL_FIELD }}" + "<span class=\"ha-node-has-no-license\"\n                                      ng-if=\"!row.entity.hasLicense\"\n                                      jf-tooltip=\"No license installed.\">&nbsp;(Inactive)</span>\n                               </div>"
	                }, {
	                    field: "role",
	                    name: "Role",
	                    displayName: "Role",
	                    width: "8%"
	                }, {
	                    field: "lastHeartbeat",
	                    name: "Last Heartbeat",
	                    displayName: "Last Heartbeat",
	                    width: "11%",
	                    cellTemplate: "\n                    <div ng-if=\"row.entity.heartbeatStale\"\n                         class=\"ui-grid-cell-contents ha-heartbeat-stale\"\n                         jf-tooltip=\"Heartbeat is stale. Check if your server is down.\"><i class=\"icon icon-notif-warning\"></i>{{ COL_FIELD }}</div>\n                    <div ng-if=\"!row.entity.heartbeatStale\"\n                         class=\"ui-grid-cell-contents\">{{ COL_FIELD }}</div>\n                         "
	                }, {
	                    field: "version",
	                    name: "Version",
	                    displayName: "Version",
	                    width: "9%"
	                }, {
	                    field: "revision",
	                    name: "Revision",
	                    displayName: "Revision",
	                    width: "6%"
	                }, {
	                    field: "releaseDate",
	                    name: "Release Date",
	                    displayName: "Release Date",
	                    width: "10%"
	                }];
	            }
	        },
	        _deleteNode: {
	            value: function _deleteNode(node) {
	                var _this = this;
	
	                modal.confirm("Are you sure you wish to remove " + node.id + " from the nodes list?").then(function () {
	                    return HaDao["delete"]({ id: node.id });
	                }).then(function () {
	                    return _this._initHa();
	                });
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    visibleWhen: function (node) {
	                        return node.heartbeatStale;
	                    },
	                    callback: function (node) {
	                        return _this._deleteNode(node);
	                    }
	                }];
	            }
	        }
	    });
	
	    return AdminConfigurationHAController;
	})();

/***/ }),
/* 209 */
/***/ (function(module, exports) {

	"use strict";
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminConfigurationController = exports.AdminConfigurationController = function AdminConfigurationController() {
	    _classCallCheck(this, AdminConfigurationController);
	
	    var AdminConfiguration = this;
	    AdminConfiguration.stateUrl = "/configuration";
	    AdminConfiguration.controllerName = "idan";
	};

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminRepositoriesController = __webpack_require__(211).AdminRepositoriesController;
	
	var AdminRepositoryFormController = __webpack_require__(213).AdminRepositoryFormController;
	
	var VirtualRepositoryFormController = __webpack_require__(214).VirtualRepositoryFormController;
	
	var AdminRepositoriesLayoutController = __webpack_require__(215).AdminRepositoriesLayoutController;
	
	var AdminRepositoryLayoutFormController = __webpack_require__(216).AdminRepositoryLayoutFormController;
	
	function repositoriesConfig($stateProvider) {
	    $stateProvider
	    // base state
	    .state("admin.repositories", {
	        url: "",
	        abstract: true,
	        template: "<ui-view></ui-view>"
	    })
	
	    // repository list and forms
	    .state("admin.repositories.list", {
	        url: "/repositories/{repoType}",
	        templateUrl: "states/admin/repositories/repositories.html",
	        controller: "AdminRepositoriesController as Repositories",
	        params: {
	            action: null
	        }
	    }).state("admin.repositories.list.edit", {
	        parent: "admin.repositories",
	        url: "/repository/{repoType}/{repoKey}/{distRepoType}/edit",
	        templateUrl: "states/admin/repositories/repository_form.html",
	        controller: "AdminRepositoryFormController as RepositoryForm",
	        params: {
	            distRepoType: {
	                squash: true,
	                value: null
	            }
	        }
	    }).state("admin.repositories.list.new", {
	        parent: "admin.repositories",
	        url: "/repository/{repoType}/{distRepoType}/new",
	        templateUrl: "states/admin/repositories/repository_form.html",
	        controller: "AdminRepositoryFormController as RepositoryForm",
	        params: {
	            distRepoType: {
	                squash: true,
	                value: null
	            }
	        }
	    })
	
	    // repository layout list and forms
	    .state("admin.repositories.repo_layouts", {
	        url: "/repo_layouts",
	        templateUrl: "states/admin/repositories/repositories_layouts.html",
	        controller: "AdminRepositoriesLayoutController as RepositoriesLayoutController"
	    }).state("admin.repositories.repo_layouts.edit", {
	        parent: "admin.repositories",
	        url: "/repo_layouts/{layoutname}/edit",
	        templateUrl: "states/admin/repositories/repository_layout_form.html",
	        controller: "AdminRepositoryLayoutFormController as RepositoryLayoutForm",
	        params: { viewOnly: true }
	    }).state("admin.repositories.repo_layouts.new", {
	        parent: "admin.repositories",
	        url: "/repo_layouts/new?copyFrom",
	        templateUrl: "states/admin/repositories/repository_layout_form.html",
	        controller: "AdminRepositoryLayoutFormController as RepositoryLayoutForm"
	    });
	}
	
	module.exports = angular.module("admin.repositories", []).config(repositoriesConfig).controller("AdminRepositoriesController", AdminRepositoriesController).controller("AdminRepositoryFormController", AdminRepositoryFormController).controller("VirtualRepositoryFormController", VirtualRepositoryFormController).controller("AdminRepositoriesLayoutController", AdminRepositoriesLayoutController).controller("AdminRepositoryLayoutFormController", AdminRepositoryLayoutFormController);

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var FIELD_OPTIONS = _interopRequire(__webpack_require__(135));
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var REPO_FORM_CONSTANTS = __webpack_require__(212).REPO_FORM_CONSTANTS;
	
	var AdminRepositoriesController = exports.AdminRepositoriesController = (function () {
	    function AdminRepositoriesController($scope, $state, JFrogGridFactory, RepositoriesDao, JFrogModal, uiGridConstants, ArtifactActionsDao, ArtifactoryFeatures, commonGridColumns, GlobalReplicationsConfigDao, JFrogEventBus, $stateParams, $timeout) {
	        var _this = this;
	
	        _classCallCheck(this, AdminRepositoriesController);
	
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.commonGridColumns = commonGridColumns;
	        this.repositoriesDao = RepositoriesDao;
	        this.globalReplicationsConfigDao = GlobalReplicationsConfigDao;
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.modal = JFrogModal;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.admin.repositories;
	        this.features = ArtifactoryFeatures;
	        this.currentRepoType = $state.params.repoType;
	        this.gridData = {};
	        this.JFrogEventBus = JFrogEventBus;
	        if (!_.includes(["local", "remote", "virtual", "distribution"], this.currentRepoType)) {
	            this.$state.go("not_found_404");
	            return;
	        }
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this._initRepos();
	        });
	
	        this._createGrid();
	        this._initRepos();
	        this._getGlobalReplicationsStatus();
	    }
	
	    _createClass(AdminRepositoriesController, {
	        $onInit: {
	            value: function $onInit() {
	                var _this = this;
	
	                if (this.$stateParams.action === "openCreationDropdowns") {
	                    this.$timeout(function () {
	                        _this.quickActions.showDropdown();
	                    });
	                }
	            }
	        },
	        isCurrentRepoType: {
	            value: function isCurrentRepoType(type) {
	                return this.currentRepoType == type;
	            }
	        },
	        _createGrid: {
	
	            /**
	             * Creates the grid according to current repo type, sets draggable according to the global repo status
	             * NOTE: Multi select and batch actions are commented until batch delete repos is approved for prod.
	             */
	
	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setSingleSelect();
	                //.setBatchActions(this._getBatchActions())
	                this.gridOption.setRowTemplate("default");
	            }
	        },
	        _initRepos: {
	            value: function _initRepos() {
	                var _this = this;
	
	                this.repositoriesDao.getRepositories({ type: this.currentRepoType }).$promise.then(function (data) {
	                    _this.noReposMessage = _this.CONFIG_MESSAGES[_this.currentRepoType].noReposMessage;
	                    if (_this.features.isJCR()) _this.noReposMessage = _this.CONFIG_MESSAGES[_this.currentRepoType].noReposMessageJCR;
	                    if (_this.features.isEnterprisePlus() && _this.currentRepoType === FIELD_OPTIONS.REPO_TYPE.DISTRIBUTION) {
	                        _this.noReposMessage += "<br>" + _this.CONFIG_MESSAGES[_this.currentRepoType].ePlusNoReposMessage;
	                    }
	                    _.forEach(data, function (row) {
	                        var rowPackageType = _.find(FIELD_OPTIONS.repoPackageTypes, function (type) {
	                            return type.value == row.repoType.toLowerCase();
	                        });
	                        if (rowPackageType) {
	                            row.displayType = rowPackageType.text;
	                            row.typeIcon = rowPackageType.icon;
	                        } else if (row.repoType !== REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES && row.repoType.toLowerCase() !== FIELD_OPTIONS.REPO_TYPE.DISTRIBUTION) {
	                            row.ignore = true;
	                        }
	                    });
	                    data = _.filter(data, function (row) {
	                        return !row.ignore;
	                    });
	                    _this.gridData = data;
	                    _this.gridOption.setGridData(data);
	                });
	            }
	        },
	        reorderRepositories: {
	            value: function reorderRepositories() {
	                return this.repositoriesDao.reorderRepositories({ repoType: this.currentRepoType }, this.getRepoOrder()).$promise;
	            }
	        },
	        getRepoOrder: {
	            value: function getRepoOrder() {
	                var repoOrderList = [];
	                this.gridData.forEach(function (data) {
	                    repoOrderList.push(data.repoKey);
	                });
	                return repoOrderList;
	            }
	        },
	        _deleteSelected: {
	            value: function _deleteSelected(row) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you wish to delete this repository? All artifacts will be permanently deleted.", "Delete " + row.repoKey + " Repository", { confirm: "Delete" }).then(function () {
	                    _this.repositoriesDao.deleteRepository({
	                        type: _this.currentRepoType,
	                        repoKey: row.repoKey
	                    }).$promise.then(function (result) {
	                        _this._initRepos();
	                    });
	                });
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this._deleteSelectedRepos();
	                    }
	                }];
	            }
	        },
	        _deleteSelectedRepos: {
	            value: function _deleteSelectedRepos() {
	                var selectedRows = this.gridOption.api.selection.getSelectedGridRows();
	            }
	        },
	        _editSelected: {
	            value: function _editSelected(row) {
	                this.$state.go("^.list.edit", { repoType: this.currentRepoType, repoKey: row.repoKey });
	            }
	        },
	        createNewRepo: {
	            value: function createNewRepo(distRepoType) {
	                this.$state.go("^.list.new", { repoType: this.currentRepoType, distRepoType: distRepoType });
	            }
	        },
	        _calculateIndex: {
	            value: function _calculateIndex(row) {
	                this.artifactActionsDao.perform({
	                    action: "calculateIndex",
	                    type: row.repoType,
	                    repoKey: row.repoKey
	                });
	            }
	        },
	        localReplicationsRunNow: {
	            value: function localReplicationsRunNow(repoKey) {
	                this.repositoriesDao.runNowReplications({ repoKey: repoKey }).$promise.then(function () {});
	            }
	        },
	        remoteExecuteReplicationNow: {
	            value: function remoteExecuteReplicationNow(repoKey) {
	                this.repositoriesDao.executeRemoteReplicationNow({ repoKey: repoKey }, this.repoInfo).$promise.then(function (result) {});
	            }
	        },
	        _getGlobalReplicationsStatus: {
	            value: function _getGlobalReplicationsStatus() {
	                var _this = this;
	
	                this.globalReplicationsConfigDao.status().$promise.then(function (status) {
	                    _this.globalReplicationsStatus = {
	                        blockPullReplications: status.blockPullReplications,
	                        blockPushReplications: status.blockPushReplications
	                    };
	                });
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                if (this.currentRepoType === "local") {
	                    return this._getLocalColumns();
	                } else if (this.currentRepoType === "remote") {
	                    return this._getRemoteColumns();
	                } else if (this.currentRepoType === "virtual") {
	                    return this._getVirtualColumns();
	                } else if (this.currentRepoType === "distribution") {
	                    return this._getDistColumns();
	                }
	            }
	        },
	        _getLocalColumns: {
	            value: function _getLocalColumns() {
	                var _this = this;
	
	                return [{
	                    name: "Repository Key",
	                    displayName: "Repository Key",
	                    field: "repoKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" ui-sref=\"^.list.edit({repoType:'local',repoKey: row.entity.repoKey})\" id=\"repositories-local-key\">{{COL_FIELD}}</a></div>",
	                    width: "55%",
	                    enableSorting: true
	                    //sort: {
	                    //    direction: this.uiGridConstants.ASC
	                    //}
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "displayType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.displayType", "row.entity.typeIcon", "repo-type-icon"),
	                    width: "15%",
	                    enableSorting: true
	                }, {
	                    name: "Recalculate Index",
	                    displayName: "Recalculate Index",
	                    field: "reindex",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-re-index\" ng-click=\"!row.entity.hasReindexAction || grid.appScope.Repositories._calculateIndex(row.entity)\" ng-disabled=\"!row.entity.hasReindexAction\" jf-tooltip=\"{{row.entity.hasReindexAction ? 'Recalculate Index Now' : 'Recalculate Not Supported For Repo Type'}}\" id=\"repositories-local-reindex\"></a></div>",
	                    width: "15%",
	                    enableSorting: true
	                }, {
	                    name: "Replications",
	                    displayName: "Replications",
	                    field: "replications",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\" ng-class=\"{'replication-disabled': grid.appScope.Repositories.globalReplicationsStatus.blockPushReplications}\"><a class=\"grid-column-button icon icon-run\" ng-click=\"(!row.entity.replications || grid.appScope.Repositories.globalReplicationsStatus.blockPushReplications) || grid.appScope.Repositories.localReplicationsRunNow(row.entity.repoKey)\" ng-disabled=\"!row.entity.replications\" jf-tooltip=\"{{grid.appScope.Repositories.globalReplicationsStatus.blockPushReplications ? 'Push Replication Is Blocked' : (row.entity.replications ? 'Run Replication' : 'No Replication Configured')}}\" id=\"repositories-local-replicate\"></a></div>",
	                    width: "15%",
	                    actions: {
	                        "delete": function (row) {
	                            return _this._deleteSelected(row);
	                        }
	                    },
	                    enableSorting: false
	                }];
	            }
	        },
	        _getRemoteColumns: {
	            value: function _getRemoteColumns() {
	                var _this = this;
	
	                return [{
	                    name: "Repository Key",
	                    displayName: "Repository Key",
	                    field: "repoKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" ui-sref=\"^.list.edit({repoType:'remote',repoKey: row.entity.repoKey})\" id=\"repositories-remote-key\">{{COL_FIELD}}</a></div>",
	                    width: "20%",
	                    enableSorting: true
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "displayType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.displayType", "row.entity.typeIcon", "repo-type-icon"),
	                    width: "10%",
	                    enableSorting: true
	                }, {
	                    name: "URL",
	                    displayName: "URL",
	                    field: "url",
	                    width: "40%",
	                    enableSorting: true
	                }, {
	                    name: "Recalculate Index",
	                    displayName: "Recalculate Index",
	                    field: "reindex",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-re-index\" ng-click=\"!row.entity.hasReindexAction || grid.appScope.Repositories._calculateIndex(row.entity)\" ng-disabled=\"!row.entity.hasReindexAction\" jf-tooltip=\"{{row.entity.hasReindexAction ? 'Recalculate Index Now' : 'Recalculate Not Supported For Repo Type'}}\" id=\"repositories-local-reindex\"></a></div>",
	                    width: "15%",
	                    enableSorting: false
	                }, {
	                    name: "Replications",
	                    displayName: "Replications",
	                    field: "hasEnabledReplication",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\" ng-class=\"{'replication-disabled': grid.appScope.Repositories.globalReplicationsStatus.blockPullReplications}\"><a class=\"grid-column-button icon icon-run\" ng-click=\"(!row.entity.hasEnabledReplication || grid.appScope.Repositories.globalReplicationsStatus.blockPullReplications) || grid.appScope.Repositories.remoteExecuteReplicationNow(row.entity.repoKey)\" ng-disabled=\"!row.entity.hasEnabledReplication\" jf-tooltip=\"{{grid.appScope.Repositories.globalReplicationsStatus.blockPullReplications ? 'Pull Replication Is Blocked' : (row.entity.hasEnabledReplication ? 'Run Replication' : 'No Replication Configured')}}\" id=\"repositories-local-replicate\"></a></div>",
	                    width: "15%",
	                    actions: {
	                        "delete": function (row) {
	                            return _this._deleteSelected(row);
	                        }
	                    },
	                    enableSorting: false
	                }];
	            }
	        },
	        _getVirtualColumns: {
	            value: function _getVirtualColumns() {
	                var _this = this;
	
	                return [{
	                    name: "Repository Key",
	                    displayName: "Repository Key",
	                    field: "repoKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" ui-sref=\"^.list.edit({repoType:'virtual',repoKey: row.entity.repoKey})\" id=\"repositories-virtual-key\">{{COL_FIELD}}</a></div>",
	                    width: "20%",
	                    enableSorting: true
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "displayType",
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.displayType", "row.entity.typeIcon", "repo-type-icon"),
	                    width: "10%",
	                    enableSorting: true
	                }, {
	                    name: "Included Repositories",
	                    displayName: "Included Repositories",
	                    field: "numberOfIncludesRepositories",
	                    width: "15%",
	                    enableSorting: false
	                }, {
	                    name: "Selected Repositories",
	                    displayName: "Selected Repositories",
	                    field: "selectedRepos",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.selectedRepos", "row.entity.repoKey", null, null, "repositories-virtual-selected"),
	                    width: "40%",
	                    enableSorting: false
	                }, {
	                    name: "Recalculate Index",
	                    displayName: "Recalculate Index",
	                    field: "reindex",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-re-index\" ng-click=\"!row.entity.hasReindexAction || grid.appScope.Repositories._calculateIndex(row.entity)\" ng-disabled=\"!row.entity.hasReindexAction\" jf-tooltip=\"{{row.entity.hasReindexAction ? 'Recalculate Index Now' : 'Recalculate Not Supported For Repo Type'}}\" id=\"repositories-virtual-reindex\"></a></div>",
	                    width: "15%",
	                    actions: {
	                        "delete": function (row) {
	                            return _this._deleteSelected(row);
	                        }
	                    },
	                    enableSorting: false
	                }];
	            }
	        },
	        _getDistColumns: {
	            value: function _getDistColumns() {
	                var _this = this;
	
	                return [{
	                    name: "Repository Key",
	                    displayName: "Repository Key",
	                    field: "repoKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                    <a ui-sref=\"^.list.edit({repoType:'distribution',repoKey: row.entity.repoKey, distRepoType:row.entity.repoType})\"\n                                        class=\"jf-link\"\n                                        id=\"repositories-distribution-key\">\n                                        {{COL_FIELD}}\n                                    </a>\n                               </div>",
	                    width: "60%",
	                    enableSorting: true
	                }, {
	                    name: "Repository Type",
	                    displayName: "Repository Type",
	                    field: "repoType",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"repository-type\">{{row.entity.repoType}}</div>",
	                    width: "20%",
	                    enableSorting: true
	                }, {
	                    name: "Repository Visibility",
	                    displayName: "Repository Visibility",
	                    field: "visibility",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"repository-visibility\">{{row.entity.visibility}}</div>",
	                    width: "20%",
	                    enableSorting: true,
	                    actions: {
	                        "delete": function (row) {
	                            return _this._deleteSelected(row);
	                        }
	                    }
	                } /*,
	                  {
	                     name: 'Status',
	                     displayName: 'Status',
	                     field: 'status',
	                     cellTemplate: this.commonGridColumns.ajaxColumn(),
	                     width: '15%',
	                     actions: {
	                         delete: row => this._deleteSelected(row);
	                     }
	                  }*/
	                ];
	            }
	        },
	        setQuickActions: {
	
	            // New Distribution Repo Actions Dropdown setup
	
	            value: function setQuickActions() {
	                if (!this.quickActions) {
	                    return;
	                }
	                this.quickActions.setActionsDictionary(this.getActionsDictionary());
	                this.quickActions.setActions(this.getActions());
	            }
	        },
	        initActionsDropdown: {
	            value: function initActionsDropdown(actionsController) {
	                this.quickActions = actionsController;
	                this.setQuickActions();
	            }
	        },
	        getActionsDictionary: {
	            value: function getActionsDictionary() {
	                var dictionary = {};
	                dictionary.newReleaseBundlesRepo = { title: "Release Bundles Repository" };
	                dictionary.newBintrayDistributionRepo = { title: "Bintray Distribution Repository" };
	                return dictionary;
	            }
	        },
	        getActions: {
	            value: function getActions() {
	                var _this = this;
	
	                var actions = [{
	                    name: "newReleaseBundlesRepo",
	                    icon: "icon-distribution-repo bordered",
	                    action: function () {
	                        _this.createNewRepo(REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES);
	                    }
	                }, {
	                    name: "newBintrayDistributionRepo",
	                    icon: "icon-distribution-repo bordered",
	                    action: function () {
	                        _this.createNewRepo(REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.BINTRAY);
	                    }
	                }];
	                return actions;
	            }
	        }
	    });
	
	    return AdminRepositoriesController;
	})();

/***/ }),
/* 212 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	var REPO_FORM_CONSTANTS = {
	  DISTRIBUTION_REPO_TYPES: {
	    RELEASE_BUNDLES: "ReleaseBundles",
	    BINTRAY: "Distribution"
	  },
	  CONFIG: {
	    RELEASE_BUNDLES: "releaseBundlesRepoConfig",
	    BINTRAY: "distributionRepoConfig" }
	};
	exports.REPO_FORM_CONSTANTS = REPO_FORM_CONSTANTS;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var fieldsValuesDictionary = _interopRequire(__webpack_require__(135));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var REPO_FORM_CONSTANTS = __webpack_require__(212).REPO_FORM_CONSTANTS;
	
	var AdminRepositoryFormController = exports.AdminRepositoryFormController = (function () {
	    function AdminRepositoryFormController($q, $scope, $stateParams, $state, $timeout, $location, RepositoriesDao, PropertySetsDao, JFrogGridFactory, ReverseProxiesDao, JFrogModal, FooterDao, ArtifactoryFeatures, JFrogNotifications, commonGridColumns, ArtifactoryModelSaver, GeneralConfigDao, DockerStatusDao, GlobalReplicationsConfigDao, XrayDao, GoogleAnalytics, JFrogTableViewOptions) {
	        _classCallCheck(this, AdminRepositoryFormController);
	
	        this.$scope = $scope;
	        this.$q = $q;
	        this.currentTab = "basic";
	        this.$timeout = $timeout;
	        this.$stateParams = $stateParams;
	        this.$location = $location;
	        this.propertySetsDao = PropertySetsDao;
	        this.globalReplicationsConfigDao = GlobalReplicationsConfigDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogTableViewOptions = JFrogTableViewOptions;
	        this.commonGridColumns = commonGridColumns;
	        this.notifications = JFrogNotifications;
	        this.modal = JFrogModal;
	        this.generalConfigDao = GeneralConfigDao;
	        this.NO_VALUE_STRING = "** NO VALUE **";
	        this.$state = $state;
	        this.footerDao = FooterDao;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.repositoriesDao = RepositoriesDao;
	        this.reverseProxiesDao = ReverseProxiesDao;
	        this.xrayDao = XrayDao;
	        this.newRepository = false;
	        this.features = ArtifactoryFeatures;
	        this.replicationsGridOption = {};
	        this.replicationScope = $scope.$new();
	        this.TOOLTIP = TOOLTIP.admin.repositories;
	        this.optionalFormats = [{ id: "bz2", text: "Bzip2 (.bz2 extension)", selectedText: "bz2", isSelected: true }, { id: "lzma", text: "LZMA (.lzma extension)", selectedText: "lzma" }, { id: "xz", text: "XZ (.xz extension)", selectedText: "xz" }];
	        this.isReleaseBundleRepo = this.$stateParams.distRepoType && this.$stateParams.distRepoType === REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.admin.repositories;
	        this.DockerStatusDao = DockerStatusDao.getInstance();
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["repoInfo"], ["replications.*.proxies"]);
	        this.bintrayAuthentication = true;
	        this.wizardConfig = {
	            enableNgShow: true
	        };
	        this.reverseProxies = ["**"];
	
	        this.reverseProxiesSelectizeConfig = {
	            sortField: "text",
	            create: false,
	            maxItems: 1
	        };
	        this._setupDistribution();
	        this.licensesListConfig = {
	            sortField: "text",
	            maxItems: null,
	            plugins: ["remove_button"]
	        };
	
	        this._createGrid();
	        this.initRepoForm();
	        this.repoType = this.$stateParams.repoType;
	        if (this.$stateParams.repoKey) {
	            this.title = "Edit " + this.$stateParams.repoKey + " Repository";
	            this.newRepository = false;
	            this.editRepository(this.$stateParams.repoKey);
	        } else {
	            this.newRepository = true;
	            this.repoInfo = new RepositoriesDao();
	            this.title = this.getPageTitle();
	            this._initNewRepositoryTypeConfig();
	
	            if (this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                if (!this.repoInfo.basic) {
	                    this.repoInfo.basic = {};
	                    this.repoInfo.basic.contentSynchronisation = {};
	                    this.repoInfo.basic.contentSynchronisation.statistics = {};
	                    this.repoInfo.basic.contentSynchronisation.properties = {};
	                }
	
	                this.repoInfo.basic.contentSynchronisation.enabled = false;
	                this.repoInfo.basic.contentSynchronisation.statistics.enabled = false;
	                this.repoInfo.basic.contentSynchronisation.properties.enabled = false;
	            }
	        }
	        this.packageType = fieldsValuesDictionary.repoPackageTypes;
	
	        this._getGeneralConfig();
	        this._getGlobalReplicationsStatus();
	        this.originalValueFlag = true;
	        this.footerDao.get(true);
	
	        this.repositoryFilterTooltip = this.TOOLTIP.rulesPopup.repositoryFilterTooltip;
	        this.pathFilterToolip = this.TOOLTIP.rulesPopup.pathFilterToolip;
	        this.noReplicationsMessage = this.CONFIG_MESSAGES.local.noReplicationsMessage;
	    }
	
	    _createClass(AdminRepositoryFormController, {
	        getPageTitle: {
	            value: function getPageTitle() {
	                var distRepoType = this.$stateParams.distRepoType && this.$stateParams.distRepoType === REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES ? "Release Bundles" : "Bintray Distribution";
	                var repoType = this.repoType === "distribution" ? distRepoType : _.capitalize(this.repoType);
	                return "New " + repoType + " Repository";
	            }
	        },
	        isCurrentRepoType: {
	            value: function isCurrentRepoType(type) {
	                return this.repoType == type;
	            }
	        },
	        onFormatSelectionChange: {
	            value: function onFormatSelectionChange() {
	                var formats = _.filter(this.optionalFormats, function (format) {
	                    return format.isSelected;
	                });
	                this.repoInfo.typeSpecific.optionalIndexCompressionFormats = _.map(formats, "id");
	            }
	        },
	        _updateOptionalIndexCompressionFormats: {
	            value: function _updateOptionalIndexCompressionFormats(optionalIndexCompressionFormats) {
	                var result = _.map(this.optionalFormats, function (format) {
	                    return _.extend({}, format, {
	                        isSelected: optionalIndexCompressionFormats.indexOf(format.id) !== -1
	                    });
	                });
	                return result;
	            }
	        },
	        initRepoForm: {
	
	            /**
	             * init propertiesSets  and replication scope functions for modal and fields options
	             */
	
	            value: function initRepoForm() {
	                var _this = this;
	
	                this.replicationScope.replication = {}; //to create a single replication
	                this.replicationScope.testLocalReplicationUrl = function (url) {
	                    return _this.testLocalReplicationUrl(url);
	                };
	
	                this.replicationScope.addReplication = function (replication) {
	                    return _this.addReplication(replication);
	                };
	                this.replicationScope.closeModal = function () {
	                    return _this.closeModal();
	                };
	                this.replicationScope.RepositoryForm = this;
	            }
	        },
	        editRepository: {
	
	            /**
	             * run only if edit repository and get repository data
	             */
	
	            value: function editRepository(repoKey) {
	                var _this = this;
	
	                var payload = { type: this.isReleaseBundleRepo ? _.camelCase(this.$stateParams.distRepoType) : this.repoType, repoKey: repoKey };
	                this.repositoriesDao.getRepository(payload).$promise.then(function (info) {
	                    _this.repoInfo = info;
	                    _this.repoInfo.basic.includesPatternArray = _this.repoInfo.basic.includesPattern ? _this.repoInfo.basic.includesPattern.split(",") : [];
	                    _this.repoInfo.basic.excludesPatternArray = _this.repoInfo.basic.excludesPattern ? _this.repoInfo.basic.excludesPattern.split(",") : [];
	                    if (_this.repoInfo.typeSpecific.repoType === "YUM") {
	                        _this.repoInfo.groupFileNamesArray = _this.repoInfo.typeSpecific.groupFileNames ? _this.repoInfo.typeSpecific.groupFileNames.split(",") : [];
	                    }
	                    var repoPackageType = _.filter(fieldsValuesDictionary.repoPackageTypes, { serverEnumName: _this.repoInfo.typeSpecific.repoType });
	
	                    if (repoPackageType.length) {
	                        _this.repoInfo.typeSpecific.text = repoPackageType[0].text;
	                        _this.repoInfo.typeSpecific.icon = repoPackageType[0].icon;
	                    }
	
	                    if (_this.repoInfo.typeSpecific.repoType === "Docker" && !_this.features.isAol() && !_this.features.isNonCommercial()) {
	                        _this._getReveresProxyConfigurations();
	                    }
	
	                    if (_this.repoInfo.typeSpecific.repoType === "Debian" && _this.repoInfo.typeSpecific.optionalIndexCompressionFormats !== undefined) {
	                        _this.optionalFormats = _this._updateOptionalIndexCompressionFormats(_this.repoInfo.typeSpecific.optionalIndexCompressionFormats);
	                    }
	
	                    if (_this.repoInfo.replications && _this.repoInfo.replications.length) {
	                        _this.repoInfo.cronExp = _this.repoInfo.replications[0].cronExp;
	                        _this.repoInfo.enableEventReplication = _this.repoInfo.replications[0].enableEventReplication;
	                    }
	                    if (_this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                        _this._getRepositoriesByType();
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE && _this.repoInfo.replications) {
	                        _this.repoInfo.replication = _this.repoInfo.replications[0];
	                    } else {
	                        _this.replicationsGridOption.setData(_this.repoInfo.replications);
	                    }
	                    _this._getFieldsOptions();
	
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                        if (_this.repoInfo.advanced.network.installedCertificatesList) {
	                            _this.repoInfo.advanced.network.installedCertificatesList.unshift("");
	                        }
	                        _this._detectSmartRepository(false).then(function () {
	                            _this.lastSmartRemoteURL = _this.repoInfo.basic.url;
	                        });
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE || _this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                        if (_this.repoInfo.typeSpecific.maxUniqueSnapshots === 0) {
	                            _this.repoInfo.typeSpecific.maxUniqueSnapshots = "";
	                        }
	                        if (_this.repoInfo.typeSpecific.maxUniqueTags === 0) {
	                            _this.repoInfo.typeSpecific.maxUniqueTags = "";
	                        }
	                        if (_this.repoInfo.advanced.cache && _this.repoInfo.advanced.cache.keepUnusedArtifactsHours === 0) {
	                            _this.repoInfo.advanced.cache.keepUnusedArtifactsHours = "";
	                        }
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                        if (!_this.repoInfo.typeSpecific.authenticated && _this.$location.search().code) {
	                            _this.openBintrayOAuthModal();
	                        }
	
	                        _this.bintrayAuthentication = _this.repoInfo.typeSpecific.premium ? true : false;
	                        _this.defaultNewRepoPrivateSwitch = _this.repoInfo.basic.defaultNewRepoPrivate == true ? "Private" : "Public";
	                        _this.distributionType = _this.repoInfo.basic.productName != null;
	                        _this.distributionRules = _this.repoInfo.advanced.distributionRules;
	                        if (_this.features.isOss()) {
	                            _this.distributionRules = _.filter(_this.distributionRules, function (rule) {
	                                return _.includes(["Maven", "Gradle", "Ivy", "SBT"], rule.type);
	                            });
	                        } else if (_this.features.isConanCE()) {
	                            _this.distributionRules = _.filter(_this.distributionRules, function (rule) {
	                                return _.includes(["Conan"], rule.type);
	                            });
	                        } else if (_this.features.isJCR()) {
	                            _this.distributionRules = _.filter(_this.distributionRules, function (rule) {
	                                return _.includes(["Docker", "Helm"], rule.type);
	                            });
	                        }
	                        _this._createDistributionRulesGrid(); // Edit
	                        _this._setupLicenses();
	                        _this._setRulesPackages();
	                    }
	                    _this.repoInfo.basic.selectedLocalRepositories = _.map(_.filter(_this.repoInfo.basic.resolvedRepositories, function (repo) {
	                        return repo.type === "local";
	                    }), "repoName");
	                    _this.repoInfo.basic.selectedRemoteRepositories = _.map(_.filter(_this.repoInfo.basic.resolvedRepositories, function (repo) {
	                        return repo.type === "remote";
	                    }), "repoName");
	                    _this.repoInfo.basic.selectedLocalRepositories.unshift("");
	
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _setDefaultProxy: {
	            value: function _setDefaultProxy() {
	                if (this.newRepository && this.fields.defaultProxy && _.has(this.repoInfo, "advanced.network")) {
	                    !this.repoInfo.advanced.network.proxy ? this.repoInfo.advanced.network.proxy = this.fields.defaultProxy : "";
	                }
	            }
	        },
	        testLocalReplicationUrl: {
	
	            /**
	             *test button  when adding new replication in local repository
	             */
	
	            value: function testLocalReplicationUrl(url) {
	                // Create a copy of the repo
	                var testRepo = angular.copy(this.repoInfo);
	
	                // Make sure replications is not null
	                testRepo.replications = testRepo.replications || [];
	
	                var testReplication = undefined;
	                if (this.replicationScope.sourceReplication) {
	                    testReplication = _.find(testRepo.replications, { url: this.replicationScope.sourceReplication.url });
	                    angular.copy(this.replicationScope.replication, testReplication);
	                } else {
	                    testReplication = angular.copy(this.replicationScope.replication);
	                    testRepo.replications.push(testReplication);
	                }
	
	                testReplication.cronExp = this.repoInfo.cronExp;
	                testReplication.nextTime = this.repoInfo.nextTime;
	                testReplication.type = this.repoType;
	                testReplication.enableEventReplication = this.repoInfo.enableEventReplication;
	
	                this.repositoriesDao.testLocalReplication({ replicationUrl: url }, testRepo);
	            }
	        },
	        testRemoteUrl: {
	            value: function testRemoteUrl() {
	                var _this = this;
	
	                this.repositoriesDao.testRemoteUrl(this.repoInfo).$promise.then(function (result) {
	                    //console.log(result);
	                    if (result && result.data && result.data.artifactory) {
	                        if (_this.isVcsRepository()) {
	                            _this.repoInfo.typeSpecific.gitProvider = "ARTIFACTORY";
	                        }
	                    }
	                });
	
	                this._detectSmartRepository();
	            }
	        },
	        _detectSmartRepository: {
	            value: function _detectSmartRepository() {
	                var _this = this;
	
	                var showModal = arguments[0] === undefined ? true : arguments[0];
	
	                if (this.repoInfo.basic.url.startsWith("https://gocenter.io")) {
	                    if (this.isVcsRepository()) {
	                        this.repoInfo.typeSpecific.gitProvider = "ARTIFACTORY";
	                    }
	                }
	                if (this.features.isOss() || this.features.isConanCE()) {
	                    return this.$q.when();
	                }
	
	                var defer = this.$q.defer();
	                this.smartRepoUnknownCapabilities = false;
	
	                var repoInfoCopy = angular.copy(this.repoInfo);
	                if (!repoInfoCopy.typeSpecific.repoType) {
	                    repoInfoCopy.typeSpecific.repoType = "Generic";
	                }
	
	                this.repositoriesDao.detectSmartRepository(repoInfoCopy).$promise.then(function (result) {
	                    if (result.artifactory && result.version && result.features.length) {
	                        if (!_this.repoInfo.basic.contentSynchronisation.enabled || _this.repoInfo.basic.url != _this.lastSmartRemoteURL) {
	                            _this.repoInfo.basic.contentSynchronisation.enabled = true;
	                            _this.lastSmartRemoteURL = _this.repoInfo.basic.url;
	                            _this.smartRepoFeatures = result.features;
	
	                            if (localStorage.disableSmartRepoPopup !== "true" && showModal) {
	                                (function () {
	                                    var modalInstance = undefined;
	                                    var modalScope = _this.$scope.$new();
	
	                                    modalScope.smartRepo = _this.repoInfo.basic.contentSynchronisation;
	                                    modalScope.smartRepo.typeSpecific = _this.repoInfo.typeSpecific;
	                                    modalScope.closeModal = function () {
	                                        return modalInstance.close();
	                                    };
	                                    modalScope.options = { dontShowAgain: false };
	                                    modalScope.isSmartRepoSupportFeature = function (featureName) {
	                                        return _this.isSmartRepoSupportFeature(featureName);
	                                    };
	                                    modalScope.onDontShowAgain = function () {
	                                        localStorage.disableSmartRepoPopup = modalScope.options.dontShowAgain;
	                                    };
	                                    modalInstance = _this.modal.launchModal("smart_remote_repository", modalScope);
	                                })();
	                            }
	
	                            defer.resolve(true);
	                        } else defer.resolve(false);
	                    } else {
	                        if (result.artifactory && result.version === null) {
	                            _this.smartRepoUnknownCapabilities = true;
	                        }
	                        _this.repoInfo.basic.contentSynchronisation.enabled = false;
	                        defer.resolve(false);
	                    }
	                });
	
	                return defer.promise;
	            }
	        },
	        isSmartRepoSupportFeature: {
	            value: function isSmartRepoSupportFeature(featureName) {
	                return _.find(this.smartRepoFeatures, { name: featureName }) !== undefined;
	            }
	        },
	        isRemoteDownloadSettingsValid: {
	            value: function isRemoteDownloadSettingsValid() {
	                if (this.repoInfo && this.repoInfo.advanced) {
	                    return !(this.repoType === "remote" && !this.repoInfo.advanced.storeArtifactsLocally && this.repoInfo.advanced.downloadRedirectConfig && this.repoInfo.advanced.downloadRedirectConfig.enabled);
	                }
	            }
	        },
	        onBlurCredentials: {
	            value: function onBlurCredentials() {
	                if (this.smartRepoUnknownCapabilities && this.repoInfo.advanced.network.username && this.repoInfo.advanced.network.password) {
	                    this._detectSmartRepository();
	                }
	            }
	        },
	        testRemoteReplication: {
	            value: function testRemoteReplication() {
	                this.addReplication(this.repoInfo.replication);
	                this.repositoriesDao.testRemoteReplication(this.repoInfo).$promise.then(function (result) {});
	            }
	        },
	        setSnapshotVersionBehavior: {
	            value: function setSnapshotVersionBehavior() {
	                if (this.repoInfo && this.repoInfo.typeSpecific && this.repoInfo.typeSpecific.snapshotVersionBehavior) {
	                    if (this.repoInfo.typeSpecific.snapshotVersionBehavior == "NONUNIQUE") {
	                        //this.repoInfo.typeSpecific.maxUniqueSnapshots = 0;
	                        this.disableMaxUniqueSnapshots = true;
	                    } else {
	                        this.disableMaxUniqueSnapshots = false;
	                    }
	                }
	            }
	        },
	        _initNewRepositoryTypeConfig: {
	            value: function _initNewRepositoryTypeConfig() {
	                var _this = this;
	
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                    this.repoInfo.type = "localRepoConfig";
	                }
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    this.repoInfo.type = "remoteRepoConfig";
	                }
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                    this.repoInfo.type = "virtualRepoConfig";
	                }
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    this.repoInfo.type = this.isReleaseBundleRepo ? REPO_FORM_CONSTANTS.CONFIG.RELEASE_BUNDLES : REPO_FORM_CONSTANTS.CONFIG.BINTRAY;
	                }
	
	                this._getDefaultModels().then(function () {
	                    _this._getFieldsOptions().then(function () {
	                        _this._setDefaultFields();
	                        if (!_this.isReleaseBundleRepo) {
	                            if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                                _this.openBintrayOAuthModal();
	                            } else {
	                                _this.openRepoTypeModal();
	                            }
	                        } else {
	                            _this.repoInfo.type = REPO_FORM_CONSTANTS.CONFIG.RELEASE_BUNDLES;
	                        }
	                        _this.ArtifactoryModelSaver.save();
	                    });
	
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                        _this.repoInfo.type = "localRepoConfig";
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                        _this.repoInfo.type = "remoteRepoConfig";
	                    }
	                    if (_this.repoType == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                        _this.repoInfo.type = "virtualRepoConfig";
	                    }
	                });
	            }
	        },
	        _populateProperties: {
	
	            /**
	             * get all properties
	             */
	
	            value: function _populateProperties() {
	                var _this = this;
	
	                return this.propertySetsDao.query({ isRepoForm: true }).$promise.then(function (properites) {
	                    _this.propertiesList = properites;
	                });
	            }
	        },
	        _getFieldsOptions: {
	
	            /**
	             * set dropdown options and default fields
	             */
	
	            value: function _getFieldsOptions() {
	                var _this = this;
	
	                return this.repositoriesDao.getAvailableChoicesOptions().$promise.then(function (fields) {
	                    _this.fields = fields;
	                    _this.localChecksumPolicies = fieldsValuesDictionary.localChecksumPolicy;
	                    _this.localChecksumPoliciesKeys = Object.keys(_this.localChecksumPolicies);
	                    _this.remoteChecksumPolicies = fieldsValuesDictionary.remoteChecksumPolicy;
	                    _this.remoteChecksumPoliciesKeys = Object.keys(fieldsValuesDictionary.remoteChecksumPolicy);
	                    fields.proxies = fields.proxies || [];
	                    fields.proxies.unshift("");
	                    fields.webStartKeyPairs = fields.webStartKeyPairs || [];
	                    fields.webStartKeyPairs.unshift("");
	                    _this.repositoryLayouts = _.sortBy(fields.repositoryLayouts, function (layout) {
	                        return layout;
	                    });
	
	                    if (_this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                        _this.repositoryLayouts.unshift("");
	                    }
	
	                    if (_this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                        if (_this.newRepository) {
	                            _this.repoInfo.type = "distributionRepoConfig";
	                            _this._createDistributionRulesGrid(); // NEW
	                        }
	                    }
	
	                    _this.remoteLayoutMapping = angular.copy(fields.repositoryLayouts);
	                    _this.remoteLayoutMapping.unshift("");
	                    _this.mavenSnapshotRepositoryBehaviors = fieldsValuesDictionary.snapshotRepositoryBehavior;
	                    _this.mavenSnapshotRepositoryBehaviorsKeys = Object.keys(fieldsValuesDictionary.snapshotRepositoryBehavior);
	                    _this.pomCleanupPolicies = fieldsValuesDictionary.pomCleanupPolicy;
	                    _this.pomCleanupPoliciesKeys = Object.keys(fieldsValuesDictionary.pomCleanupPolicy);
	                    _this.vcsGitProviderOptions = fieldsValuesDictionary.vcsGitProvider;
	                    _this.vcsGitProviderOptionsKeys = Object.keys(fieldsValuesDictionary.vcsGitProvider);
	                    _this.setSnapshotVersionBehavior();
	                    return _this._populateProperties();
	                });
	            }
	        },
	        _getDefaultModels: {
	
	            /**
	             * fetching from server the default data
	             */
	
	            value: function _getDefaultModels() {
	                var _this = this;
	
	                return this.repositoriesDao.getDefaultValues().$promise.then(function (models) {
	                    _this.defaultModels = models.defaultModels;
	                });
	            }
	        },
	        setCurrentTab: {
	
	            /**
	             * check and set current tab
	             */
	
	            value: function setCurrentTab(tab) {
	                if (this.features.isDisabled(tab)) {
	                    return;
	                }
	                this.currentTab = tab;
	            }
	        },
	        isCurrentTab: {
	            value: function isCurrentTab(tab) {
	                return this.currentTab === tab;
	            }
	        },
	        isRemoteDockerWithoutCredentials: {
	            value: function isRemoteDockerWithoutCredentials() {
	                return this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE && this.repoInfo.isType("docker") && this.repoInfo.basic.url.indexOf("docker.io") >= 0 && (!this.repoInfo.advanced.network.username || !this.repoInfo.advanced.network.password);
	            }
	        },
	        submitGuard: {
	            value: function submitGuard() {
	                var _this = this;
	
	                if (this.isRemoteDockerWithoutCredentials()) {
	                    this.modal.confirm("Authentication is not set on this Remote Docker repository. Do you want to proceed?").then(function () {
	                        return _this.save();
	                    })["catch"](function () {
	                        return false;
	                    });
	                } else {
	                    this.save();
	                }
	            }
	        },
	        save: {
	
	            /**
	             * handle save or update click
	             */
	
	            value: function save() {
	                var _this = this;
	
	                var pending = this.repositoriesForm.repoKey.$pending;
	                if (pending && pending.repoKeyValidator) {
	                    this.$timeout(function () {
	                        _this.save();
	                    }, 100);
	                    return;
	                }
	
	                if (this.savePending) {
	                    return;
	                }if (!this.repositoriesForm.$valid) {
	                    return;
	                }this.savePending = true;
	
	                this.repoInfo.basic.includesPattern = this.repoInfo.basic.includesPatternArray.join(",") || undefined;
	                //'*,dfdf,sdsd,cxc'
	                this.repoInfo.basic.excludesPattern = this.repoInfo.basic.excludesPatternArray.join(",") || undefined;
	                if (this.repoInfo.typeSpecific.repoType === "YUM") {
	                    this.repoInfo.typeSpecific.groupFileNames = this.repoInfo.groupFileNamesArray ? this.repoInfo.groupFileNamesArray.join(",") : undefined;
	                }
	
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                    if (this.repoInfo.replications && this.repoInfo.replications.length) {
	                        this.saveCronAndEventFlagToAllReplicationsAndValidateHa();
	                    }
	                    //Warn user if saving cron expression without any replication config
	                    if (this.repoInfo.cronExp && (!this.repoInfo.replications || !this.repoInfo.replications.length)) {
	                        this.notifications.create({ warn: "A cron expression was entered without any replication configuration." + "\nThe expression will not be saved."
	                        });
	                    }
	                }
	
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    this._detectSmartRepository().then(function (result) {
	                        if (!result) {}
	                    });
	
	                    //Add replication if exists:
	                    if (this.repoInfo.replication) {
	                        if (this.repoInfo.cronExp && this.repoInfo.replication.enabled && (!this.repoInfo.advanced.network.username || !this.repoInfo.advanced.network.password)) {
	                            this.notifications.create({
	                                error: "Pull replication requires non-anonymous authentication to the " + "remote repository. Please make sure to fill the 'Username' and 'Password' fields in the " + "Advanced settings tab or remove the fields you filled in the replication tab."
	                            });
	                            this.savePending = false;
	                            return false;
	                        }
	                        this.addReplication(this.repoInfo.replication);
	                    }
	
	                    if (this.repoInfo.advanced.network.proxy === "") {
	                        delete this.repoInfo.advanced.network.proxy;
	                    }
	
	                    if (this.repoInfo.advanced.network.selectedInstalledCertificate == "") {
	                        delete this.repoInfo.advanced.network.selectedInstalledCertificate;
	                    }
	                }
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION && !this.isReleaseBundleRepo) {
	                    this.repoInfo.advanced.distributionRules = this.distributionRules;
	                }
	                this.$timeout(function () {
	                    _this.save_update();
	                }, 500);
	            }
	        },
	        save_update: {
	
	            /**
	             * save or update wizard form
	             */
	
	            value: function save_update() {
	                var _this = this;
	
	                var recursed = arguments[0] === undefined ? false : arguments[0];
	                var changeState = arguments[1] === undefined ? true : arguments[1];
	
	                var defer = this.$q.defer();
	
	                if (!recursed && this.repoInfo.isType("cocoapods") && this.baseUrl === this.NO_VALUE_STRING) {
	                    this._showUrlBaseAlert().then(function (gotoGenConf) {
	                        if (gotoGenConf) {
	                            _this.save_update(true).then(function () {
	                                _this.$state.go("admin.configuration.general", { focusOnBaseUrl: true });
	                            });
	                        } else {
	                            _this.save_update(true);
	                        }
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                } else {
	                    if (this.repoInfo && this.repoInfo.typeSpecific && this.repoInfo.typeSpecific.keyPair === "") {
	                        delete this.repoInfo.typeSpecific.keyPair;
	                    }
	                    if (this.newRepository) {
	                        this.repositoriesDao.save(this.repoInfo).$promise.then(function (result) {
	                            _this.ArtifactoryModelSaver.save();
	                            _this.savePending = false;
	
	                            // Track new repository creation to Google Analytics
	                            if (_this.repoInfo && _this.repoInfo.typeSpecific) {
	                                var repoData = [];
	                                if (_.includes(["local", "remote", "distribution"], _this.repoType)) {
	                                    if (_this.repoType === "remote" && _this.repoInfo.typeSpecific.repoType === "Docker") {
	                                        repoData.push("enableForeignLayersCaching:" + _this.repoInfo.typeSpecific.enableForeignLayersCaching);
	                                    }
	                                    _this.GoogleAnalytics.trackEvent("Admin", "Create Repo", _this.repoInfo.typeSpecific.repoType, null, _this.repoType, repoData[0] || "");
	                                } else if (_this.repoType === "virtual") {
	                                    // Enable Dependency Rewrite (bower/npm)
	                                    var repoType = _this.repoInfo.typeSpecific.repoType;
	                                    if (repoType === "Bower" || repoType === "Npm") {
	                                        repoData.push("enableDependencyRewrite:" + _this.repoInfo.typeSpecific.enableExternalDependencies);
	                                    }
	
	                                    // Default Deployment Repository
	                                    var defaultDeploymentRepo = !!_this.repoInfo.basic.defaultDeploymentRepo;
	                                    repoData.unshift("defaultDeploymentRepo:" + defaultDeploymentRepo);
	
	                                    _this.GoogleAnalytics.trackEvent("Admin", "Create Repo", _this.repoInfo.typeSpecific.repoType, _this.repoInfo.basic.selectedRepositories.length, _this.repoType, repoData[0] || "", repoData[1] || "");
	                                }
	                            }
	
	                            if (_this.repoInfo.typeSpecific.repoType === "Docker" && _this.features.isAol()) {
	                                (function () {
	                                    var modalScope = _this.$scope.$new();
	
	                                    var dockerData = {
	                                        repoKey: _this.repoInfo.general.repoKey,
	                                        packageType: _this.repoType
	                                    };
	
	                                    _this.DockerStatusDao.get({ repoKey: dockerData.repoKey }).$promise.then(function (data) {
	                                        dockerData.hostname = data.hostname;
	                                        dockerData.dockerPath = data.hostname + "-" + dockerData.repoKey + ".jfrog.io";
	                                        dockerData.noDeployToLocal = !_this.repoInfo.basic.defaultDeploymentRepo;
	                                        dockerData = _this.getDockerSnippets(dockerData);
	                                        modalScope.dockerData = dockerData;
	
	                                        _this.dockerPopup = _this.modal.launchModal("new_docker_modal", modalScope).result;
	                                        _this.dockerPopup["finally"](function () {
	                                            if (changeState) _this.$state.go("^.list", { repoType: _this.repoType });
	                                        });
	                                    });
	                                })();
	                            } else if (changeState) _this.$state.go("^.list", { repoType: _this.repoType });
	                            defer.resolve();
	                        })["catch"](function () {
	                            return _this.savePending = false;
	                        });
	                    } else {
	                        this.repositoriesDao.update(this.repoInfo).$promise.then(function (result) {
	                            _this.ArtifactoryModelSaver.save();
	                            _this.savePending = false;
	
	                            if (changeState) _this.$state.go("^.list", { repoType: _this.repoType });
	                            defer.resolve();
	                        })["catch"](function () {
	                            return _this.savePending = false;
	                        });
	                    }
	                }
	
	                return defer.promise;
	            }
	        },
	        getDockerSnippets: {
	            value: function getDockerSnippets(dockerData) {
	                var allSnippets = {
	                    dockerLogin: { message: "According to the repository permission, you will need to login to your repository with docker login command", snippet: "docker login " + dockerData.dockerPath },
	                    dockerPull: { message: "Pull an image.", snippet: "docker pull " + dockerData.dockerPath + "/hello-world" },
	                    dockerTag: { message: "Tag an image.", snippet: "docker tag hello-world " + dockerData.dockerPath + "/hello-world" },
	                    dockerPush: { message: "Then push it to your repository.", snippet: "docker push " + dockerData.dockerPath + "/hello-world" },
	                    dockerPushIt: { message: "Then push it.", snippet: "docker push " + dockerData.dockerPath + "/hello-world" },
	                    dockerTest: { message: "And to test deploy to virtual, tag an image.", snippet: "docker tag hello-world " + dockerData.dockerPath + "/hello-world" },
	                    dockerPullImageFromRepo: { message: "To pull an image from your repository.", snippet: "docker pull " + dockerData.dockerPath + "/hello-world" } };
	
	                dockerData.snippets = [];
	                if (this.repoInfo.typeSpecific.dockerApiVersion === "V2") {
	                    dockerData.snippets.push(allSnippets.dockerLogin);
	                }
	
	                switch (dockerData.packageType) {
	                    case "local":
	                        dockerData.snippets.push(allSnippets.dockerPull);
	                        dockerData.snippets.push(allSnippets.dockerTag);
	                        dockerData.snippets.push(allSnippets.dockerPush);
	                        break;
	                    case "remote":
	                        dockerData.snippets.push(allSnippets.dockerPull);
	                        break;
	                    case "virtual":
	                        if (!dockerData.noDeployToLocal) {
	                            dockerData.snippets.push(allSnippets.dockerPull);
	                            dockerData.snippets.push(allSnippets.dockerTest);
	                            dockerData.snippets.push(allSnippets.dockerPushIt);
	                            dockerData.snippets.push(allSnippets.dockerPullImageFromRepo);
	                        } else {
	                            dockerData.snippets.push(allSnippets.dockerPullImageFromRepo);
	                        }
	                        break;
	                }
	                return dockerData;
	            }
	        },
	        _showUrlBaseAlert: {
	            value: function _showUrlBaseAlert() {
	                var modalScope = this.$scope.$new();
	                modalScope.context = "cocoapods";
	                return this.modal.launchModal("base_url_alert_modal", modalScope, "md").result;
	            }
	        },
	        prevStep: {
	
	            /**
	             * button pre and  forward at the bottom page
	             */
	
	            value: function prevStep() {
	                if (this.currentTab == "advanced") {
	                    this.setCurrentTab("basic");
	                } else if (this.currentTab == "replications") {
	                    this.setCurrentTab("advanced");
	                } else if (this.currentTab == "rules") {
	                    this.setCurrentTab("advanced");
	                }
	            }
	        },
	        fwdStep: {
	            value: function fwdStep() {
	                if (this.currentTab == "basic") {
	                    this.setCurrentTab("advanced");
	                    return;
	                }
	                if (this.currentTab == "advanced" && this.repoType != fieldsValuesDictionary.REPO_TYPE.VIRTUAL && this.repoType != fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    this.setCurrentTab("replications");
	                }
	                if (this.currentTab == "advanced" && this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    this.setCurrentTab("rules");
	                }
	            }
	        },
	        openRepoTypeModal: {
	
	            /**
	             * function for select package type
	             */
	
	            value: function openRepoTypeModal() {
	                var _this = this;
	
	                var addTextBelowIcon = ["Bower", "Chef", "CocoaPods", "Conan", "Pypi", "Puppet", "Opkg", "Composer", "SBT", "Gradle", "Gems", "NuGet", "GitLfs", "Generic", "P2", "VCS", "CRAN"];
	                this.$repoTypeScope = this.$scope.$new();
	                this.$repoTypeScope.packageTypes = this.getPackageType();
	                this.$repoTypeScope.highlightCheck = function (typeFilter, type) {
	                    if (typeFilter) {
	                        var string = type.text.toLowerCase(),
	                            searchstring = typeFilter.toLowerCase().replace(/ /g, "");
	
	                        if (string.substr(0, searchstring.length) == searchstring) {
	                            type.highlighted = true;
	                            return true;
	                        } else {
	                            type.highlighted = false;
	                            return false;
	                        };
	                    }
	                };
	                this.$repoTypeScope.checkNoResults = function (typeFilter) {
	                    if (typeFilter && typeFilter.length > 0 && _.filter(_this.packageType, function (type) {
	                        return type.highlighted;
	                    }).length == 0) {
	                        return true;
	                    }
	                };
	                this.$repoTypeScope.isSelected = function () {
	                    var HighlightedListItems = _.filter(_this.packageType, function (type) {
	                        return type.highlighted;
	                    });
	                    if (HighlightedListItems.length == 1) {
	                        return true;
	                    }
	                };
	                this.$repoTypeScope.selectPackage = function () {
	                    var selectedItem = _.filter(_this.packageType, function (type) {
	                        return type.highlighted;
	                    });
	                    if (selectedItem.length == 1) {
	                        _this.selectRepoType(selectedItem[0]);
	                    }
	                };
	
	                _.map(this.$repoTypeScope.packageTypes, function (type) {
	                    if (_.includes(addTextBelowIcon, type.serverEnumName)) type.helpText = true;
	                });
	
	                if (this.features.isNonCommercial()) {
	                    _.forEach(this.$repoTypeScope.packageTypes, function (item) {
	                        if (!_this.features.isEnabled(item.value)) item.disabled = true;
	                    });
	
	                    var activeItems = [];
	                    if (this.features.isConanCE()) {
	                        activeItems = _.remove(this.$repoTypeScope.packageTypes, function (item) {
	                            return item.serverEnumName === "Conan" || item.serverEnumName === "Generic";
	                        });
	                    } else if (this.features.isJCR()) {
	                        activeItems = _.remove(this.$repoTypeScope.packageTypes, function (item) {
	                            return item.serverEnumName === "Docker" || item.serverEnumName === "Helm" || item.serverEnumName === "Generic";
	                        });
	                    }
	
	                    this.$repoTypeScope.packageTypes = [].concat(_toConsumableArray(activeItems), _toConsumableArray(this.$repoTypeScope.packageTypes));
	                }
	                this.$repoTypeScope.closeModal = function () {
	                    return _this.closeModalPackageType();
	                };
	                this.$repoTypeScope.modalClose = function () {
	                    return _this.modalClose();
	                };
	                this.$repoTypeScope.selectRepoType = function (type) {
	                    return _this.selectRepoType(type);
	                };
	                this.isTypeModalOpen = true;
	
	                this.repoTypeModal = this.modal.launchModal("repository_type_modal", this.$repoTypeScope, 1000);
	                this.repoTypeModal.result["finally"](function () {
	                    _this.repositoriesForm.repoKey.$validate();
	                    _this.isTypeModalOpen = false;
	                    if (_this.repoInfo.isType("debian")) {
	                        _this.onFormatSelectionChange();
	                    }
	                });
	            }
	        },
	        openBintrayOAuthModal: {
	            value: function openBintrayOAuthModal() {
	                var _this = this;
	
	                this.$bintrayAuthScope = this.$scope.$new();
	                //Stuff for outgoing request
	                this.$bintrayAuthScope.isBackFromBintray = this.$location.search().code;
	                this.$bintrayAuthScope.bintrayBaseUrl = this.repoInfo.typeSpecific.bintrayBaseUrl;
	                this.$bintrayAuthScope.redirectUrl = encodeURIComponent(this.$location.absUrl());
	
	                if (this.$bintrayAuthScope.isBackFromBintray) {
	                    this.$bintrayAuthScope.redirectUrl = encodeURIComponent(this.$location.absUrl().split("?")[0]);
	                    //this.$bintrayAuthScope.redirectUrl = encodeURIComponent(this.$location.absUrl().substring(0, this.$location.absUrl().indexOf('?')));
	                } else {
	                    this.$bintrayAuthScope.redirectUrl = encodeURIComponent(this.$location.absUrl());
	                }
	
	                this.$bintrayAuthScope.config = { bintraySecretString: "" };
	                this.$bintrayAuthScope.saveBintrayAuthInModel = function () {
	                    return _this.saveBintrayAuthInModel(_this.$bintrayAuthScope.config.bintraySecretString);
	                };
	                this.isBintrayModalOpen = true;
	
	                this.bintrayAuthModal = this.modal.launchModal("bintray_oauth_modal", this.$bintrayAuthScope, 600);
	                this.bintrayAuthModal.result.then(function () {
	                    _this.isBintrayModalOpen = false;
	                    _this.repositoriesForm.repoKey.$validate();
	                });
	                this.bintrayAuthModal.result["catch"](function () {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.list", { repoType: _this.repoType });
	                });
	            }
	        },
	        goToBintray: {
	            value: function goToBintray() {
	                var url = this.$bintrayAuthScope.bintrayBaseUrl + "/login/oauth/authorize?scope=org:?:admin&redirect_uri=" + this.$bintrayAuthScope.redirectUrl + "&artifactory_originated=Oik=";
	                window.open(url, "_self");
	            }
	        },
	        closeModalPackageType: {
	            value: function closeModalPackageType() {
	                if (!this.repoType) {
	                    return false;
	                }
	                if (this.newRepository) {
	                    this.setRepoLayout();
	                }
	                if (this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                    // Resetting resolved and selected repositories lists in case we are changing package type
	                    if (this.newRepository) {
	                        this.repoInfo.basic.selectedRepositories = [];
	                        this.repoInfo.basic.resolvedRepositories = [];
	                    }
	                    this._getRepositoriesByType();
	                }
	            }
	        },
	        _getRepositoriesByType: {
	            value: function _getRepositoriesByType() {
	                var _this = this;
	
	                this.repositoriesDao.availableRepositoriesByType({
	                    type: this.repoInfo.typeSpecific.repoType,
	                    repoKey: this.repoInfo.general ? this.repoInfo.general.repoKey : ""
	                }).$promise.then(function (repos) {
	                    repos.availableLocalRepos = _.map(repos.availableLocalRepos, function (repo) {
	                        return {
	                            repoName: repo,
	                            type: "local",
	                            _iconClass: "icon icon-local-repo"
	                        };
	                    });
	                    repos.availableRemoteRepos = _.map(repos.availableRemoteRepos, function (repo) {
	                        return {
	                            repoName: repo,
	                            type: "remote",
	                            _iconClass: "icon icon-remote-repo"
	                        };
	                    });
	                    repos.availableVirtualRepos = _.map(repos.availableVirtualRepos, function (repo) {
	                        return {
	                            repoName: repo,
	                            type: "virtual",
	                            _iconClass: "icon icon-virtual-repo"
	                        };
	                    });
	
	                    _this.repoInfo.basic.selectedRepositories = _.map(_this.repoInfo.basic.selectedRepositories, function (repo) {
	                        if (repo.type == "local") {
	                            return {
	                                repoName: repo.repoName,
	                                type: "local",
	                                _iconClass: "icon icon-local-repo"
	                            };
	                        } else if (repo.type == "remote") {
	                            return {
	                                repoName: repo.repoName,
	                                type: "remote",
	                                _iconClass: "icon icon-remote-repo"
	                            };
	                        } else if (repo.type == "virtual") {
	                            return {
	                                repoName: repo.repoName,
	                                type: "virtual",
	                                _iconClass: "icon icon-virtual-repo"
	                            };
	                        }
	                    });
	
	                    _this.repositoriesList = [];
	                    _this.repositoriesList = repos.availableLocalRepos.concat(repos.availableRemoteRepos).concat(repos.availableVirtualRepos);
	
	                    if (!_this.newRepository) _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        getReplicationActions: {
	            value: function getReplicationActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-run",
	                    tooltip: "Run Now",
	                    visibleWhen: function (row) {
	                        return !_this.globalReplicationsStatus.blockPushReplications && row.enabled;
	                    },
	                    callback: function (row) {
	                        return _this.executeReplicationNow(row);
	                    }
	                }, {
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this._deleteReplication(row);
	                    }
	                }];
	            }
	        },
	        executeReplicationNow: {
	            value: function executeReplicationNow(row) {
	                if (true) {
	                    this.repositoriesDao.executeReplicationNow({ replicationUrl: row.url }, this.repoInfo).$promise.then(function (result) {});
	                }
	            }
	        },
	        setRepoLayout: {
	            value: function setRepoLayout() {
	                var _this = this;
	
	                var foundLayout = false;
	                if (_.has(this.repoInfo, "typeSpecific.repoType")) {
	                    (function () {
	                        var type = _this.repoInfo.typeSpecific.repoType.toLowerCase();
	                        var defaultLayouts = fieldsValuesDictionary.defaultLayouts;
	                        if (!_this.repoInfo.basic) {
	                            _this.repoInfo.basic = {};
	                            _this.repoInfo.basic.repositoryLayout = {};
	                        }
	                        _this.repositoryLayouts = _.filter(_this.repositoryLayouts, function (layout) {
	                            return layout !== "";
	                        });
	                        if (_this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                            _this.repositoryLayouts.unshift("");
	                        }
	
	                        var defaultLayout = defaultLayouts[type];
	                        if (defaultLayout && _.includes(_this.repositoryLayouts, defaultLayout)) {
	                            _this.repoInfo.basic.layout = defaultLayout;
	                            foundLayout = true;
	                        } else {
	                            _this.repositoryLayouts.forEach(function (layout) {
	                                if (layout.indexOf(type) != -1) {
	                                    _this.repoInfo.basic.layout = layout;
	                                    foundLayout = true;
	                                }
	                            });
	                        }
	                        if (!foundLayout) {
	                            _this.repoInfo.basic.layout = "simple-default";
	                        }
	                    })();
	                }
	            }
	        },
	        _setDefaultValuesByType: {
	
	            /**
	             * set default fields for new repository
	             */
	
	            value: function _setDefaultValuesByType() {
	                if (!(this.repoInfo && this.repoInfo.typeSpecific)) {
	                    this.repoInfo.typeSpecific = {};
	                }
	                var type = this.repoInfo.typeSpecific.repoType.toLowerCase();
	                if (type && this.defaultModels[type]) {
	                    angular.extend(this.repoInfo.typeSpecific, this.defaultModels[type]);
	                    // add default remote url for remote repository
	                    if (this.repoType.toLocaleLowerCase() == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                        this.repoInfo.basic.url = this.defaultModels[type].url;
	                    }
	                }
	                if (this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.VIRTUAL) {
	                    this.repoInfo.basic.repositoryLayout = "";
	                }
	            }
	        },
	        _setDefaultFields: {
	            value: function _setDefaultFields() {
	                if (!this.repoInfo.typeSpecific) {
	                    this.repoInfo.typeSpecific = {};
	                }
	                this.repoInfo.advanced = {};
	                this.repoInfo.advanced.cache = {};
	                this.repoInfo.advanced.network = {};
	
	                _.forEach(this.defaultModels, function (item) {
	                    if (item.maxUniqueTags === 0) {
	                        item.maxUniqueTags = "";
	                    }
	                    if (item.maxUniqueSnapshots === 0) {
	                        item.maxUniqueSnapshots = "";
	                    }
	                    if (item.keepUnusedArtifactsHours === 0) {
	                        item.keepUnusedArtifactsHours = "";
	                    }
	                });
	
	                angular.extend(this.repoInfo.advanced.cache, this.defaultModels.cache);
	                angular.extend(this.repoInfo.advanced.network, this.defaultModels.network);
	                if (this.repoInfo.advanced.network.installedCertificatesList) {
	                    this.repoInfo.advanced.network.installedCertificatesList.unshift("");
	                }
	
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    if (!this.repoInfo.advanced) {
	                        this.repoInfo.advanced = {};
	                    }
	                    if (!this.repoInfo.basic) {
	                        this.repoInfo.basic = {};
	                    }
	
	                    angular.extend(this.repoInfo.advanced, this.defaultModels.remoteAdvanced);
	                    angular.extend(this.repoInfo.basic, this.defaultModels.remoteBasic);
	                } else if (this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL || this.repoType == fieldsValuesDictionary.REPO_TYPE.VIRTUAL || this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    if (!this.repoInfo.advanced) {
	                        this.repoInfo.advanced = {};
	                    }
	                    if (!this.repoInfo.basic) {
	                        this.repoInfo.basic = {};
	                    }
	                    angular.extend(this.repoInfo.advanced, this.defaultModels.localAdvanced);
	                    angular.extend(this.repoInfo.basic, this.defaultModels.localBasic);
	                    this.repoInfo.typeSpecific.localChecksumPolicy = this.defaultModels.maven.localChecksumPolicy;
	                    if (this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                        if (this.isReleaseBundleRepo) {
	                            this.repoInfo.advanced = {};
	                            this.repoInfo.typeSpecific = {
	                                repoType: REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES
	                            };
	                            this.repoInfo.basic.includesPatternArray = ["**/*"];
	                            this.repoInfo.basic.excludesPatternArray = [];
	                            return;
	                        } else {
	                            this.repoInfo.typeSpecific = this.defaultModels.distribution;
	                            this.repoInfo.basic.layout = "simple-default";
	                            this.distributionType = false;
	                        }
	                    }
	                }
	
	                this.repoInfo.basic.includesPatternArray = ["**/*"];
	                this.repoInfo.basic.excludesPatternArray = [];
	
	                this._setDefaultProxy();
	            }
	        },
	        selectRepoType: {
	            value: function selectRepoType(type) {
	                var _this = this;
	
	                if (this.features.isDisabled(type.value)) {
	                    return;
	                }
	
	                this.repoTypeModal.close();
	                if (!this.repoInfo.typeSpecific) {
	                    this.repoInfo.typeSpecific = {};
	                }
	                this.repoInfo.typeSpecific.repoType = type.serverEnumName;
	                this.repoInfo.typeSpecific.icon = type.icon;
	                this.repoInfo.typeSpecific.text = type.text;
	                if (this.repoInfo.typeSpecific.repoType === "Docker" && !this.features.isAol() && !this.features.isNonCommercial()) {
	                    this._getReveresProxyConfigurations();
	                }
	                if (this.repoInfo.typeSpecific.repoType === "CocoaPods" && this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    this.repoInfo.advanced.network.socketTimeout = 45000;
	                }
	
	                if (this.newRepository) {
	                    this._setDefaultValuesByType();
	                }
	                this.closeModalPackageType();
	
	                // Go import in virtual repo specific tooltip
	                if (this.repoType === "virtual") {
	                    this.whitelistTooltip = "";
	                    this.$timeout(function () {
	                        return _this.whitelistTooltip = type.value === "go" ? _this.TOOLTIP.virtualForm.externalDependenciesPatternsGo : _this.TOOLTIP.virtualForm.externalDependenciesPatterns;
	                    });
	                }
	            }
	        },
	        saveBintrayAuthInModel: {
	            value: function saveBintrayAuthInModel(bintraySecretString) {
	                var _this = this;
	
	                //todo -- should respond to feature disabled?
	                if (!this.repoInfo.typeSpecific) {
	                    this.repoInfo.typeSpecific = {};
	                }
	                this.repoInfo.typeSpecific.repoType = "Distribution";
	                if (this.newRepository) {
	                    this._setDefaultValuesByType();
	                }
	                this.repoInfo.typeSpecific.bintrayAuthString = bintraySecretString;
	                this.repoInfo.typeSpecific.redirectUrl = this.$location.absUrl().split("?")[0];
	                this.repoInfo.typeSpecific.paramClientId = this.$location.search().client_id;
	                this.repoInfo.typeSpecific.code = this.$location.search().code;
	                this.repoInfo.typeSpecific.scope = this.$location.search().scope;
	                this.repositoriesDao.saveBintrayOauthConfig(this.repoInfo.typeSpecific).$promise.then(function (result) {
	                    _this.bintrayAuthModal.close();
	                    //Result from backend contains the key for the newly created OAuth app that this repo must reference.
	                    _this.repoInfo.typeSpecific = result.data;
	                    var isPremium = _this.repoInfo.typeSpecific.premium;
	                    if (!isPremium) {
	                        _this.bintrayAuthentication = false;
	                    }
	                    _this._setupLicenses();
	                    _this._checkVisibility(isPremium);
	                    _this._setRulesPackages();
	                })["catch"](function () {});
	            }
	        },
	        isRightColumnEmptyInLocalRepo: {
	            value: function isRightColumnEmptyInLocalRepo() {
	                return !this.repoInfo.isType("maven", "gradle", "ivy", "sbt", "yum", "cocoapods", "debian", "docker", "nuget");
	            }
	        },
	        isRightColumnEmptyInRemoteRepo: {
	            value: function isRightColumnEmptyInRemoteRepo() {
	                return !this.repoInfo.basic.contentSynchronisation.enabled && !this.smartRepoUnknownCapabilities && !this.repoInfo.isType("maven", "gradle", "ivy", "sbt", "generic", "vcs", "bower", "cocoapods", "composer", "docker", "nuget", "debian", "yum", "p2", "pypi", "go", "helm");
	            }
	        },
	        isVirtualAdvancedAvailable: {
	            value: function isVirtualAdvancedAvailable() {
	                return !this.repoInfo.isType("gems", "nuget", "chef", "gitlfs", "p2", "pypi", "yum", "generic", "puppet", "helm", "conda", "debian");
	            }
	        },
	        isVcsRepository: {
	            value: function isVcsRepository() {
	                return this.repoInfo.isType("vcs", "bower", "cocoapods", "composer", "go", "pypi");
	            }
	        },
	        newReplication: {
	
	            /**
	             * newReplication; editReplication->
	             * functions for replications modal (work only for local repos)
	             */
	
	            value: function newReplication() {
	                if (this.repoInfo.replications && this.repoInfo.replications.length && this.features.isDisabled("highAvailability") && !this.features.isDedicatedAol()) {
	                    this.notifications.create({ warn: "Multi-push replication will only work with an Enterprise license" });
	                    return true;
	                }
	                this.replicationScope.replication = {};
	                this.replicationScope.title = "New Replication";
	                this.replicationScope.replication.socketTimeout = 15000;
	                this.replicationScope.replication.syncProperties = true;
	                this.replicationScope.sourceReplication = null;
	                this.replicationScope.replication.enabled = true;
	                this.replicationModal(false);
	            }
	        },
	        editReplication: {
	            value: function editReplication(row) {
	                this.replicationScope.title = "Replication Properties";
	                this.replicationScope.replication = angular.copy(row);
	                this.replicationScope.sourceReplication = row;
	                this.replicationModal(true);
	            }
	        },
	        _deleteReplication: {
	            value: function _deleteReplication(row) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you wish to delete this replication?", "Delete Replication", { confirm: "Delete" }).then(function () {
	                    _.remove(_this.repoInfo.replications, row);
	                    _this.replicationsGridOption.setData(_this.repoInfo.replications);
	                });
	            }
	        },
	        replicationModal: {
	            value: function replicationModal(isEdit) {
	                this.replicationScope.replication.proxies = this.fields.proxies;
	                if (!isEdit) {
	                    this.fields.defaultProxy ? this.replicationScope.replication.proxy = this.fields.defaultProxy : "";
	                }
	                this.modalInstance = this.modal.launchModal("replication_modal", this.replicationScope);
	            }
	        },
	        addReplication: {
	
	            /**
	             * add replication: function that save fields in form for replication.
	             * if local: push it for grid replication
	             * if remote: clear exsit replication and set the new one
	             */
	
	            value: function addReplication(replication) {
	
	                if (this.repoType.toLowerCase() == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    this.repoInfo.replications = [];
	                }
	                replication.enabled = replication.enabled ? replication.enabled : false;
	                replication.syncDeletes = replication.syncDeletes ? replication.syncDeletes : false;
	                replication.syncProperties = replication.syncProperties ? replication.syncProperties : false;
	                replication.syncStatistics = replication.syncStatistics ? replication.syncStatistics : false;
	                replication.cronExp = this.repoInfo.cronExp;
	                replication.nextTime = this.repoInfo.nextTime;
	                replication.enableEventReplication = this.repoInfo.enableEventReplication;
	                replication.type = this.repoType;
	                if (replication.proxy === "") {
	                    delete replication.proxy;
	                }
	                if (this.replicationScope.sourceReplication) {
	                    // updating replication
	                    angular.copy(replication, this.replicationScope.sourceReplication);
	                } else {
	                    // adding new replication
	                    this.repoInfo.replications = this.repoInfo.replications || [];
	                    this.repoInfo.replications.push(replication);
	                }
	                if (this.repoType.toLocaleLowerCase() == fieldsValuesDictionary.REPO_TYPE.LOCAL) {
	                    this.replicationsGridOption.setData(this.repoInfo.replications);
	                    this.closeModal();
	                }
	            }
	        },
	        saveCronAndEventFlagToAllReplicationsAndValidateHa: {
	
	            /**
	             * Saves the cron expression and event replication flag to all replications.
	             * Also validates that if HA license is not installed - only one active replication is saved.
	             */
	
	            value: function saveCronAndEventFlagToAllReplicationsAndValidateHa() {
	                var _this = this;
	
	                //Signifies save should disable all replications but one because multiple enabled replicaions exist without HA license
	                var notHa = this.features.isDisabled("highAvailability") && !this.features.isDedicatedAol() && this.repoInfo.replications.length > 1;
	                this.repoInfo.replications.forEach(function (replication) {
	                    replication.cronExp = _this.repoInfo.cronExp;
	                    replication.enableEventReplication = _this.repoInfo.enableEventReplication;
	                    if (notHa) {
	                        replication.enabled = false;
	                    }
	                });
	                if (notHa) {
	                    this.notifications.create({ warn: "You saved multiple enabled replication configurations.\n Multi-push " + "replication is only available with an Enterprise licenses therefore only the first replication will be" + "saved as enabled and the rest will be disabled." });
	                    this.repoInfo.replications[0].enabled = true;
	                }
	            }
	        },
	        closeModal: {
	            value: function closeModal() {
	                this.modalInstance.close();
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.replicationsGridOption = new this.JFrogTableViewOptions(this.$scope);
	                this.replicationsGridOption.setRowsPerPage(10).setColumns(this._getColumns()).setSelection(this.replicationsGridOption.SINGLE_SELECTION).setEmptyTableText("No replications").setObjectName("Repository/Repositories").setActions(this.getReplicationActions());
	                //
	                this.replicationsGridOption.setData([]);
	            }
	        },
	        showNextButton: {
	
	            /**
	             * controller display arrows form
	             */
	
	            value: function showNextButton() {
	                if (this.repoType == fieldsValuesDictionary.REPO_TYPE.LOCAL || this.repoType == fieldsValuesDictionary.REPO_TYPE.REMOTE) {
	                    if (this.features.isDisabled("replications")) {
	                        return this.currentTab != "advanced";
	                    }
	                    return this.currentTab != "replications";
	                } else if (this.repoType == fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION) {
	                    if (this.features.isDisabled("rules")) {
	                        return this.currentTab != "advanced";
	                    }
	                    return this.currentTab != "rules";
	                } else {
	                    return this.currentTab != "advanced";
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "URL",
	                    header: "URL",
	                    field: "url",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ng-click=\"grid.appScope.RepositoryForm.editReplication(row.entity)\" class=\"jf-link\">{{row.entity.url}}</a></div>"
	
	                }, {
	                    name: "Sync Deletes",
	                    header: "Sync Deletes",
	                    field: "syncDeletes",
	                    cellTemplate: this.JFrogTableViewOptions.cellTemplateGenerators.checkboxColumn("row.entity.syncDeletes")
	                }, {
	                    name: "Sync Properties",
	                    header: "Sync Properties",
	                    field: "syncProperties",
	                    cellTemplate: this.JFrogTableViewOptions.cellTemplateGenerators.checkboxColumn("row.entity.syncProperties")
	                }, {
	                    name: "Enabled",
	                    header: "Enabled",
	                    field: "enabled",
	                    cellTemplate: this.JFrogTableViewOptions.cellTemplateGenerators.checkboxColumn("row.entity.enabled")
	                }];
	            }
	        },
	        getPackageType: {
	
	            /**
	             * all packages sorts by type
	             */
	
	            value: function getPackageType() {
	                switch (this.repoType) {
	                    case fieldsValuesDictionary.REPO_TYPE.LOCAL:
	                        {
	                            return _.filter(this.packageType, function (type) {
	                                return _.indexOf(type.repoType, fieldsValuesDictionary.REPO_TYPE.LOCAL) != -1;
	                            });
	                        }
	                    case fieldsValuesDictionary.REPO_TYPE.REMOTE:
	                        {
	                            return _.filter(this.packageType, function (type) {
	                                return _.indexOf(type.repoType, fieldsValuesDictionary.REPO_TYPE.REMOTE) != -1;
	                            });
	                        }
	                    case fieldsValuesDictionary.REPO_TYPE.VIRTUAL:
	                        {
	                            return _.filter(this.packageType, function (type) {
	                                return _.indexOf(type.repoType, fieldsValuesDictionary.REPO_TYPE.VIRTUAL) != -1;
	                            });
	                        }
	                    case fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION:
	                        {
	                            return fieldsValuesDictionary.REPO_TYPE.DISTRIBUTION;
	                        }
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.list", { repoType: this.repoType });
	            }
	        },
	        _getReveresProxyConfigurations: {
	            value: function _getReveresProxyConfigurations() {
	                var _this = this;
	
	                this.reverseProxiesDao.get().$promise.then(function (reverseProxies) {
	
	                    _this.reverseProxyConfigured = reverseProxies.serverName && reverseProxies.webServerType && (reverseProxies.useHttp || reverseProxies.useHttps) && reverseProxies.dockerReverseProxyMethod !== "NOVALUE";;
	
	                    //            this.hideReverseProxy = this.reverseProxyConfigured
	
	                    if (_this.reverseProxyConfigured) {
	                        if (!_this.repoInfo.advanced.reverseProxy) {
	                            _this.repoInfo.advanced.reverseProxy = {
	                                key: reverseProxies.key,
	                                serverName: reverseProxies.serverName
	                            };
	                        }
	                        if (reverseProxies.dockerReverseProxyMethod === "PORTPERREPO") {
	                            _this.reverseProxyPortMode = true;
	                            _this.repoInfo.advanced.reverseProxy.serverName = reverseProxies.serverName;
	                        } else if (reverseProxies.dockerReverseProxyMethod === "REPOPATHPREFIX") {} else {
	                            _this.reverseProxyPortMode = false;
	                            if (_this.repoInfo.general && _this.repoInfo.general.repoKey) _this.repoInfo.advanced.reverseProxy.serverName = reverseProxies.serverNameExpression.replace("*", _this.repoInfo.general.repoKey);
	                            _this.reverseProxyServerNameExpression = reverseProxies.serverNameExpression;
	                        }
	                    }
	                });
	            }
	        },
	        onChangeRepoKey: {
	            value: function onChangeRepoKey() {
	                if (this.repoInfo.general && this.repoInfo.general.repoKey && this.reverseProxyServerNameExpression) this.repoInfo.advanced.reverseProxy.serverName = this.reverseProxyServerNameExpression.replace("*", this.repoInfo.general.repoKey);
	            }
	        },
	        onChangeForeignLayersCachingEnabled: {
	            value: function onChangeForeignLayersCachingEnabled() {
	                if (this.repoInfo.typeSpecific.enableForeignLayersCaching) {
	                    if (!this.repoInfo.typeSpecific.externalPatterns) {
	                        this.repoInfo.typeSpecific.externalPatterns = ["**"];
	                    }
	                }
	            }
	        },
	        _getGeneralConfig: {
	            value: function _getGeneralConfig() {
	                var _this = this;
	
	                this.generalConfigDao.get().$promise.then(function (data) {
	                    _this.baseUrl = data.customUrlBase || _this.NO_VALUE_STRING;
	                    _this.isS3Configured = data.s3Configured;
	                });
	            }
	        },
	        _getGlobalReplicationsStatus: {
	            value: function _getGlobalReplicationsStatus() {
	                var _this = this;
	
	                this.globalReplicationsConfigDao.status().$promise.then(function (status) {
	                    _this.globalReplicationsStatus = {
	                        blockPullReplications: status.blockPullReplications,
	                        blockPushReplications: status.blockPushReplications
	                    };
	                });
	            }
	        },
	        hostYumOriginalValue: {
	
	            // YUM FOLDER DEPTH TOOLTIP
	
	            value: function hostYumOriginalValue() {
	                this.originalYumValue;
	                if (this.originalValueFlag) {
	                    this.originalYumValue = this.repoInfo.typeSpecific.metadataFolderDepth;
	                    this.originalValueFlag = false;
	                }
	            }
	        },
	        changeYumFolderDepth: {
	            value: function changeYumFolderDepth() {
	                this.yumTooltip = this.repoInfo.typeSpecific.metadataFolderDepth < this.originalYumValue ? true : false;
	            }
	        },
	        _setRulesPackages: {
	
	            // DISTRIBUTION RULES
	
	            value: function _setRulesPackages() {
	                var _this = this;
	
	                this.distributionRulesPackages = _.filter(this.packageType, function (o) {
	                    if (_this.features.isOss()) {
	                        return o.value == "generic" || o.value == "maven" || o.value == "gradle" || o.value == "ivy" || o.value == "sbt";
	                    } else if (_this.features.isConanCE()) {
	                        return o.value == "generic" || o.value == "conan";
	                    } else if (_this.features.isJCR()) {
	                        return o.value == "generic" || o.value == "docker" || o.value == "helm";
	                    } else {
	                        return o.value != "gitlfs" && o.value != "gems" && o.value != "pypi" && o.value != "p2" && o.value != "vcs";
	                    }
	                });
	                this.distributionRulesPackages.forEach(function (pack) {
	                    return delete pack.description;
	                });
	            }
	        },
	        _checkVisibility: {
	            value: function _checkVisibility(isPremium) {
	                if (!isPremium) {
	                    this.defaultNewRepoPrivateSwitch = "Public";
	                    this.repoInfo.basic.defaultNewRepoPrivate = false;
	                    this.repoInfo.basic.defaultNewRepoPremium = false;
	                } else {
	                    this.defaultNewRepoPrivateSwitch = "Private";
	                    this.repoInfo.basic.defaultNewRepoPrivate = true;
	                    this.repoInfo.basic.defaultNewRepoPremium = true;
	                }
	            }
	        },
	        _setupLicenses: {
	            value: function _setupLicenses() {
	                // License input configuration
	                this.licensesList = _.map(this.repoInfo.typeSpecific.availableLicenses, function (lic) {
	                    return {
	                        text: lic,
	                        value: lic
	                    };
	                });
	            }
	        },
	        _setupDistribution: {
	
	            // TODO: try understand why there is a glitch with width when dragging
	
	            value: function _setupDistribution() {
	                this.distRepoRulesGridData = [];
	                this.rulesGridOptions = new this.JFrogTableViewOptions(this.$scope);
	                this.rulesGridOptions.setNewEntityAction(this.rulesPopup.bind(this)).setDraggable(this._reorderRules.bind(this)).setColumns(this._getDistributionRulesColumns()).setActions(this._getRulesActions()).setBatchActions(this._getBatchActions()).setRowsPerPage(10).setEmptyTableText("No rules to show").setObjectName("Rule/Rules").setSelection(this.JFrogTableViewOptions.MULTI_SELECTION);
	            }
	        },
	        _reorderRules: {
	            value: function _reorderRules() {
	                this.distributionRules = this.distRepoRulesGridData;
	            }
	        },
	        _getRulesActions: {
	            value: function _getRulesActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this._deleteRule(row);
	                    }
	                }];
	            }
	        },
	        _deleteRule: {
	            value: function _deleteRule(row) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you wish to delete this rule?", "Delete Rule", { confirm: "Delete" }).then(function () {
	                    _.remove(_this.distributionRules, row);
	                    _this._createDistributionRulesGrid();
	                });
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    }
	                }];
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;
	
	                // Get All selected rules
	                var selectedRows = this.rulesGridOptions.getSelected();
	
	                // Ask for confirmation before delete and if confirmed then delete bulk of rules
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " rules?").then(function () {
	                    _this.distributionRules = _.filter(_this.distributionRules, function (row) {
	                        return !_.find(selectedRows, { name: row.name });
	                    });
	                    _this._createDistributionRulesGrid();
	                });
	            }
	        },
	        changeDistribute: {
	            value: function changeDistribute() {
	                if (this.distributionType == false) {
	                    this.repoInfo.basic.productName = null;
	                }
	                /*this.modal.confirm("Artifactory has a set of default rules for " + (this.distributionType ? "product" : "packages") + " distribution.<br/>Would you like to set these rules and <strong>override</strong> existing rules?", this.distributionType ? 'Set Product Distribution Rules' : 'Set Packages Distribution Rules', {confirm: 'Override'})
	                    .then(()=> {
	                        if (this.distributionType == false) {
	                            this.distributionRules = this.distributionDefaultRules;
	                        }
	                        else {
	                            this.distributionRules = this.distributionDefaultProductRules;
	                        }
	                        this._createDistributionRulesGrid();
	                    }).catch(() => {
	                    this.distributionType = !this.distributionType;
	                });*/
	            }
	        },
	        changeDistributeVisibility: {
	            value: function changeDistributeVisibility() {
	                this.repoInfo.basic.defaultNewRepoPrivate = this.defaultNewRepoPrivateSwitch == "Private" ? true : false;
	            }
	        },
	        _createDistributionRulesGrid: {
	            value: function _createDistributionRulesGrid() {
	
	                if (!this.distributionRules && !this.newRepository) {
	                    this.distributionRules = this.repoInfo.advanced.distributionRules;
	                }
	
	                _.forEach(this.distributionRules, function (row) {
	                    var rowPackageType = _.find(fieldsValuesDictionary.repoPackageTypes, function (type) {
	                        return type.value == row.type.toLowerCase();
	                    });
	                    if (rowPackageType) {
	                        row.displayType = rowPackageType.text;
	                        row.typeIcon = rowPackageType.icon;
	                    } else row.ignore = true;
	                });
	                var distRepoRulesGridData = _.filter(this.distributionRules, function (row) {
	                    return !row.ignore;
	                });
	                this.distRepoRulesGridData = distRepoRulesGridData;
	                this.rulesGridOptions.setData(this.distRepoRulesGridData);
	            }
	        },
	        onWizardTabSwitch: {
	            value: function onWizardTabSwitch(tab) {
	                if (this.rulesGridOptions && this.rulesGridOptions.update && tab === "Rules") {
	                    this.rulesGridOptions.update();
	                }
	            }
	        },
	        _getDistributionRulesColumns: {
	            value: function _getDistributionRulesColumns() {
	                return [{
	                    name: "Name",
	                    header: "Name",
	                    field: "name",
	                    cellTemplate: "<a class=\"jf-link rule-name\" \n                                    ng-click=\"appScope.RepositoryForm.editDistributionRule(row.entity)\">\n                                    {{row.entity.name}}\n                               </a>",
	                    width: "80%",
	                    sortable: false
	                }, {
	                    name: "Type",
	                    header: "Type",
	                    field: "displayType",
	                    cellTemplate: this.JFrogTableViewOptions.cellTemplateGenerators.iconColumn("row.entity.displayType", "row.entity.typeIcon", "repo-type-icon"),
	                    width: "20%",
	                    sortable: false
	                }];
	            }
	        },
	        rulesPopup: {
	            value: function rulesPopup() {
	                this.rulesModalScope = this.$scope.$new();
	                this.rulesModalScope.title = "Add New Rule";
	                this.rulesModalScope.itemToEdit = null;
	                this.rulesModalScope.rule = {};
	                this.availableTokens = null;
	                this.rulesModalScope.repositoryFilterTooltip = this.repositoryFilterTooltip;
	                this.rulesModalScope.pathFilterToolip = this.pathFilterToolip;
	
	                this.modalRules = this.modal.launchModal("add_rule_modal", this.rulesModalScope, 1000);
	            }
	        },
	        changeRuleRepoType: {
	            value: function changeRuleRepoType() {
	                var selectedPackageType = this.rulesModalScope.rule.selectedPackageType;
	                var selectedPackageServerEnumName = selectedPackageType.serverEnumName;
	                var selectedPackageValue = selectedPackageType.value;
	                if (selectedPackageValue == "generic") {
	                    this.rulesModalScope.rule.RulePackageLayoutSelect = null; // Reset selected layout
	                    this.availableTokens = this.ruleTokensByLayout[selectedPackageServerEnumName];
	                } else if (selectedPackageValue == "nuget" || selectedPackageValue == "debian") {
	                    this.rulesModalScope.rule.distributionCoordinatesPackage = "[packageName]";
	                    this.availableTokens = this.ruleTokensByType[selectedPackageServerEnumName];
	                } else {
	                    this.availableTokens = this.ruleTokensByType[selectedPackageServerEnumName];
	                    if (!this.distributionType) {
	                        this.availableTokens = _.filter(this.availableTokens, function (val) {
	                            return val !== "${productName}";
	                        });
	                    }
	                }
	
	                // Auto fill coordinates from default rules module
	                var coordinates = {};
	                if (selectedPackageValue != "generic") {
	                    coordinates = _.filter(this.distributionDefaultRules, function (o) {
	                        return o.type.toLowerCase() === selectedPackageValue;
	                    });
	                    coordinates = coordinates.length ? coordinates[0].distributionCoordinates : [];
	                }
	                this.rulesModalScope.rule.distributionCoordinatesRepo = coordinates.repo || "";
	                this.rulesModalScope.rule.distributionCoordinatesPackage = coordinates.pkg || "";
	                this.rulesModalScope.rule.distributionCoordinatesVersion = coordinates.version || "";
	                this.rulesModalScope.rule.distributionCoordinatesPath = coordinates.path || "";
	            }
	        },
	        changeRulePackageLayout: {
	            value: function changeRulePackageLayout() {
	                this.availableTokens = this.ruleTokensByLayout[this.rulesModalScope.rule.RulePackageLayoutSelect];
	            }
	        },
	        saveDistributionRule: {
	            value: function saveDistributionRule() {
	                var ruleObject = {
	                    name: this.rulesModalScope.rule.ruleName,
	                    type: this.rulesModalScope.rule.selectedPackageType.text,
	                    repoFilter: this.rulesModalScope.rule.filterRepo || "",
	                    pathFilter: this.rulesModalScope.rule.filterPath || "",
	                    distributionCoordinates: {
	                        repo: this.rulesModalScope.rule.distributionCoordinatesRepo || "",
	                        pkg: this.rulesModalScope.rule.distributionCoordinatesPackage || "",
	                        version: this.rulesModalScope.rule.distributionCoordinatesVersion || "",
	                        path: this.rulesModalScope.rule.distributionCoordinatesPath || ""
	                    }
	                };
	
	                if (this.rulesModalScope.itemToEdit == null) {
	                    this.distributionRules.push(ruleObject);
	                } else {
	                    this.distributionRules[this.rulesModalScope.itemToEdit] = ruleObject;
	                }
	
	                this._createDistributionRulesGrid();
	                this.modalRules.close();
	            }
	        },
	        editDistributionRule: {
	            value: function editDistributionRule(row) {
	                var selectedPackageType = _.find(fieldsValuesDictionary.repoPackageTypes, function (type) {
	                    return type.value == row.type.toLowerCase();
	                });
	                this.availableTokens = this.ruleTokensByType[row.type];
	
	                if (!this.distributionType) {
	                    this.availableTokens = _.filter(this.availableTokens, function (val) {
	                        return val !== "${productName}";
	                    });
	                }
	
	                this.rulesModalScope = this.$scope.$new();
	                this.rulesModalScope.originalRuleName = row.name;
	                this.rulesModalScope.title = "Edit Rule";
	                this.rulesModalScope.itemToEdit = _.indexOf(this.distributionRules, row);
	                this.rulesModalScope.rule = {
	                    ruleName: row.name,
	                    selectedPackageType: selectedPackageType,
	                    filterRepo: row.repoFilter,
	                    filterPath: row.pathFilter,
	                    distributionCoordinatesRepo: row.distributionCoordinates.repo,
	                    distributionCoordinatesPackage: row.distributionCoordinates.pkg,
	                    distributionCoordinatesVersion: row.distributionCoordinates.version,
	                    distributionCoordinatesPath: row.distributionCoordinates.path
	                };
	
	                this.rulesModalScope.repositoryFilterTooltip = this.repositoryFilterTooltip;
	                this.rulesModalScope.pathFilterToolip = this.pathFilterToolip;
	
	                this.modalRules = this.modal.launchModal("add_rule_modal", this.rulesModalScope, 1000);
	            }
	        },
	        testRule: {
	
	            // RULE TEST
	
	            value: function testRule() {
	                this.repositoriesDao.testDistributionRules({
	                    testPath: this.rulesModalScope.rule.testPath,
	                    productName: this.repoInfo.basic.productName || null,
	                    name: this.rulesModalScope.rule.ruleName,
	                    type: this.rulesModalScope.rule.selectedPackageType.text,
	                    repoFilter: this.rulesModalScope.rule.filterRepo || "",
	                    pathFilter: this.rulesModalScope.rule.filterPath || "",
	                    distributionCoordinates: {
	                        repo: this.rulesModalScope.rule.distributionCoordinatesRepo || "",
	                        pkg: this.rulesModalScope.rule.distributionCoordinatesPackage || "",
	                        version: this.rulesModalScope.rule.distributionCoordinatesVersion || "",
	                        path: this.rulesModalScope.rule.distributionCoordinatesPath || ""
	                    }
	                }).$promise.then(function (result) {});
	            }
	        },
	        isProductNameValid: {
	
	            // VALIDATIONS
	
	            value: function isProductNameValid(value) {
	                return !value || value.match(/^[a-zA-Z0-9\-_\.:]+$/);
	            }
	        },
	        checkUniqueRuleName: {
	            value: function checkUniqueRuleName(value) {
	                var found = _.find(this.distributionRules, function (o) {
	                    return o.name == value;
	                });
	                return !found || value == this.rulesModalScope.originalRuleName;
	            }
	        },
	        isEventReplicationDisabled: {
	            value: function isEventReplicationDisabled() {
	                return !this.repoInfo.replication || !this.repoInfo.replication.enabled || !this.lastSmartRemoteURL || this.footerDao.getInfo().versionID !== "ENT" && this.footerDao.getInfo().versionID !== "ENTPLUS" && !this.features.isDedicatedAol() || !this.isSmartRepoSupportFeature("EVENT_BASED_PULL_REPLICATION");
	            }
	        },
	        formatNewPattern: {
	            value: function formatNewPattern(newPattern) {
	                return _.trimStart(newPattern, "/");
	            }
	        }
	    });
	
	    return AdminRepositoryFormController;
	})();

	//            console.log(result);

	//console.log(result)

	//console.log(result);

/***/ }),
/* 214 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var VirtualRepositoryFormController = exports.VirtualRepositoryFormController = (function () {
	    function VirtualRepositoryFormController($scope, RepositoriesDao, parseUrl, JFrogNotifications, ArtifactoryFeatures) {
	        _classCallCheck(this, VirtualRepositoryFormController);
	
	        this.$scope = $scope;
	        this.parseUrl = parseUrl;
	        this.gridP2Option = {};
	        this.repositoriesDao = RepositoriesDao;
	        this.notifications = JFrogNotifications;
	        this.artifactoryGridFactory = $scope.RepositoryForm.artifactoryGridFactory;
	        this.repositoryForm = $scope.RepositoryForm;
	        this.virtualRepo = {};
	        this.features = ArtifactoryFeatures;
	        this._createGrid();
	        this._initVirtual();
	
	        this.repositoryForm.isDependencyRewriteOK = this.isDependencyRewriteOK.bind(this);
	    }
	
	    _createClass(VirtualRepositoryFormController, {
	        isSigningKeysDisable: {
	            value: function isSigningKeysDisable() {
	                if (this.features.isDisabled("signingKeys")) {
	                    return true;
	                } else {
	                    return false;
	                }
	            }
	        },
	        _initVirtual: {
	            value: function _initVirtual() {
	                var _this = this;
	
	                if (!this.repositoryForm.newRepository) {
	                    if (this.repositoryForm.repoInfo.typeSpecific && this.repositoryForm.repoInfo.typeSpecific.p2Repos) {
	                        this.gridP2Option.setGridData(this.repositoryForm.repoInfo.typeSpecific.p2Repos);
	                    }
	                }
	                this.repositoriesDao.remoteUrlToRepoMap().$promise.then(function (result) {
	                    _this.remoteUrlMap = result;
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridP2Option = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getP2Columns()).setRowTemplate("default").setButtons(this._getActions()).setGridData([]);
	            }
	        },
	        addP2Local: {
	            value: function addP2Local() {
	                var repoToPush = {};
	                var baseUrl = "local://";
	                if (this.virtualRepo.pathSuffix) {
	                    repoToPush.pathSuffix = this.virtualRepo.pathSuffix.startsWith("/") ? this.virtualRepo.pathSuffix.replace(/\/+/, "") : this.virtualRepo.pathSuffix;
	                    repoToPush.repoUrl = baseUrl + this.virtualRepo.localRepoKey + "/" + repoToPush.pathSuffix;
	                } else {
	                    repoToPush.repoUrl = baseUrl + this.virtualRepo.localRepoKey;
	                }
	                repoToPush.repoKey = this.virtualRepo.localRepoKey;
	                if (this._repoKeyExists(repoToPush.repoKey)) {
	                    repoToPush.action = "included";
	                } else {
	                    repoToPush.action = "include";
	                }
	                this._pushToGrid(repoToPush);
	            }
	        },
	        _repoKeyExists: {
	            value: function _repoKeyExists(repoKey) {
	                var repos = this.repositoryForm.repoInfo.typeSpecific.p2Repos;
	                if (repos) {
	                    return _.find(repos, { repoKey: repoKey });
	                }
	                return false;
	            }
	        },
	        _repoUrlExists: {
	            value: function _repoUrlExists(repoUrl) {
	                var repos = this.repositoryForm.repoInfo.typeSpecific.p2Repos;
	                if (repos) {
	                    return _.find(repos, { repoUrl: repoUrl });
	                }
	                return false;
	            }
	        },
	        addP2Remote: {
	            value: function addP2Remote() {
	                var _this = this;
	
	                var indexRepo = 1;
	                var findMatch = false;
	                this.currentRepo = "";
	                _.forOwn(this.remoteUrlMap, function (remoteUrl, key) {
	                    if (_this.virtualRepo.remoteUrl.startsWith(remoteUrl)) {
	                        var action = "include";
	                        if (_this._repoKeyExists(key)) {
	                            action = "included";
	                        }
	                        if (_this._pushToGrid({ repoKey: key, repoUrl: _this.virtualRepo.remoteUrl, action: action })) {
	                            findMatch = true;
	                            return false;
	                        } else {
	                            return true;
	                        }
	                    }
	                });
	                if (!findMatch) {
	                    var fields = this.repositoryForm.fields;
	                    var allRepos = fields.availableLocalRepos.concat(fields.availableRemoteRepos).concat(fields.availableVirtualRepos);
	                    var parser = this.parseUrl(this.virtualRepo.remoteUrl);
	
	                    this.currentRepo = parser.host.replace(":", "-");
	
	                    if (_.indexOf(allRepos, this.currentRepo) != -1) {
	                        (function () {
	                            var regexp = new RegExp(_this.currentRepo + "-.+");
	                            var matchingRepos = _.filter(allRepos, function (repo) {
	                                return regexp.test(repo);
	                            });
	                            if (matchingRepos.length) {
	                                var lastMatchingRepo = _.last(matchingRepos.sort());
	                                indexRepo = lastMatchingRepo.substring(lastMatchingRepo.indexOf("-") + 1);
	                                indexRepo = parseInt(indexRepo) + 1;
	                            }
	                            _this.currentRepo = _this.currentRepo + "-" + indexRepo;
	                        })();
	                    }
	
	                    this.remoteUrlMap[this.currentRepo] = this.virtualRepo.remoteUrl;
	                    this._pushToGrid({ repoKey: this.currentRepo, repoUrl: this.virtualRepo.remoteUrl, action: "create" });
	                }
	            }
	        },
	        onChangeRepo: {
	            value: function onChangeRepo() {
	                var _this = this;
	
	                this.repositoriesDao.getResolvedRepositories(this.repositoryForm.repoInfo).$promise.then(function (resolvedRepositories) {
	                    _this.repositoryForm.repoInfo.basic.resolvedRepositories = resolvedRepositories;
	                    _this.repositoryForm.repoInfo.basic.selectedLocalRepositories = _.map(_.filter(_this.repositoryForm.repoInfo.basic.resolvedRepositories, function (repo) {
	                        return repo.type === "local";
	                    }), "repoName");
	                    _this.repositoryForm.repoInfo.basic.selectedRemoteRepositories = _.map(_.filter(_this.repositoryForm.repoInfo.basic.resolvedRepositories, function (repo) {
	                        return repo.type === "remote";
	                    }), "repoName");
	                    if (!_.includes(_this.repositoryForm.repoInfo.basic.selectedLocalRepositories, _this.repositoryForm.repoInfo.basic.defaultDeploymentRepo)) {
	                        _this.repositoryForm.repoInfo.basic.defaultDeploymentRepo = null;
	                    }
	                    _this.repositoryForm.repoInfo.basic.selectedLocalRepositories.unshift("");
	                });
	            }
	        },
	        _pushToGrid: {
	            value: function _pushToGrid(repo) {
	                if (this._repoUrlExists(repo.repoUrl)) {
	                    this.notifications.create({ error: "Repo URL already exists in the list" });
	                    return false;
	                }
	                this.repositoryForm.repoInfo.typeSpecific.p2Repos = this.repositoryForm.repoInfo.typeSpecific.p2Repos || [];
	                this.repositoryForm.repoInfo.typeSpecific.p2Repos.push(repo);
	                this.gridP2Option.setGridData(this.repositoryForm.repoInfo.typeSpecific.p2Repos);
	                this.virtualRepo.remoteUrl = "";
	                return true;
	            }
	        },
	        _deleteRepo: {
	            value: function _deleteRepo(repo) {
	                _.remove(this.repositoryForm.repoInfo.typeSpecific.p2Repos, { repoUrl: repo.repoUrl });
	                this.gridP2Option.setGridData(this.repositoryForm.repoInfo.typeSpecific.p2Repos);
	            }
	        },
	        isDependencyRewriteRelevant: {
	            value: function isDependencyRewriteRelevant() {
	                return this.repositoryForm.repoInfo.typeSpecific && (this.repositoryForm.repoInfo.typeSpecific.repoType === "Bower" || this.repositoryForm.repoInfo.typeSpecific.repoType === "Npm" || this.repositoryForm.repoInfo.typeSpecific.repoType === "Go");
	            }
	        },
	        addDependencyRewritePattern: {
	            value: function addDependencyRewritePattern() {
	                this.newValue = $("#newPatternField").val();
	                this.errorMessage = null;
	
	                if (_.isEmpty(this.newValue)) {
	                    this.errorMessage = "Must input value";
	                }
	                //else if (!this._isValueUnique(this.newValue)) {
	                //    this.errorMessage = "Value already exists";
	                //}
	                else {
	                    this.repositoryForm.repoInfo.typeSpecific.externalPatterns.push(this.newValue);
	                    this.newValue = null;
	                    $("#newPatternField").val("");
	                    //this.invalidateType();
	                }
	            }
	        },
	        removeDependencyRewritePattern: {
	            value: function removeDependencyRewritePattern(index) {
	                this.repositoryForm.repoInfo.typeSpecific.externalPatterns.splice(index, 1);
	            }
	        },
	        onDependencyRewriteEnableChange: {
	            value: function onDependencyRewriteEnableChange() {
	                if (this.repositoryForm.repoInfo.typeSpecific.enableExternalDependencies) {
	                    if (!this.repositoryForm.repoInfo.typeSpecific.externalRemoteRepo && this.repositoryForm.repoInfo.basic.selectedRemoteRepositories) {
	                        this.repositoryForm.repoInfo.typeSpecific.externalRemoteRepo = this.repositoryForm.repoInfo.basic.selectedRemoteRepositories[0];
	                    }
	                    if (!this.repositoryForm.repoInfo.typeSpecific.externalPatterns) {
	                        this.repositoryForm.repoInfo.typeSpecific.externalPatterns = ["**"];
	                    }
	                }
	            }
	        },
	        isDependencyRewriteOK: {
	            value: function isDependencyRewriteOK() {
	                return !this.repositoryForm.repoInfo.typeSpecific.enableExternalDependencies || this.repositoryForm.repoInfo.typeSpecific.externalRemoteRepo || this.repositoryForm.repoInfo.typeSpecific.repoType === "Go";
	            }
	        },
	        getP2Columns: {
	            value: function getP2Columns() {
	                return [{
	                    name: "Action",
	                    displayName: "Action",
	                    field: "action",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.action || \"included\" }}</div>"
	                }, {
	                    name: "Repository",
	                    displayName: "Repository",
	                    field: "repoKey",
	                    enableCellEdit: "{{row.entity.action === 'create'}}"
	
	                }, {
	                    name: "URL",
	                    displayName: "URL",
	                    field: "repoUrl",
	                    enableCellEdit: true
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (repo) {
	                        _this._deleteRepo(repo);
	                    }
	                }];
	            }
	        }
	    });
	
	    return VirtualRepositoryFormController;
	})();

/***/ }),
/* 215 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminRepositoriesLayoutController = exports.AdminRepositoriesLayoutController = (function () {
	    function AdminRepositoriesLayoutController($scope, $state, JFrogGridFactory, RepositoriesLayoutsDao, uiGridConstants, ArtifactoryFeatures, JFrogModal) {
	        _classCallCheck(this, AdminRepositoriesLayoutController);
	
	        this.$scope = $scope;
	        this.$state = $state;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.layoutsDao = RepositoriesLayoutsDao;
	        this.gridOptions = {};
	        this.modal = JFrogModal;
	        this.uiGridConstants = uiGridConstants;
	        this.enableNew = ArtifactoryFeatures.getCurrentLicense() !== "OSS";
	
	        this._createGrid();
	        this._getLayouts();
	    }
	
	    _createClass(AdminRepositoriesLayoutController, {
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setSingleSelect().setButtons(this.getActions()).setRowTemplate("default");
	            }
	        },
	        _getLayouts: {
	            value: function _getLayouts() {
	                var _this = this;
	
	                this.layoutsDao.getLayouts().$promise.then(function (data) {
	                    _this.gridOptions.setGridData(data);
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	
	                    },
	                    name: "Name",
	                    displayName: "Name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"layout-name\" ui-sref=\"^.repo_layouts.edit({layoutname: row.entity.name,viewOnly: !row.entity.layoutActions.edit})\" ><a href=\"\" class=\"jf-link\">{{row.entity.name}}</a></div>",
	                    width: "15%"
	                }, {
	                    field: "artifactPathPattern",
	                    name: "Artifact Path Pattern",
	                    displayName: "Artifact Path Pattern",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"artifact-pattern\">{{row.entity.artifactPathPattern}}</div>",
	                    width: "85%"
	                }];
	            }
	        },
	        copyLayout: {
	            value: function copyLayout(row) {
	                this.$state.go("^.repo_layouts.new", { copyFrom: row.name });
	            }
	        },
	        deleteLayout: {
	            value: function deleteLayout(row) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete layout '" + row.name + "?'").then(function () {
	                    _this.layoutsDao.deleteLayout({}, { layoutName: row.name }).$promise.then(function (data) {
	                        _this._getLayouts();
	                    });
	                });
	            }
	        },
	        getActions: {
	            value: function getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-copy",
	                    tooltip: "Duplicate",
	                    callback: function (row) {
	                        return _this.copyLayout(row);
	                    },
	                    visibleWhen: function (row) {
	                        return row.layoutActions.copy;
	                    }
	                }, {
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteLayout(row);
	                    },
	                    visibleWhen: function (row) {
	                        return row.layoutActions["delete"];
	                    }
	                }];
	            }
	        }
	    });
	
	    return AdminRepositoriesLayoutController;
	})();

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminRepositoryLayoutFormController = exports.AdminRepositoryLayoutFormController = (function () {
	    function AdminRepositoryLayoutFormController($state, $stateParams, RepositoriesLayoutsDao, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminRepositoryLayoutFormController);
	
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.layoutsDao = RepositoriesLayoutsDao;
	        this.TOOLTIP = TOOLTIP.admin.repositories.layoutsForm;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["layoutData"]);
	
	        this.input = {};
	        this.testReply = null;
	        this.regexViewData = null;
	
	        this.testReplyDictionary = {
	            organization: "Organization",
	            module: "Module",
	            baseRevision: "Base Revision",
	            folderIntegrationRevision: "Folder Integration Revision",
	            fileIntegrationRevision: "File Integration Revision",
	            classifier: "Classifier",
	            ext: "Extension",
	            type: "Type"
	        };
	
	        this.viewOnly = $stateParams.viewOnly === true;
	
	        if ($stateParams.layoutname) {
	            this.mode = "edit";
	            this.layoutName = $stateParams.layoutname;
	            this.title = "Edit " + this.layoutName + " Repository Layout";
	            this._getLayoutData(this.layoutName);
	        } else if ($stateParams.copyFrom) {
	            this.mode = "create";
	            this.title = "New Repository Layout";
	            this._getLayoutData($stateParams.copyFrom);
	        } else {
	            this.mode = "create";
	            this.title = "New Repository Layout";
	            this.layoutData = {};
	        }
	    }
	
	    _createClass(AdminRepositoryLayoutFormController, {
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	                if (this.mode == "edit") {
	                    var payload = angular.copy(this.layoutData);
	                    delete payload.repositoryAssociations;
	
	                    this.layoutsDao.update({}, payload).$promise.then(function (data) {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.repo_layouts");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                }
	
	                if (this.mode == "create") {
	                    this.layoutsDao.save({}, this.layoutData).$promise.then(function (data) {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.repo_layouts");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                }
	            }
	        },
	        hasAnyAssoc: {
	            value: function hasAnyAssoc() {
	                return this.layoutData && (this.layoutData.repositoryAssociations.localRepositories.length || this.layoutData.repositoryAssociations.remoteRepositories.length || this.layoutData.repositoryAssociations.virtualRepositories.length);
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.repo_layouts");
	            }
	        },
	        test: {
	            value: function test() {
	                var _this = this;
	
	                var payload = angular.copy(this.layoutData);
	                delete payload.repositoryAssociations;
	                _.extend(payload, { pathToTest: this.input.testPath });
	                this.testReply = null;
	
	                this.layoutsDao.testArtifactPath({}, payload).$promise.then(function (data) {
	                    _this.testReply = data.data;
	                });
	            }
	        },
	        isSaveDisabled: {
	            value: function isSaveDisabled() {
	                return this.savePending || !this.layoutForm || this.layoutForm.$invalid;
	            }
	        },
	        resolveRegex: {
	            value: function resolveRegex() {
	                var _this = this;
	
	                var payload = angular.copy(this.layoutData);
	                delete payload.repositoryAssociations;
	                this.regexViewData = null;
	                this.layoutsDao.resolveRegex({}, payload).$promise.then(function (data) {
	                    _this.regexViewData = data;
	                });
	            }
	        },
	        gotoEditRepo: {
	            value: function gotoEditRepo(type, repo) {
	                this.$state.go("admin.repositories.list.edit", { repoType: type, repoKey: repo });
	            }
	        },
	        _getLayoutData: {
	            value: function _getLayoutData(layoutName) {
	                var _this = this;
	
	                this.layoutsDao.getLayoutData({}, { layoutName: layoutName }).$promise.then(function (data) {
	                    _this.layoutData = data;
	                    _this.ArtifactoryModelSaver.save();
	                    if (_this.$stateParams.copyFrom) {
	                        _this.layoutData.name = "";
	                    }
	                });
	            }
	        }
	    });
	
	    return AdminRepositoryLayoutFormController;
	})();

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var ConfigDescriptor = _interopRequire(__webpack_require__(218));
	
	var Maintenance = _interopRequire(__webpack_require__(220));
	
	var SecurityDescriptor = _interopRequire(__webpack_require__(222));
	
	var StorageSummary = _interopRequire(__webpack_require__(224));
	
	var SystemInfo = _interopRequire(__webpack_require__(226));
	
	var SystemLogs = _interopRequire(__webpack_require__(228));
	
	var SupportPage = _interopRequire(__webpack_require__(230));
	
	var LogAnalytics = _interopRequire(__webpack_require__(232));
	
	var AdminAdvancedController = __webpack_require__(234).AdminAdvancedController;
	
	function advancedConfig($stateProvider) {
	    $stateProvider.state("admin.advanced", {
	        url: "/advanced",
	        template: "<ui-view></ui-view>",
	        controller: "AdminAdvancedController as AdminAdvanced"
	    });
	}
	
	module.exports = angular.module("admin.advanced", [ConfigDescriptor.name, Maintenance.name, SecurityDescriptor.name, StorageSummary.name, SystemInfo.name, SystemLogs.name, SupportPage.name, LogAnalytics.name]).config(advancedConfig).controller("AdminAdvancedController", AdminAdvancedController);

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminAdvancedConfigDescriptorController = __webpack_require__(219).AdminAdvancedConfigDescriptorController;
	
	function configDescriptorConfig($stateProvider) {
	
	    $stateProvider.state("admin.advanced.config_descriptor", {
	        params: { feature: "configDescriptor" },
	        url: "/config_descriptor",
	        templateUrl: "states/admin/advanced/config_descriptor/config_descriptor.html",
	        controller: "AdminAdvancedConfigDescriptorController as ConfigDescriptorController"
	    });
	}
	
	module.exports = angular.module("advanced.config_descriptor", []).config(configDescriptorConfig).controller("AdminAdvancedConfigDescriptorController", AdminAdvancedConfigDescriptorController);

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var AdminAdvancedConfigDescriptorController = exports.AdminAdvancedConfigDescriptorController = (function () {
	    function AdminAdvancedConfigDescriptorController($scope, $timeout, ArtifactoryHttpClient, JFrogNotifications, RESOURCE, ArtifactoryModelSaver, JFrogEventBus) {
	        var _this = this;
	
	        _classCallCheck(this, AdminAdvancedConfigDescriptorController);
	
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.RESOURCE = RESOURCE;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.artifactoryHttpClient = ArtifactoryHttpClient;
	        this.configDescriptor = "";
	        this.apiAccess = {};
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["configDescriptor"]);
	        this.JFrogEventBus = JFrogEventBus;
	
	        this._getData();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this._getData();
	        });
	    }
	
	    _createClass(AdminAdvancedConfigDescriptorController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;
	
	                this.artifactoryHttpClient.get(this.RESOURCE.CONFIG_DESCRIPTOR).then(function (response) {
	                    _this.configDescriptor = response.data;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$timeout(function () {
	                        _this.apiAccess.api.clearHistory();
	                    });
	                });
	            }
	        },
	        save: {
	            value: function save(configXml) {
	                var _this = this;
	
	                this.artifactoryHttpClient.put(this.RESOURCE.CONFIG_DESCRIPTOR, { configXml: configXml }).then(function (response) {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.artifactoryNotifications.create(response.data);
	                })["catch"](function (response) {
	                    if (response.data.errors && response.data.errors.length) {
	                        _this.artifactoryNotifications.create(angular.fromJson(response.data.errors[0].message));
	                    }
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this._getData();
	                });
	            }
	        }
	    });
	
	    return AdminAdvancedConfigDescriptorController;
	})();

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminAdvancedMaintenanceController = __webpack_require__(221).AdminAdvancedMaintenanceController;
	
	function maintenanceConfig($stateProvider) {
	
	    $stateProvider.state("admin.advanced.maintenance", {
	        params: { feature: "maintenance" },
	        url: "/maintenance",
	        templateUrl: "states/admin/advanced/maintenance/maintenance.html",
	        controller: "AdminAdvancedMaintenanceController as Maintenance"
	    });
	}
	
	module.exports = angular.module("advanced.maintenance", []).config(maintenanceConfig).controller("AdminAdvancedMaintenanceController", AdminAdvancedMaintenanceController);

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminAdvancedMaintenanceController = exports.AdminAdvancedMaintenanceController = (function () {
	    function AdminAdvancedMaintenanceController(MaintenanceDao, JFrogNotifications, JFrogEventBus, JFrogModal, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminAdvancedMaintenanceController);
	
	        this.maintenanceDao = MaintenanceDao;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryModal = JFrogModal;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["maintenanceSettings"]);
	        this.maintenanceSettings = {};
	        this.TOOLTIP = TOOLTIP.admin.advanced.maintenance;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	
	        this._getData();
	    }
	
	    _createClass(AdminAdvancedMaintenanceController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;
	
	                this.maintenanceDao.get().$promise.then(function (data) {
	                    _this.backupMaintance = angular.copy(data);
	                    _this.maintenanceSettings.cleanUnusedCachedCron = data.cleanUnusedCachedCron;
	                    _this.maintenanceSettings.cleanVirtualRepoCron = data.cleanVirtualRepoCron;
	                    _this.maintenanceSettings.garbageCollectorCron = data.garbageCollectorCron;
	                    _this.maintenanceSettings.quotaControl = data.quotaControl;
	                    _this.maintenanceSettings.storageLimit = data.storageLimit;
	                    _this.maintenanceSettings.storageWarning = data.storageWarning;
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.maintenanceForm.$valid) {
	                    this.maintenanceDao.update(this.maintenanceSettings).$promise.then(function () {
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        clear: {
	            value: function clear() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	                    _this._getData();
	                });
	            }
	        },
	        resetQuotaFields: {
	            value: function resetQuotaFields() {
	                if (!this.maintenanceSettings.quotaControl) {
	                    this.maintenanceSettings.storageLimit = this.backupMaintance.storageLimit;
	                    this.maintenanceSettings.storageWarning = this.backupMaintance.storageWarning;
	                }
	            }
	        },
	        _runAction: {
	            value: function _runAction(name) {
	                this.maintenanceDao.perform({ module: name });
	            }
	        },
	        runGarbageCollection: {
	            value: function runGarbageCollection() {
	                this._runAction("garbageCollection");
	            }
	        },
	        runUnusedCachedArtifactsCleanup: {
	            value: function runUnusedCachedArtifactsCleanup() {
	                this._runAction("cleanUnusedCache");
	            }
	        },
	        compressInternalDatabase: {
	            value: function compressInternalDatabase() {
	                var _this = this;
	
	                this.artifactoryModal.confirm("Are you sure you want to compress the internal database?").then(function () {
	                    return _this._runAction("compress");
	                });
	            }
	        },
	        pruneUnreferencedData: {
	            value: function pruneUnreferencedData() {
	                this._runAction("prune");
	            }
	        },
	        cleanVirtualRepositories: {
	            value: function cleanVirtualRepositories() {
	                this._runAction("cleanVirtualRepo");
	            }
	        }
	    });
	
	    return AdminAdvancedMaintenanceController;
	})();

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminAdvancedSecurityDescriptorController = __webpack_require__(223).AdminAdvancedSecurityDescriptorController;
	
	function securityDescriptorConfig($stateProvider) {
	
	    $stateProvider.state("admin.advanced.security_descriptor", {
	        params: { feature: "securityDescriptor" },
	        url: "/security_descriptor",
	        templateUrl: "states/admin/advanced/security_descriptor/security_descriptor.html",
	        controller: "AdminAdvancedSecurityDescriptorController as SecurityDescriptorController"
	    });
	}
	
	module.exports = angular.module("advanced.security_descriptor", []).config(securityDescriptorConfig).controller("AdminAdvancedSecurityDescriptorController", AdminAdvancedSecurityDescriptorController);

/***/ }),
/* 223 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminAdvancedSecurityDescriptorController = exports.AdminAdvancedSecurityDescriptorController = (function () {
	    function AdminAdvancedSecurityDescriptorController($timeout, ArtifactoryHttpClient, JFrogNotifications, RESOURCE, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminAdvancedSecurityDescriptorController);
	
	        this.artifactoryHttpClient = ArtifactoryHttpClient;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.RESOURCE = RESOURCE;
	        this.$timeout = $timeout;
	        this.securityDescriptor = "";
	        this.apiAccess = {};
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["securityDescriptor"]);
	
	        this._getData();
	    }
	
	    _createClass(AdminAdvancedSecurityDescriptorController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;
	
	                this.artifactoryHttpClient.get(this.RESOURCE.SECURITY_DESCRIPTOR).then(function (response) {
	                    _this.securityDescriptor = response.data;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$timeout(function () {
	                        _this.apiAccess.api.clearHistory();
	                    });
	                });
	            }
	        },
	        save: {
	            value: function save(securityXML) {
	                var _this = this;
	
	                this.artifactoryHttpClient.put(this.RESOURCE.SECURITY_DESCRIPTOR, { securityXML: securityXML }).success(function (response) {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.artifactoryNotifications.create(response);
	                }).error(function (response) {
	                    if (response.errors && response.errors.length) {
	                        _this.artifactoryNotifications.create(angular.fromJson(response.errors[0].message));
	                    }
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this._getData();
	                });
	            }
	        }
	    });
	
	    return AdminAdvancedSecurityDescriptorController;
	})();

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminAdvancedStorageSummaryController = __webpack_require__(225).AdminAdvancedStorageSummaryController;
	
	function storageSummaryConfig($stateProvider) {
	
	    $stateProvider.state("admin.advanced.storage_summary", {
	        url: "/storage_summary",
	        templateUrl: "states/admin/advanced/storage_summary/storage_summary.html",
	        controller: "AdminAdvancedStorageSummaryController as StorageSummaryController"
	    });
	}
	
	module.exports = angular.module("advanced.storage_summary", []).config(storageSummaryConfig).controller("AdminAdvancedStorageSummaryController", AdminAdvancedStorageSummaryController);

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var FIELD_OPTIONS = _interopRequire(__webpack_require__(135));
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var AdminAdvancedStorageSummaryController = exports.AdminAdvancedStorageSummaryController = (function () {
	    function AdminAdvancedStorageSummaryController($scope, $timeout, JFrogGridFactory, uiGridConstants, commonGridColumns, $compile, ArtifactoryFeatures, JFrogEventBus, StorageSummaryCachedDao, $interval) {
	        var _this = this;
	
	        _classCallCheck(this, AdminAdvancedStorageSummaryController);
	
	        this.$scope = $scope;
	        this.$compile = $compile;
	        this.$timeout = $timeout;
	        this.commonGridColumns = commonGridColumns;
	        this.storageSummary = {};
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.storageSummaryCachedDao = StorageSummaryCachedDao;
	        this.features = ArtifactoryFeatures;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.TOOLTIP = TOOLTIP.admin.advanced.storageSummary;
	        this.counterTooltip = "List includes all Local and Virtual repositories, and Remote repositories configured to store artifacts locally.";
	        this.binariesKeys = ["binariesSize", "binariesCount", "artifactsSize", "artifactsCount", "optimization", "itemsCount"];
	        this.JFrogEventBus = JFrogEventBus;
	
	        this.getGridPopulatedWithData();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.getGridPopulatedWithData();
	        });
	        this.disableRefresh = true;
	        this.$interval = $interval;
	        this.fetchStatus();
	        this.intervalPromise = this.$interval(this.fetchStatus.bind(this), 5000);
	        this.$scope.$on("$destroy", function () {
	            _this.$interval.cancel(_this.intervalPromise);
	        });
	    }
	
	    _createClass(AdminAdvancedStorageSummaryController, {
	        getGridPopulatedWithData: {
	            value: function getGridPopulatedWithData() {
	                var _this = this;
	
	                this.storageSummaryCachedDao.getStorageInfo().$promise.then(function (result) {
	                    _this.storageSummary = result;
	                    _this.binariesSummary = result.binariesSummary;
	                    // Creates a repository array by running each repo element in the list through the arrow function
	                    _this.storageSummary.repositoriesSummaryList = _.map(_this.storageSummary.repositoriesSummaryList, function (row) {
	                        return _this.setRowTemplate(row);
	                    });
	
	                    _this.getStorageTableSummaryData();
	
	                    // If grid does not exists - create it , else refresh the grid data
	                    if (!_this.gridOption.data) {
	                        _this.createGrid();
	                    } else {
	                        _this.gridOption.setGridData(_this.storageSummary.repositoriesSummaryList);
	                    }
	                });
	            }
	        },
	        refresh: {
	            value: function refresh() {
	                this.storageSummaryCachedDao.refreshStorageSummary();
	                this.disableRefresh = true;
	                this.calculating = true;
	            }
	        },
	        fetchStatus: {
	            value: function fetchStatus() {
	                var _this = this;
	
	                if (!this.fetchingStatus) {
	                    this.fetchingStatus = true;
	                    this.storageSummaryCachedDao.fetchStatus().$promise.then(function (result) {
	                        _this.disableRefresh = result.calculating;
	                        if (_this.calculating && !result.calculating) {
	                            _this.getGridPopulatedWithData();
	                        }
	                        _this.calculating = result.calculating;
	                        _this.fetchingStatus = false;
	                    });
	                }
	            }
	        },
	        setRowTemplate: {
	            value: function setRowTemplate(row) {
	
	                row = this.getStorageTableSummaryTamplate(row);
	
	                row = this.getDataColumns(row);
	
	                row = this.getPackageTypeColumn(row);
	
	                return row;
	            }
	        },
	        getDataColumns: {
	            value: function getDataColumns(row) {
	                var _this = this;
	
	                var repoKey = row.repoKey;
	                for (var key in row) {
	                    if (key !== "__doNotCount__" && key !== "percentageDisplay") {
	                        row[key] = { value: row[key], repoKey: repoKey, getCtrl: function () {
	                                return _this;
	                            } };
	                    }
	                }
	                return row;
	            }
	        },
	        getPackageTypeColumn: {
	            value: function getPackageTypeColumn(row) {
	                var rowPackageType = _.find(FIELD_OPTIONS.repoPackageTypes, function (type) {
	                    return type.serverEnumName == row.packageType.value || type.serverEnumName == "YUM" && row.packageType.value == "RPM";
	                    // The REST for storage has changed and now returns RPM, while other RESTs returns YUM
	                });
	
	                if (rowPackageType) {
	                    row.typeIcon = rowPackageType.icon;
	                    // set the correct package name (from FIELD_OPTIONS constants)
	                    row.packageType.value = rowPackageType.text;
	                }
	
	                if (row.packageType.value === "Trash") {
	                    row.typeIcon = "trash";
	                }
	
	                if (row.packageType.value === "Support Bundle") {
	                    row.typeIcon = "support";
	                }
	
	                if (row.packageType.value === "Distribution") {
	                    row.typeIcon = "distribution-repo";
	                }
	
	                return row;
	            }
	        },
	        getStorageTableSummaryTamplate: {
	            value: function getStorageTableSummaryTamplate(row, repoKey) {
	                if (repoKey === "TOTAL") {
	                    row.percentage = 100;
	                    row.percentageDisplay = "100%";
	                } else {
	                    row.percentage = !_.isNaN(parseFloat(row.percentage)) ? parseFloat(row.percentage) : row.percentage;
	                    row.percentageDisplay = _.isNumber(row.percentage) ? row.percentage + "%" : "N/A";
	                }
	
	                if (row.repoType === "NA") row.repoType = "N/A";
	                if (row.packageType === "NA") row.packageType = "N/A";
	
	                if (row.repoKey === "TOTAL" || row.repoKey === "auto-trashcan" || row.repoKey === "jfrog-support-bundle") {
	                    row.__doNotCount__ = true;
	                    row.packageType = "N/A";
	                    row._specialRow = true;
	                }
	
	                if (row.repoKey === "auto-trashcan") {
	                    row.trashcan = true;
	                    row.packageType = "Trash";
	                    row.repoKey = "Trash Can";
	                }
	
	                if (row.repoKey === "jfrog-support-bundle") {
	                    row.packageType = "Support Bundle";
	                    row.repoKey = "Support Bundle";
	                }
	
	                return row;
	            }
	        },
	        getStorageTableSummaryData: {
	            value: function getStorageTableSummaryData() {
	                //This is for assuring that even without sorting, total will always be first and trash will be second
	                var total = _.find(this.storageSummary.repositoriesSummaryList, { repoKey: { value: "TOTAL" } });
	                var trash = _.find(this.storageSummary.repositoriesSummaryList, { repoKey: { value: "Trash Can" } });
	                var supportBundle = _.find(this.storageSummary.repositoriesSummaryList, { repoKey: { value: "Support Bundle" } });
	
	                if (supportBundle) {
	                    var supportBundleIndex = this.storageSummary.repositoriesSummaryList.indexOf(supportBundle);
	                    this.storageSummary.repositoriesSummaryList.splice(supportBundleIndex, 1);
	                    this.storageSummary.repositoriesSummaryList.unshift(supportBundle);
	                }
	
	                var totalIndex = this.storageSummary.repositoriesSummaryList.indexOf(total);
	                this.storageSummary.repositoriesSummaryList.splice(totalIndex, 1);
	
	                var trashIndex = this.storageSummary.repositoriesSummaryList.indexOf(trash);
	                this.storageSummary.repositoriesSummaryList.splice(trashIndex, 1);
	
	                this.storageSummary.repositoriesSummaryList.unshift(trash);
	                this.storageSummary.repositoriesSummaryList.unshift(total);
	
	                if (this.storageSummary.fileStoreSummary && this.storageSummary.fileStoreSummary.storageDirectory.indexOf(", ") != -1) {
	                    this.storageSummary.fileStoreSummary.storageDirectory = "<div class=\"storage-multiple-mounts\">" + this.storageSummary.fileStoreSummary.storageDirectory.replace(/, /g, "<br>") + "</div>";
	                    this.storageSummary.fileStoreSummary.storageType = "Advanced Configuration";
	                }
	            }
	        },
	        createGrid: {
	            value: function createGrid() {
	                var _this = this;
	
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setGridData(this.storageSummary.repositoriesSummaryList).setRowTemplate("default");
	
	                this.gridOption.afterRegister(function (gridApi) {
	                    gridApi.pagination.on.paginationChanged(_this.$scope, function (pageNumber, pageSize) {
	                        var specialsToRemove = $(".ui-grid-row.special-row");
	                        specialsToRemove.removeClass("special-row");
	                        _this.$timeout(function () {
	                            var specials = $(".special-row");
	                            specials.parent().parent().addClass("special-row");
	                            specials.removeClass("special-row");
	                        }, 100);
	                    });
	                });
	
	                this.$timeout(function () {
	                    var counterElem = $(".grid-counter");
	                    var tooltipElem = $("<jf-help-tooltip html=\"StorageSummaryController.counterTooltip\"></jf-help-tooltip>");
	                    counterElem.append(tooltipElem);
	                    _this.$compile(tooltipElem)(_this.$scope);
	
	                    var specials = $(".special-row");
	                    specials.parent().parent().addClass("special-row");
	                    specials.removeClass("special-row");
	                });
	            }
	        },
	        sortGeneral: {
	            value: function sortGeneral(a, b, column) {
	                var dir = "asc";
	                var ctrl = a.getCtrl();
	                if (column) {
	                    dir = _.find(ctrl.gridOption.api.grid.columns, { field: column }).sort.direction;
	                }
	                if (a.repoKey === "TOTAL") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "TOTAL") {
	                    return dir === "desc" ? -1 : 1;
	                } else if (a.repoKey === "Trash Can") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "Trash Can") {
	                    return dir === "desc" ? -1 : 1;
	                } else if (a.repoKey === "Support Bundle") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "Support Bundle") {
	                    return dir === "desc" ? -1 : 1;
	                } else {
	                    return a.value > b.value ? 1 : a.value < b.value ? -1 : 0;
	                }
	            }
	        },
	        sortByteSizes: {
	            value: function sortByteSizes(a, b, column) {
	                var dir = "asc";
	                var ctrl = a.getCtrl();
	
	                if (column) {
	                    dir = _.find(ctrl.gridOption.api.grid.columns, { field: column }).sort.direction;
	                }
	
	                var res = 0;
	                if (a === undefined || b === undefined) {
	                    return res;
	                }if (a.repoKey === "TOTAL") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "TOTAL") {
	                    return dir === "desc" ? -1 : 1;
	                } else if (a.repoKey === "Trash Can") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "Trash Can") {
	                    return dir === "desc" ? -1 : 1;
	                } else if (a.repoKey === "Support Bundle") {
	                    return dir === "desc" ? 1 : -1;
	                } else if (b.repoKey === "Support Bundle") {
	                    return dir === "desc" ? -1 : 1;
	                } else {
	                    var tb = [a.value.match("TB"), b.value.match("TB")],
	                        gb = [a.value.match("GB"), b.value.match("GB")],
	                        mb = [a.value.match("MB"), b.value.match("MB")],
	                        kb = [a.value.match("KB"), b.value.match("KB")];
	
	                    res = tb[0] && !tb[1] ? 1 : tb[1] && !tb[0] ? -1 : gb[0] && !gb[1] ? 1 : gb[1] && !gb[0] ? -1 : mb[0] && !mb[1] ? 1 : mb[1] && !mb[0] ? -1 : kb[0] && !kb[1] ? 1 : kb[1] && !kb[0] ? -1 : parseFloat(a.value.match(/[+-]?\d+(\.\d+)?/)[0]) > parseFloat(b.value.match(/[+-]?\d+(\.\d+)?/)[0]) ? 1 : -1;
	                }
	
	                return res;
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                var _this = this;
	
	                return [{
	                    field: "repoKey",
	                    name: "Repository Key",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "repoKey");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"repoKey\">{{row.entity.repoKey.value}}</div>",
	                    displayName: "Repository Key"
	                }, {
	                    field: "repoType",
	                    name: "Repository Type",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "repoType");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"repoType\">{{row.entity.repoType.value}}</div>",
	                    displayName: "Repository Type"
	                }, {
	                    field: "packageType",
	                    name: "Package Type",
	                    displayName: "Package Type",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "packageType");
	                    },
	                    cellTemplate: this.commonGridColumns.iconColumn("row.entity.packageType.value", "row.entity.typeIcon", "repo-type-icon")
	                }, {
	                    field: "percentage",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\" id=\"storage-precentage\" >{{row.entity.percentageDisplay}}</div>",
	                    name: "Percentage",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "percentage");
	                    },
	                    displayName: "Percentage"
	                }, {
	                    field: "usedSpace",
	                    name: "Used Space",
	                    displayName: "Artifacts Size",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\" id=\"used-space\" >{{row.entity.usedSpace.value}}</div>",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortByteSizes(a, b, "usedSpace");
	                    },
	                    sort: {
	                        direction: this.uiGridConstants.DESC
	                    }
	                }, {
	                    field: "filesCount",
	                    name: "Files",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "filesCount");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"files\" >  {{row.entity.filesCount.value}}</div>",
	                    displayName: "Files"
	                }, {
	                    field: "foldersCount",
	                    name: "Folders",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "foldersCount");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"folders\" >{{row.entity.foldersCount.value}}</div>",
	                    displayName: "Folders"
	                }, {
	                    field: "itemsCount",
	                    name: "Items",
	                    sortingAlgorithm: function (a, b) {
	                        return _this.sortGeneral(a, b, "itemsCount");
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"items\" >{{row.entity.itemsCount.value}}</div>",
	                    displayName: "Items"
	                }];
	            }
	        }
	    });
	
	    return AdminAdvancedStorageSummaryController;
	})();

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminAdvancedSystemInfoController = __webpack_require__(227).AdminAdvancedSystemInfoController;
	
	function systemInfoConfig($stateProvider) {
	    $stateProvider.state("admin.advanced.system_info", {
	        params: { feature: "systemInfo" },
	        url: "/system_info",
	        templateUrl: "states/admin/advanced/system_info/system_info.html",
	        controller: "AdminAdvancedSystemInfoController as SystemInfoController"
	    });
	}
	
	module.exports = angular.module("advanced.system_info", []).config(systemInfoConfig).controller("AdminAdvancedSystemInfoController", AdminAdvancedSystemInfoController);

/***/ }),
/* 227 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminAdvancedSystemInfoController = exports.AdminAdvancedSystemInfoController = (function () {
	    function AdminAdvancedSystemInfoController(SystemInfoDao) {
	        _classCallCheck(this, AdminAdvancedSystemInfoController);
	
	        // console.log("log: "+SystemInfoDao);
	        this.systemInfoDao = SystemInfoDao.getInstance();
	        var self = this;
	        this.systemInfo;
	        this.systemInfoJoined;
	        this.systemInfoDao.get().$promise.then(function (data) {
	            self.getSystemInfoKeys(data);
	        });
	    }
	
	    _createClass(AdminAdvancedSystemInfoController, {
	        getSystemInfoKeys: {
	            value: function getSystemInfoKeys(data) {
	                this.systemInfo = data.systemInfo;
	                this.systemInfoJoined = JSON.stringify(data.systemInfo);
	                //let headers = Object.keys(systemInfo);
	                //let subTitles = [];
	            }
	        },
	        replaceNewLines: {
	            value: function replaceNewLines(text) {
	                return text.replace(/\n/g, "<br>");
	            }
	        }
	    });
	
	    return AdminAdvancedSystemInfoController;
	})();

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminAdvancedSystemLogsController = __webpack_require__(229).AdminAdvancedSystemLogsController;
	
	function systemLogsConifg($stateProvider) {
	
	    $stateProvider.state("admin.advanced.system_logs", {
	        url: "/system_logs",
	        templateUrl: "states/admin/advanced/system_logs/system_logs.html",
	        controller: "AdminAdvancedSystemLogsController as SystemLogsController"
	    });
	}
	
	module.exports = angular.module("advanced.system_logs", []).config(systemLogsConifg).controller("AdminAdvancedSystemLogsController", AdminAdvancedSystemLogsController);

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var API = _interopRequire(__webpack_require__(98));
	
	var AdminAdvancedSystemLogsController = exports.AdminAdvancedSystemLogsController = (function () {
	    function AdminAdvancedSystemLogsController($scope, SystemLogsDao, $interval, $window, $timeout) {
	        var _this = this;
	
	        _classCallCheck(this, AdminAdvancedSystemLogsController);
	
	        this.logsDao = SystemLogsDao;
	        this.$interval = $interval;
	        this.$window = $window;
	        this.$timeout = $timeout;
	
	        this.intervalPromise = null;
	        this.timeoutSpinner = null;
	        this.timeCount = 5;
	
	        this._getInitialData();
	
	        $scope.$on("$destroy", function () {
	            _this.stopTimeout();
	            _this.stopInterval();
	        });
	    }
	
	    _createClass(AdminAdvancedSystemLogsController, {
	        _getInitialData: {
	            value: function _getInitialData() {
	                var _this = this;
	
	                this.logsDao.getLogs().$promise.then(function (data) {
	                    _this.refreshRateSecs = data.refreshRateSecs;
	                    _this.logs = _.map(data.logs, function (logName) {
	                        return { logName: logName };
	                    });
	                    _this.selectedLog = _this.logs[0].logName;
	                    _this.data = { fileSize: 0 };
	                    _this._getLogData();
	                });
	            }
	        },
	        _getLogData: {
	            value: function _getLogData() {
	                var _this = this;
	
	                this.stopInterval();
	
	                this.logsDao.getLogData({ id: this.selectedLog, fileSize: this.data.fileSize, $no_spinner: true }).$promise.then(function (data) {
	                    _this.stopTimeout();
	
	                    if (_this.data.fileSize === 0) {
	                        _this.$timeout(function () {
	                            var textarea = document.getElementById("textarea");
	                            textarea.scrollTop = textarea.scrollHeight;
	                        });
	                    }
	
	                    if (data.fileSize) _this.data = data;
	
	                    _this.timeCount = _this.refreshRateSecs;
	                    if (!_this.intervalPromise && !_this.paused) _this.startInterval();
	                });
	
	                this.timeoutSpinner = this.$timeout(function () {
	                    _this.timeCount--;
	                }, 400);
	            }
	        },
	        download: {
	            value: function download() {
	                this.$window.open("" + API.API_URL + "/systemlogs/downloadFile?id=" + this.selectedLog, "_blank");
	            }
	        },
	        onChangeLog: {
	            value: function onChangeLog() {
	                this.stopInterval();
	                this.data = { fileSize: 0 };
	                this._getLogData();
	            }
	        },
	        startInterval: {
	            value: function startInterval() {
	                var _this = this;
	
	                this.intervalPromise = this.$interval(function () {
	                    if (_this.timeCount == 0) _this._getLogData();else _this.timeCount--;
	                }, 1000);
	            }
	        },
	        stopInterval: {
	            value: function stopInterval() {
	                if (this.intervalPromise) {
	                    this.$interval.cancel(this.intervalPromise);
	                    this.intervalPromise = null;
	                }
	            }
	        },
	        stopTimeout: {
	            value: function stopTimeout() {
	                if (this.timeoutSpinner) {
	                    this.$timeout.cancel(this.timeoutSpinner);
	                    this.timeoutSpinner = null;
	                }
	            }
	        },
	        togglePause: {
	            value: function togglePause() {
	                this.paused = !this.paused;
	                if (this.paused) {
	                    this.stopInterval();
	                    this.stopTimeout();
	                } else {
	                    this.startInterval();
	                }
	            }
	        },
	        getPauseLinkText: {
	            value: function getPauseLinkText() {
	                return this.paused ? "Resume" : "Pause";
	            }
	        }
	    });
	
	    return AdminAdvancedSystemLogsController;
	})();

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminAdvancedSupportPageController = __webpack_require__(231).AdminAdvancedSupportPageController;
	
	function supportPageConfig($stateProvider) {
	    $stateProvider.state("admin.advanced.support_page", {
	        params: { feature: "supportPage" },
	        url: "/support_page",
	        templateUrl: "states/admin/advanced/support_page/support_page.html",
	        controller: "AdminAdvancedSupportPageController as SupportPage"
	    });
	}
	
	module.exports = angular.module("advanced.support_page", []).config(supportPageConfig).controller("AdminAdvancedSupportPageController", AdminAdvancedSupportPageController);

/***/ }),
/* 231 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 */
	
	var AdminAdvancedSupportPageController = exports.AdminAdvancedSupportPageController = (function () {
		function AdminAdvancedSupportPageController(SupportPageDao, ServerTimeDao, JFrogTableViewOptions, $rootScope, $scope, JFrogIFrameDownload, GeneralConfigDao, RESOURCE, JFrogNotifications, JFrogModal) {
			var _this = this;
	
			_classCallCheck(this, AdminAdvancedSupportPageController);
	
			this.$scope = $scope;
			this.$rootScope = $rootScope;
			this.supportPageDao = SupportPageDao;
			this.JFrogTableViewOptions = JFrogTableViewOptions;
			this.GeneralConfigDao = GeneralConfigDao;
	
			this.modal = JFrogModal;
			this.serverTimeDao = ServerTimeDao;
			this.iFrameDownload = JFrogIFrameDownload;
			this.RESOURCE = RESOURCE;
	
			this.artifactoryNotifications = JFrogNotifications;
	
			this.GeneralConfigDao.get().$promise.then(function (data) {
				_this.dateFormat = _this._getDatePartFromFormat(data.dateFormat);
				_this._init();
			});
		}
	
		_createClass(AdminAdvancedSupportPageController, {
			_init: {
				value: function _init() {
					var _this = this;
	
					this.timePeriodConfig = {
						maxItems: 1,
						create: false
					};
	
					this.timePeriodOptions = [{ text: "Last 24 Hours", value: 1 }, { text: "Last 3 Days", value: 3 }, { text: "Last 5 Days", value: 5 }, { text: "Last 7 Days", value: 7 }];
	
					this.timePeriodSelection = 1;
	
					this.supportPageDao.listBundles().$promise.then(function (data) {
						_this.bundles = _this.formatStatus(data);
						_this.setupBundlesTable();
					});
	
					this.serverTimeDao.get().$promise.then(function (serverTimeResource) {
						var serverTime = parseInt(_.map(serverTimeResource.toJSON()).join(""));
	
						// get today date (based on -server time-)
						_this.today = moment(serverTime).format();
					});
	
					var basicDatePickerOptions = { format: this._getDatePartFromFormat(this.dateFormat), maxDate: this.today, toolbarPlacement: "bottom" };
					this.toDateOptions = this.fromDateOptions = basicDatePickerOptions;
				}
			},
			setupBundlesTable: {
				value: function setupBundlesTable() {
					var _this = this;
	
					this.bundlesTableOptions = new this.JFrogTableViewOptions(this.$scope);
					this.bundlesTableOptions.setId("bundles-list").setObjectName("Bundle").setEmptyTableText("No Support Bundles have been created.").sortBy("create_date").reverseSortingDir().setColumns(this.getBundlesListColumns()).setActions(this.getRowActions()).setNewEntityAction(function () {
						_this.openNewBundleModal();
					});
	
					this.bundlesTableOptions.newEntityCustomText = "Create New Bundle";
					this.bundlesTableOptions.setData(this.bundles);
				}
			},
			getRowActions: {
				value: function getRowActions() {
					var _this = this;
	
					return [{
						name: "Download",
						icon: "icon icon-download",
						callback: function (row) {
							return _this.downloadBundle(row.id);
						},
						tooltip: "Download"
					}, {
						name: "Delete",
						icon: "icon icon-clear",
						callback: function (row) {
							return _this.deleteBunbdle(row.id);
						},
						tooltip: "Delete"
					}];
				}
			},
			getBundlesListColumns: {
				value: function getBundlesListColumns() {
	
					return [{
						header: "Name",
						field: "name",
						sortable: true,
						filterable: true,
						cellTemplate: "<div>{{row.entity.name}}</div>"
					}, {
						header: "Description",
						field: "description",
						cellTemplate: "<div>{{row.entity.description}}</div>" }, {
						header: "Create Date",
						field: "create_date",
						cellTemplate: "<div>{{row.entity.created | date:'yyyy-MM-dd HH:mm:ss Z'}}</div>",
						sortable: true
					}, {
						header: "Status",
						field: "status",
						cellTemplate: "<div>{{row.entity.formatedStatus }}</div>",
						width: "10%"
					}];
				}
			},
			openNewBundleModal: {
				value: function openNewBundleModal() {
					var _this = this;
	
					var modalScope = this.$scope.$new();
					modalScope.title = "Create New Support Bundle";
	
					// defaults
					modalScope.endDate = this.today;
					modalScope.bundleData = {
						configuration: true,
						systemInfoConfiguration: true,
						systemLogsConfiguration: true,
						threadDumpConfiguration: true,
						threadDump: {
							count: 1,
							interval: 0
						}
					};
	
					modalScope.onChangeTimePeriod = function () {
						var timePeriodSelection = modalScope.bundleData.timePeriodSelection;
						modalScope.bundleData.endDate = moment(_this.today).format();
						modalScope.bundleData.startDate = moment(_this.today).subtract(timePeriodSelection - 1, "days").format();
					};
	
					modalScope.createBundle = function () {
	
						var json = {
							parameters: {
								configuration: modalScope.bundleData.configuration,
								system: modalScope.bundleData.systemInfoConfiguration,
								logs: {
									include: modalScope.bundleData.systemLogsConfiguration,
									start_date: moment(modalScope.bundleData.startDate).format("YYYY-MM-DD"),
									end_date: moment(modalScope.bundleData.endDate).format("YYYY-MM-DD")
								},
								thread_dump: {
									count: !modalScope.bundleData.threadDumpConfiguration ? 0 : modalScope.bundleData.threadDump.count,
									interval: modalScope.bundleData.threadDump.interval
								}
							},
							name: modalScope.bundleData.supportBundleName,
							description: modalScope.bundleData.supportBundleDescription
						};
	
						_this.supportPageDao.generateBundle(json).$promise.then(function (data) {
							_this.updateBundlesList();
							_this.modalInstance.close();
						});
					};
	
					this.modalInstance = this.modal.launchModal("support_bundle_modal", modalScope, 1000);
				}
			},
			updateBundlesList: {
				value: function updateBundlesList() {
					var _this = this;
	
					this.supportPageDao.listBundles().$promise.then(function (data) {
						_this.bundles = _this.formatStatus(data);
						_this.bundlesTableOptions.setData(_this.bundles);
					});
				}
			},
			formatStatus: {
				value: function formatStatus(data) {
					var options = {
						success: "Success",
						in_progress: "In progress",
						failure: "Failure"
					};
					data.forEach(function (item) {
						item.formatedStatus = options[item.status] || "";
					});
	
					return data;
				}
			},
			downloadBundle: {
				value: function downloadBundle(bundleId) {
					var url = this.RESOURCE.API_URL + "/userSupport/downloadBundle/" + bundleId;
					this.iFrameDownload(url);
				}
			},
			deleteBunbdle: {
				value: function deleteBunbdle(bundleId) {
					var _this = this;
	
					this.modal.confirm("Are you sure you want to delete this bundle?").then(function () {
						_this.supportPageDao.deleteBundle({}, { bundleId: bundleId }).$promise.then(function () {
							_this.artifactoryNotifications.create({ info: "Bundle deleted successfully." });
							_this.updateBundlesList();
						});
					});
				}
			},
			_getDatePartFromFormat: {
				value: function _getDatePartFromFormat(format) {
					var parts = this._breakFormat(format);
	
					var currContext = "U"; //U = Unkown D = Date T = Time
					var unknowns = [];
	
					var gotMonth = false;
					for (var i in parts) {
						var part = parts[i];
	
						if (_.includes("dy", part.char)) {
							part.context = "D";
						} else if (_.includes("hs", part.char)) {
							part.context = "T";
						} else if (part.char === "m") {
							if (gotMonth) currContext = "U";
							part.context = !gotMonth && currContext === "D" ? "D" : "U";
							unknowns.push(part);
						}
						if (part.context) currContext = part.context;
						if (currContext !== "U" && unknowns.length) {
							for (var _i in unknowns) {
								unknowns[_i].context = currContext;
								if (currContext === "D") gotMonth = true;
							}
							unknowns = [];
						}
					}
	
					var insideDate = false;
					var justDate = [];
					for (var i in parts) {
						var part = parts[i];
						if (part.context === "D") {
							insideDate = true;
						} else if (part.context === "T") {
							insideDate = false;
						}
						if (insideDate) justDate.push(part);
					}
	
					var trim = 0;
					for (var i = justDate.length - 1; i >= 0; i--) {
						var part = parts[i];
						if (part.context) {
							break;
						} else justDate.pop();
					}
	
					var finalResult = "";
					for (var i in justDate) {
						var part = justDate[i];
						finalResult += part.precise;
					}
	
					return moment().toMomentFormatString(finalResult);
				}
			},
			_breakFormat: {
				value: function _breakFormat(format) {
					var parts = [];
					while (format.length) {
						var part = this._getNextFormatPart(format);
						parts.push(part);
						format = format.substr(part.count);
					}
					return parts;
				}
			},
			_getNextFormatPart: {
				value: function _getNextFormatPart(format) {
					var temp = format.toLowerCase();
					var char = temp.charAt(0);
					var count = 0;
					while (temp.charAt(0) === char) {
						count++;
						temp = temp.substr(1);
					}
					var precise = format.substr(0, count);
					return {
						char: char,
						count: count,
						precise: precise
					};
				}
			}
		});
	
		return AdminAdvancedSupportPageController;
	})();

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminAdvancedLogAnalyticsController = __webpack_require__(233).AdminAdvancedLogAnalyticsController;
	
	function logAnalyticsConfig($stateProvider) {
	    $stateProvider.state("admin.advanced.log_analytics", {
	        url: "/log_analytics",
	        templateUrl: "states/admin/advanced/log_analytics/log_analytics.html",
	        controller: "AdminAdvancedLogAnalyticsController as LogAnalytics"
	    });
	}
	
	module.exports = angular.module("advanced.log_analytics", []).config(logAnalyticsConfig).controller("AdminAdvancedLogAnalyticsController", AdminAdvancedLogAnalyticsController);

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var MESSAGES = _interopRequire(__webpack_require__(190));
	
	/*
	* TODO:
	* - if proxy is change or on load thre's default proxy - update the model
	* */
	
	var AdminAdvancedLogAnalyticsController = exports.AdminAdvancedLogAnalyticsController = (function () {
	    function AdminAdvancedLogAnalyticsController(SumoLogicConfigDao, $scope, $state, $location, $timeout, $interval, $window, JFrogModal, ArtifactoryModelSaver, ProxiesDao, ArtifactoryFeatures) {
	        var _this = this;
	
	        _classCallCheck(this, AdminAdvancedLogAnalyticsController);
	
	        this.sumoLogicConfigDao = SumoLogicConfigDao;
	        this.$scope = $scope;
	        this.$state = $state;
	        this.$location = $location;
	        this.$timeout = $timeout;
	        this.$interval = $interval;
	        this.$window = $window;
	        this.modal = JFrogModal;
	        this.proxiesDao = ProxiesDao;
	        this.artifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["sumologic"]);
	        this.enableExistingSettings = false;
	        this.features = ArtifactoryFeatures;
	        this.TOOLTIP = TOOLTIP.admin.logAnalytics;
	        this.MESSAGES = MESSAGES.admin.advanced.logAnalytics;
	        this.getSumoLogicData(false, true);
	        this.proxies = [""];
	
	        this.proxiesDao.get().$promise.then(function (proxies) {
	            _.forEach(proxies, function (o) {
	                _this.proxies.push(o.key);
	                if (o.defaultProxy && !_this.proxy) {
	                    _this.proxy = o.key;
	                }
	            });
	        });
	
	        this.$scope.$on("$destroy", function () {
	            _this.cancelInterval();
	        });
	    }
	
	    _createClass(AdminAdvancedLogAnalyticsController, {
	        disabledIntegration: {
	            value: function disabledIntegration() {
	                var _this = this;
	
	                if (this.enableExistingSettings === false) {
	                    this.modal.confirm("If disabled, logs will not be sent to your Sumo Logic account. <br /> You can enable the integration for this instance later. <br /><br /> Are you sure you want to disable the integration for this instance?", "Disable Sumo Logic Integration", { confirm: "Disable" }).then(function () {
	                        _this.cancelInterval();
	                        _this.enableDisableSumoLogic(false);
	                    })["catch"](function () {
	                        _this.enableExistingSettings = !_this.enableExistingSettings;
	                    });
	                } else {
	                    if (!this.sumologic.email) {
	                        this.modal.confirm("To enable the Sumo Logic integration, you must provide " + this.features.getGlobalName() + " with your email address by adding it to your User Profile.", "Email address required", { confirm: "Go to User Profile" }).then(function () {
	                            _this.$state.go("user_profile");
	                        })["catch"](function () {
	                            _this.enableExistingSettings = !_this.enableExistingSettings;
	                        });
	                    } else {
	                        if (this.sumologic.clientId && this.sumologic.secret) {
	                            this.modal.confirm("If enabled, your logs will be populated and sent to your Sumo Logic " + this.features.getGlobalName() + " dashboard. <br /><br /> Are you sure you want to enable the integration for this instance?", "Enable Sumo Logic Integration", { confirm: "Enable" }).then(function () {
	                                _this.enableDisableSumoLogic(true);
	                            })["catch"](function () {
	                                _this.enableExistingSettings = !_this.enableExistingSettings;
	                            });
	                        } else {
	                            this.enableDisableSumoLogic(true);
	                        }
	                    }
	                }
	            }
	        },
	        enableDisableSumoLogic: {
	            value: function enableDisableSumoLogic(action) {
	                this.sumologic.enabled = action;
	                this.updateModel();
	            }
	        },
	        changeListener: {
	            value: function changeListener() {
	                if (this.connectionMethod === "existing") {
	                    this.disableRegisterButton = false;
	                }
	            }
	        },
	        requireAuth: {
	            value: function requireAuth() {
	                return this.sumologic.clientId != this.origSumologicData.clientId || this.sumologic.secret != this.origSumologicData.secret;
	            }
	        },
	        changeConnectionMethod: {
	            value: function changeConnectionMethod(value) {
	                var _this = this;
	
	                if (value === "new") {
	                    if (this.sumologic.dashboardUrl || this.isPullingRunning) {
	                        this.modal.confirm("Creating a new connection will disconnect the current connection. When you access your dashboard with a new connection for the first time, a new Client ID and Secret will be created. <br /><br />Are you sure you want to create a new connection?", "Create New Connection with Sumo Logic", { confirm: "Create" }).then(function () {
	                            _this.cancelInterval();
	                            _this.sumoLogicConfigDao.reset().$promise.then(function (sumologic) {
	                                _this.connectionMethod = "new";
	                                _this.statusConnected = false;
	                                _this.disableRegisterButton = false;
	                                _this.sumologic = sumologic;
	                                _this.artifactoryModelSaver.save();
	                            })["catch"](function () {
	                                _this.cancelInterval();
	                            });
	                        })["catch"](function () {
	                            _this.connectionMethod = "existing";
	                        });
	                    } else {
	                        this.sumologic.clientId = null;
	                        this.sumologic.secret = null;
	                    }
	                }
	            }
	        },
	        registerSumoLogicApplication: {
	            value: function registerSumoLogicApplication() {
	                var _this = this;
	
	                this.disableRegisterButton = true;
	                this.sumologic.dashboardUrl = null;
	                this.sumoLogicConfigDao.registerSumoLogicApplication().$promise.then(function () {
	                    _this.getSumoLogicData(true);
	                    if (!angular.isDefined(_this.getDataInterval)) {
	                        _this.getDataInterval = _this.$interval(function () {
	                            _this.isPullingRunning = true;
	                            _this.getSumoLogicData();
	                        }, 5000);
	                    }
	                })["catch"](function () {
	                    _this.cancelInterval();
	                });
	            }
	        },
	        authenticateWithSumo: {
	            value: function authenticateWithSumo(setupNewConnection) {
	                var _this = this;
	
	                this.sumologic.dashboardUrl = null;
	                var setupTypeSuffix = setupNewConnection ? "/new_app" : "/existing_app";
	                var redirectUrl = encodeURIComponent(this.sumologic.redirectUrl + setupTypeSuffix);
	                var email = this.sumologic.email;
	                var url = this.sumologic.sumoBaseUrl + "/partner/oauth/authorize?response_type=code&email=" + encodeURIComponent(email) + "&license_type=" + this.sumologic.licenseType + "&client_id=" + this.sumologic.clientId + "&redirect_uri=" + redirectUrl + "";
	
	                var popup = this.$window.open(url, "_blank");
	
	                if (!angular.isDefined(this.getDataInterval)) {
	                    this.getDataInterval = this.$interval(function () {
	                        _this.isPullingRunning = true;
	                        _this.getSumoLogicData();
	                    }, 5000);
	                }
	
	                this.$timeout(function () {
	                    if (!popup || popup.outerHeight === 0) {
	                        var modalScope = _this.$scope.$new();
	                        modalScope.url = url;
	                        _this.modalInstance = _this.modal.launchModal("popup_block_notice", modalScope, "sm");
	                    }
	                }, 100);
	            }
	        },
	        getSumoLogicData: {
	            value: function getSumoLogicData(setupNewConnection, firstLoad) {
	                var _this = this;
	
	                this.sumoLogicConfigDao.get().$promise.then(function (sumologic) {
	                    _this.sumologic = sumologic;
	                    if (sumologic.proxy) _this.proxy = sumologic.proxy;
	                    _this.origSumologicData = {
	                        clientId: _this.sumologic.clientId,
	                        secret: _this.sumologic.secret
	                    };
	                    _this.enableExistingSettings = _this.sumologic.enabled;
	
	                    if (_this.sumologic.dashboardUrl) {
	                        _this.cancelInterval();
	                        if (firstLoad && _this.enableExistingSettings) {
	                            _this.sumoLogicConfigDao.refreshToken().$promise.then(function (refreshResponseData) {
	                                _this.sumologic.dashboardUrl = refreshResponseData.dashboardUrl;
	                                _this.statusConnected = true;
	                                _this.updateModel();
	                            })["catch"](function () {
	                                if (angular.isDefined(_this.getDataInterval)) {
	                                    _this.$interval.cancel(_this.getDataInterval);
	                                }
	                            });
	                        }
	                    }
	
	                    if (_this.sumologic.clientId || _this.sumologic.secret) {
	                        _this.connectionMethod = "existing";
	                    } else {
	                        _this.connectionMethod = "new";
	                    }
	
	                    if (setupNewConnection) {
	                        _this.authenticateWithSumo(true);
	                        _this.updateModel();
	                    }
	                    _this.artifactoryModelSaver.save();
	                })["catch"](function () {
	                    _this.cancelInterval();
	                });
	            }
	        },
	        cancelInterval: {
	            value: function cancelInterval() {
	                if (angular.isDefined(this.getDataInterval)) {
	                    this.isPullingRunning = false;
	                    this.$interval.cancel(this.getDataInterval);
	                    delete this.getDataInterval;
	                }
	            }
	        },
	        updateProxy: {
	            value: function updateProxy() {
	                this.updateModel();
	            }
	        },
	        updateModel: {
	            value: function updateModel() {
	                var _this = this;
	
	                if (this.proxy) this.sumologic.proxy = this.proxy;
	                this.sumoLogicConfigDao.update(this.sumologic).$promise.then(function () {
	                    _this.artifactoryModelSaver.save();
	                });
	            }
	        }
	    });
	
	    return AdminAdvancedLogAnalyticsController;
	})();

/***/ }),
/* 234 */
/***/ (function(module, exports) {

	"use strict";
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminAdvancedController = exports.AdminAdvancedController = function AdminAdvancedController() {
	  _classCallCheck(this, AdminAdvancedController);
	
	  var AdminAdvanced = this;
	  AdminAdvanced.stateUrl = "/advanced";
	  AdminAdvanced.controllerName = "AdminAdvancedController";
	};

/***/ }),
/* 235 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	function dashboardConfig($stateProvider) {
	    $stateProvider.state("admin.dashboard", {
	        url: "/dashboard",
	        templateUrl: "states/admin/dashboard/dashboard.html"
	    });
	}
	
	module.exports = angular.module("admin.dashboard", []).config(dashboardConfig);

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var Repositories = _interopRequire(__webpack_require__(237));
	
	var System = _interopRequire(__webpack_require__(239));
	
	var AdminImportExportController = __webpack_require__(241).AdminImportExportController;
	
	function importExportConfig($stateProvider) {
	    $stateProvider.state("admin.import_export", {
	        url: "/import_export",
	        template: "<ui-view></ui-view>",
	        controller: "AdminImportExportController as AdminImportExport"
	    });
	}
	
	module.exports = angular.module("admin.import_export", [Repositories.name, System.name]).config(importExportConfig).controller("AdminImportExportController", AdminImportExportController);

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var ImportExportRepositoriesController = __webpack_require__(238).ImportExportRepositoriesController;
	
	function repositoriesConfig($stateProvider) {
	    $stateProvider.state("admin.import_export.repositories", {
	        params: { feature: "repositories" },
	        url: "/repositories",
	        templateUrl: "states/admin/import_export/repositories/repositories.html",
	        controller: "ImportExportRepositoriesController as Repositories"
	    });
	}
	
	module.exports = angular.module("import_export.repositories", []).config(repositoriesConfig).controller("ImportExportRepositoriesController", ImportExportRepositoriesController);

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var API = _interopRequire(__webpack_require__(98));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var ImportExportRepositoriesController = exports.ImportExportRepositoriesController = (function () {
	    function ImportExportRepositoriesController($scope, BrowseFilesDao, ExportDao, ImportDao, JFrogNotifications, FileUploader, RepoDataDao, JFrogEventBus, ArtifactoryFeatures) {
	        var _this = this;
	
	        _classCallCheck(this, ImportExportRepositoriesController);
	
	        this.$scope = $scope;
	        this.features = ArtifactoryFeatures;
	        this.repoDataDao = RepoDataDao;
	        this.browseFilesDao = BrowseFilesDao.getInstance();
	        this.JFrogEventBus = JFrogEventBus;
	        this.FileUploader = FileUploader;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	
	        this.exportDao = ExportDao;
	        this.importDao = ImportDao;
	        this.TOOLTIP = TOOLTIP.admin.import_export.repositories;
	
	        this.exportFileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Export",
	            pathLabel: "Path to export",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: true
	        };
	        this.importFileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Import",
	            pathLabel: "Path to import",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: false
	        };
	
	        this.uploadZip = {};
	        this.uploadSuccess = false;
	        this.exportOptions = {
	            action: "repository",
	            repository: "All Repositories",
	            path: "",
	            excludeMetadata: false,
	            m2: false,
	            verbose: false
	        };
	        this.importOptions = {
	            action: "repository",
	            repository: "All Repositories",
	            path: "",
	            excludeMetadata: false,
	            verbose: false
	        };
	        this.zipOptions = {
	            action: "repository",
	            repository: "All Repositories",
	            path: "",
	            verbose: false
	        };
	        this.artifactoryNotifications = JFrogNotifications;
	        this._initImportExportRepo();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.getAllReposList();
	        });
	    }
	
	    _createClass(ImportExportRepositoriesController, {
	        _getRootPath: {
	            value: function _getRootPath() {
	                var _this = this;
	
	                this.browseFilesDao.query({ path: "/" }).$promise.then(function (result) {
	                    if (result) {
	                        _this.rootPath = result.roots[0] || "/";
	                        _this.roots = result.roots;
	                    }
	                });
	            }
	        },
	        getAllReposList: {
	            value: function getAllReposList() {
	                var _this = this;
	
	                this.repoDataDao.getForBackup().$promise.then(function (result) {
	                    _this.reposList = _.sortBy(result.repoList, function (repo) {
	                        return repo;
	                    });
	                    _this.reposList.unshift("All Repositories");
	                });
	            }
	        },
	        _initImportExportRepo: {
	            value: function _initImportExportRepo() {
	                this.uploader = new this.FileUploader();
	                this.uploader.url = "" + API.API_URL + "/artifactimport/upload";
	                this.uploader.headers = { "X-Requested-With": "artUI" };
	                this.uploader.onSuccessItem = this.onUploadSuccess.bind(this);
	                this.uploader.onErrorItem = this.onUploadError.bind(this);
	                this.uploader.onAfterAddingFile = this.onAddingfile.bind(this);
	
	                this.uploader.removeAfterUpload = true;
	                this.getAllReposList();
	
	                this._getRootPath();
	            }
	        },
	        onUploadError: {
	            value: function onUploadError(fileDetails, response) {
	                this.artifactoryNotifications.create(response);
	            }
	        },
	        onUploadSuccess: {
	            value: function onUploadSuccess(fileDetails, response) {
	                this.uploadSuccess = true;
	                this.zipOptions.path = response.path;
	            }
	        },
	        onAddingfile: {
	            value: function onAddingfile(fileItem) {
	                if (fileItem.file.size < 0) {
	                    fileItem.okToUploadFile = false;
	                    this.uploader.removeFromQueue(fileItem);
	                } else {
	                    fileItem.okToUploadFile = true;
	                }
	            }
	        },
	        updateExportFolderPath: {
	            value: function updateExportFolderPath(directory) {
	                this.exportOptions.path = directory;
	            }
	        },
	        updateImportFolderPath: {
	            value: function updateImportFolderPath(directory) {
	                this.importOptions.path = directory;
	            }
	        },
	        clearValidations: {
	            value: function clearValidations() {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	            }
	        },
	        "export": {
	            value: function _export(form) {
	                if (form.$valid) {
	                    this.exportDao.save(this.exportOptions);
	                }
	            }
	        },
	        "import": {
	            value: function _import(form) {
	                if (form.$valid) {
	                    this.importDao.save(this.importOptions);
	                }
	            }
	        },
	        importUploadZip: {
	            value: function importUploadZip() {
	                var _this = this;
	
	                var importDetails = {
	                    path: this.zipOptions.path,
	                    verbose: this.zipOptions.verbose,
	                    repository: this.zipOptions.repository,
	                    zip: true
	                };
	                this.importDao.save({ action: "repository" }, importDetails).$promise["finally"](function () {
	                    return _this.uploadSuccess = false;
	                });
	            }
	        },
	        upload: {
	            value: function upload() {
	                if (this.uploader.queue[0]) {
	                    this.uploader.queue[0].upload();
	                }
	            }
	        }
	    });
	
	    return ImportExportRepositoriesController;
	})();

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminImportExportSystemController = __webpack_require__(240).AdminImportExportSystemController;
	
	function systemConfig($stateProvider) {
	    $stateProvider.state("admin.import_export.system", {
	        url: "/system",
	        templateUrl: "states/admin/import_export/system/system.html",
	        controller: "AdminImportExportSystemController as SystemController"
	    });
	}
	
	module.exports = angular.module("import_export.system", []).config(systemConfig).controller("AdminImportExportSystemController", AdminImportExportSystemController);

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminImportExportSystemController = exports.AdminImportExportSystemController = (function () {
	    function AdminImportExportSystemController(BrowseFilesDao, ExportDao, ImportDao, JFrogNotifications, JFrogModal, JFrogEventBus, ArtifactoryFeatures) {
	        _classCallCheck(this, AdminImportExportSystemController);
	
	        this.features = ArtifactoryFeatures;
	        this.browseFilesDao = BrowseFilesDao.getInstance();
	        this.JFrogEventBus = JFrogEventBus;
	        this.systemExportDao = ExportDao;
	        this.systemImportDao = ImportDao;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.modal = JFrogModal;
	        this.TOOLTIP = TOOLTIP.admin.import_export.system;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	
	        this.exportFileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Export",
	            pathLabel: "Path to export",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: true
	        };
	        this.importFileBrowserOptions = {
	            canSelectFiles: true,
	            selectionLabel: "Directory Or Zip File To Import",
	            pathLabel: "Path to import",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: false
	        };
	
	        this.exportOptions = {
	            path: "",
	            excludeContent: false,
	            excludeMetadata: false,
	            m2: false,
	            createArchive: false,
	            verbose: false
	        };
	
	        this.importOptions = {
	            path: "",
	            excludeContent: false,
	            excludeMetadata: false,
	            verbose: false
	        };
	
	        this._getRootPath();
	    }
	
	    _createClass(AdminImportExportSystemController, {
	        _getRootPath: {
	            value: function _getRootPath() {
	                var _this = this;
	
	                this.browseFilesDao.query({ path: "/" }).$promise.then(function (result) {
	                    if (result) {
	                        _this.defaultRootPath = result.roots[0] || "/";
	                        _this.roots = result.roots;
	                    }
	                });
	            }
	        },
	        clearValidations: {
	            value: function clearValidations() {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	            }
	        },
	        updateImportFolderPath: {
	            value: function updateImportFolderPath(directory) {
	                this.importOptions.path = directory;
	            }
	        },
	        updateExportFolderPath: {
	            value: function updateExportFolderPath(directory) {
	                this.exportOptions.path = directory;
	            }
	        },
	        "import": {
	            value: function _import() {
	                if (this.importForm.$valid) {
	                    this.confirmImport();
	                }
	            }
	        },
	        doImport: {
	            value: function doImport() {
	                var _this = this;
	
	                this.importOptions.zip = _.endsWith(this.importOptions.path, ".zip");
	                this.importOptions.action = "system";
	                this.systemImportDao.save(this.importOptions).$promise.then(function (response) {
	                    if (response.data.errors) {
	                        _this.artifactoryNotifications.create({ error: "The import has failed. Check Artifactory logs for details." });
	                    }
	                });
	            }
	        },
	        "export": {
	            value: function _export() {
	                var _this = this;
	
	                if (this.exportForm.$valid) {
	                    this.exportOptions.action = "system";
	                    this.systemExportDao.save(this.exportOptions).$promise.then(function (res) {
	                        if (res.status = 200) {
	                            document.querySelector("#export-path").focus();
	                            _this.exportOptions.path = "";
	                        }
	                    });
	                }
	            }
	        },
	        confirmImport: {
	            value: function confirmImport() {
	                var _this = this;
	
	                this.modal.confirm("Full system import deletes all existing Artifactory content. <br /> Are you sure you want to continue?").then(function () {
	                    return _this.doImport();
	                });
	            }
	        }
	    });
	
	    return AdminImportExportSystemController;
	})();

/***/ }),
/* 241 */
/***/ (function(module, exports) {

	"use strict";
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminImportExportController = exports.AdminImportExportController = function AdminImportExportController() {
	  _classCallCheck(this, AdminImportExportController);
	
	  var AdminImportExport = this;
	  AdminImportExport.stateUrl = "/import_export";
	  AdminImportExport.controllerName = "AdminImportExportController";
	};

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var General = _interopRequire(__webpack_require__(243));
	
	var Groups = _interopRequire(__webpack_require__(245));
	
	var HttpSso = _interopRequire(__webpack_require__(248));
	
	var SshServer = _interopRequire(__webpack_require__(250));
	
	var Permissions = _interopRequire(__webpack_require__(252));
	
	var Users = _interopRequire(__webpack_require__(257));
	
	var Saml = _interopRequire(__webpack_require__(262));
	
	var CrowdIntegration = _interopRequire(__webpack_require__(264));
	
	var OAuth = _interopRequire(__webpack_require__(266));
	
	var LdapSettings = _interopRequire(__webpack_require__(269));
	
	var SigningKeys = _interopRequire(__webpack_require__(273));
	
	var TrustedKeys = _interopRequire(__webpack_require__(275));
	
	var AccessTokens = _interopRequire(__webpack_require__(277));
	
	var SslCertificates = _interopRequire(__webpack_require__(279));
	
	var AdminSecurityController = __webpack_require__(281).AdminSecurityController;
	
	function securityConfig($stateProvider) {
	    $stateProvider.state("admin.security", {
	        url: "/security",
	        template: "<ui-view></ui-view>",
	        controller: "AdminSecurityController as AdminSecurity"
	    });
	}
	
	module.exports = angular.module("admin.security", [General.name, Groups.name, HttpSso.name, SshServer.name, Permissions.name, Users.name, Saml.name, CrowdIntegration.name, OAuth.name, LdapSettings.name, SigningKeys.name, TrustedKeys.name, AccessTokens.name, SslCertificates.name]).config(securityConfig).controller("AdminSecurityController", AdminSecurityController);

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminSecurityGeneralController = __webpack_require__(244).AdminSecurityGeneralController;
	
	function securityGeneralConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.general", {
	        url: "/general",
	        templateUrl: "states/admin/security/general/general.html",
	        controller: "AdminSecurityGeneralController as AdminSecurityGeneral"
	    });
	}
	
	module.exports = angular.module("security.general", []).config(securityGeneralConfig).controller("AdminSecurityGeneralController", AdminSecurityGeneralController);

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var MESSAGES = _interopRequire(__webpack_require__(190));
	
	var AdminSecurityGeneralController = exports.AdminSecurityGeneralController = (function () {
	    function AdminSecurityGeneralController(AdminSecurityGeneralDao, PasswordsEncryptionDao, ArtifactoryModelSaver, UserProfileDao, JFrogModal, UserDao, JFrogNotifications, User) {
	        _classCallCheck(this, AdminSecurityGeneralController);
	
	        this.adminSecurityGeneralDao = AdminSecurityGeneralDao;
	        this.passwordsEncryptionDao = PasswordsEncryptionDao.getInstance();
	        this.options = [{ label: "Supported", value: "SUPPORTED" }, { label: "Unsupported", value: "UNSUPPORTED" }, { label: "Required", value: "REQUIRED" }];
	        this.modal = JFrogModal;
	        this.User = User;
	        this.TOOLTIP = TOOLTIP.admin.security.general;
	        this.MESSAGES = MESSAGES.admin.security.general;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["generalConfig"]);
	        this.userProfileDao = UserProfileDao;
	        this.userDao = UserDao.getInstance();
	        this.artifactoryNotifications = JFrogNotifications;
	
	        this.getGeneralConfigObject();
	        this.getMasterKeyStatus();
	    }
	
	    _createClass(AdminSecurityGeneralController, {
	        getEncryptionButtonText: {
	            value: function getEncryptionButtonText() {
	                return this.materKeyState.hasMasterKey ? "Decrypt" : "Encrypt";
	            }
	        },
	        getEncryptionStatusText: {
	            value: function getEncryptionStatusText() {
	                return this.materKeyState.hasMasterKey ? this.MESSAGES.passwordEncrypted : this.MESSAGES.passwordDecrypted;
	            }
	        },
	        getGeneralConfigObject: {
	            value: function getGeneralConfigObject() {
	                var _this = this;
	
	                this.adminSecurityGeneralDao.get().$promise.then(function (data) {
	                    _this.generalConfig = data;
	                    _this.generalConfig.passwordSettings.encryptionPolicy = _.find(_this.options, { value: _this.generalConfig.passwordSettings.encryptionPolicy });
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        getMasterKeyStatus: {
	            value: function getMasterKeyStatus() {
	                this.materKeyState = this.passwordsEncryptionDao.get();
	            }
	        },
	        forcePassExpForAll: {
	            value: function forcePassExpForAll() {
	                var _this = this;
	
	                if (!this.generalConfig.passwordSettings.expirationPolicy.enabled) {
	                    return;
	                }this.modal.confirm("Are you sure you want to expire all user's passwords?").then(function () {
	                    _this.userDao.expireAllPassword();
	                });
	            }
	        },
	        unExpireAll: {
	            value: function unExpireAll() {
	                var _this = this;
	
	                if (!this.generalConfig.passwordSettings.expirationPolicy.enabled) {
	                    return;
	                }this.modal.confirm("Are you sure you want to unexpire all user's expired passwords?").then(function () {
	                    _this.userDao.unExpireAllPassword();
	                });
	            }
	        },
	        toggleEncryption: {
	            value: function toggleEncryption() {
	                var _this = this;
	
	                if (this.materKeyState.hasMasterKey) {
	                    this.modal.confirm("Artifactory will decrypt all encrypted data in your configuration files<br/>and user sensitive data, and it will be saved in clear text.<br/>It is recommended to backup your current artifactory.key<br/>(under $ARTIFACTORY_HOME/etc/security).<br/><br/>Are you sure you want to decrypt?", null, { confirm: "Decrypt" }).then(function () {
	                        _this.materKeyState.$decrypt().then(function () {
	                            _this.getMasterKeyStatus();
	                        });
	                    });
	                } else {
	                    this.modal.confirm("Artifactory will create a private key to encrypt your configuration data<br/>and user sensitive data under /etc directory.<br/>Make sure to backup the key (under $ARTIFACTORY_HOME/etc/security)<br/>in a secure private location, since without it Artifactory will not be able to decrypt the encrypted data, such as configuration passwords, API keys, encrypted passwords, etc.<br/><br/>Are you sure you want to encrypt?", null, { confirm: "Encrypt" }).then(function () {
	                        _this.materKeyState.$encrypt().then(function () {
	                            _this.getMasterKeyStatus();
	                        });
	                    });
	                }
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                var payload = _.cloneDeep(this.generalConfig);
	                payload.passwordSettings.encryptionPolicy = payload.passwordSettings.encryptionPolicy.value;
	                this.adminSecurityGeneralDao.update(payload).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.User.reload();
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getGeneralConfigObject();
	                });
	            }
	        },
	        revokeApiKeys: {
	            value: function revokeApiKeys() {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to revoke all users API keys?").then(function () {
	                    _this.userProfileDao.revokeApiKey({ deleteAll: 1 });
	                });
	            }
	        },
	        unlockAllUsers: {
	            value: function unlockAllUsers() {
	                this.adminSecurityGeneralDao.unlockAllUsers();
	            }
	        }
	    });
	
	    return AdminSecurityGeneralController;
	})();

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminSecurityGroupsController = __webpack_require__(246).AdminSecurityGroupsController;
	
	var AdminSecurityGroupFormController = __webpack_require__(247).AdminSecurityGroupFormController;
	
	function groupsConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.groups", {
	        url: "/groups",
	        templateUrl: "states/admin/security/groups/groups.html",
	        controller: "AdminSecurityGroupsController as AdminSecurityGroups"
	    }).state("admin.security.groups.edit", {
	        parent: "admin.security",
	        url: "/groups/{groupname}/edit",
	        templateUrl: "states/admin/security/groups/group_form.html",
	        controller: "AdminSecurityGroupFormController as GroupForm"
	    }).state("admin.security.groups.new", {
	        parent: "admin.security",
	        url: "/groups/new",
	        templateUrl: "states/admin/security/groups/group_form.html",
	        controller: "AdminSecurityGroupFormController as GroupForm"
	    });
	}
	
	module.exports = angular.module("security.groups", []).config(groupsConfig).controller("AdminSecurityGroupsController", AdminSecurityGroupsController).controller("AdminSecurityGroupFormController", AdminSecurityGroupFormController);

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var AdminSecurityGroupsController = exports.AdminSecurityGroupsController = (function () {
	    function AdminSecurityGroupsController(JFrogModal, $scope, $state, GroupsDao, JFrogGridFactory, uiGridConstants, commonGridColumns) {
	        _classCallCheck(this, AdminSecurityGroupsController);
	
	        this.DEFAULT_REALM = "artifactory";
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.groupsDao = GroupsDao.getInstance();
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.$scope = $scope;
	        this.$state = $state;
	        this.noGroupsMessage = CONFIG_MESSAGES.admin.security.groups.noGroupsMessage;
	        this._createGrid();
	        this._initGroups();
	    }
	
	    _createClass(AdminSecurityGroupsController, {
	        _initGroups: {
	            value: function _initGroups() {
	                var _this = this;
	
	                this.groupsDao.getAll().$promise.then(function (groups) {
	                    _this.gridOption.setGridData(groups);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setButtons(this._getActions()).setMultiSelect().setRowTemplate("default").setBatchActions(this._getBatchActions());
	            }
	        },
	        deleteGroup: {
	            value: function deleteGroup(group) {
	                var _this = this;
	
	                var json = { groupNames: [group.groupName] };
	                this.modal.confirm("Are you sure you want to delete group '" + group.name + "' ?").then(function () {
	                    return _this.groupsDao["delete"](json).$promise.then(function () {
	                        return _this._initGroups();
	                    });
	                });
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;
	
	                //Get All selected users
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                //Create an array of the selected groups names
	                var names = _.map(selectedRows, function (group) {
	                    return group.groupName;
	                });
	                //Create Json for the bulk request
	                var json = { groupNames: names };
	                //console.log('Bulk delete....');
	                //Ask for confirmation before delete and if confirmed then delete bulk of users
	                this.modal.confirm("Are you sure you want to delete " + names.length + " groups ?").then(function () {
	                    return _this.groupsDao["delete"](json).$promise.then(function () {
	                        return _this._initGroups();
	                    });
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    field: "groupName",
	                    name: "Group Name",
	                    displayName: "Group Name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" ui-sref=\"^.groups.edit({groupname: row.entity.groupName})\"><a href=\"\" class=\"jf-link\" >{{row.entity.groupName}}</a></div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "20%"
	                }, {
	                    field: "permissions",
	                    name: "Permissions",
	                    displayName: "Permissions",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.permissions", "row.entity.groupName"),
	                    width: "50%"
	                }, {
	                    name: "External",
	                    displayName: "External",
	                    field: "External",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.external"),
	                    width: "10%"
	                }, {
	                    name: "Admin",
	                    displayName: "Admin",
	                    field: "adminPrivileges",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.adminPrivileges"),
	                    width: "10%"
	                }, {
	                    name: "Auto Join",
	                    displayName: "Auto Join",
	                    field: "Auto Join",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.autoJoin"),
	                    width: "10%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteGroup(row);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    }
	                }];
	            }
	        }
	    });
	
	    return AdminSecurityGroupsController;
	})();

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var MESSAGES = _interopRequire(__webpack_require__(190));
	
	var AdminSecurityGroupFormController = exports.AdminSecurityGroupFormController = (function () {
	    function AdminSecurityGroupFormController($scope, $state, $stateParams, $timeout, $q, JFrogGridFactory, GroupsDao, UserDao, GroupPermissionsDao, commonGridColumns, ArtifactoryModelSaver, RepositoriesDao, FooterDao) {
	        var _this = this;
	
	        _classCallCheck(this, AdminSecurityGroupFormController);
	
	        this.DEFAULT_REALM = "artifactory";
	        this.$scope = $scope;
	        this.$state = $state;
	        this.footerDao = FooterDao;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.repositoriesDao = RepositoriesDao;
	        this.userDao = UserDao.getInstance();
	        this.groupsDao = GroupsDao.getInstance();
	        this.groupPermissionsDao = GroupPermissionsDao.getInstance();
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.permissionsGridOptions = {};
	        this.buildPermissionsGridOptions = {};
	        this.commonGridColumns = commonGridColumns;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["groupdata"]);
	        this.input = {};
	        this.MESSAGES = MESSAGES.admin.security.groups.groupForm;
	
	        this.footerDao.get().then(function (response) {
	            _this.xrayEnabled = response.xrayEnabled;
	        });
	
	        if ($stateParams.groupname) {
	            this.mode = "edit";
	            this.groupname = $stateParams.groupname;
	            this.title = "Edit " + this.groupname + " Group";
	            this._getGroupData();
	            this._createGrid();
	            this._getPermissions();
	        } else {
	            this.mode = "create";
	            this.title = "Add New Group";
	            this.groupdata = {};
	            this.saveLastNewUsersCheckbox = false;
	        }
	
	        this._getAllRepos();
	        this._getAllUsers();
	    }
	
	    _createClass(AdminSecurityGroupFormController, {
	        _getAllRepos: {
	            value: function _getAllRepos() {
	                var _this = this;
	
	                this.reposData = {};
	                this.repositoriesDao.getRepositories({ type: "local" }).$promise.then(function (data) {
	                    _this.reposData.locals = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	                this.repositoriesDao.getRepositories({ type: "remote" }).$promise.then(function (data) {
	                    _this.reposData.remotes = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	                this.repositoriesDao.getRepositories({ type: "distribution" }).$promise.then(function (data) {
	                    _this.reposData.dists = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	            }
	        },
	        _getGroupData: {
	            value: function _getGroupData() {
	                var _this = this;
	
	                this.groupsDao.getSingle({ name: this.groupname }).$promise.then(function (data) {
	                    _this.groupdata = data.data;
	                    _this.saveLastNewUsersCheckbox = _this.groupdata.newUserDefault;
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _getAllUsers: {
	            value: function _getAllUsers() {
	                var _this = this;
	
	                this.userDao.getAll().$promise.then(function (data) {
	                    _this.usersData = data;
	                    _this.usersList = _.map(data, function (user) {
	                        return user.name;
	                    });
	                    _this.userDndTemplate = "<div style=\"min-width:200px\">\n                                        {{getItemInfo().text}}\n                                        <i ng-if=\"userScope.GroupForm.userIsAdmin(getItemInfo().text)\" \n                                            jf-tooltip=\"Admin Privileges\"\n                                            class=\"icon icon-admin-new pull-left\"></i>\n                                        <i ng-if=\"!userScope.GroupForm.userIsAdmin(getItemInfo().text)\" \n                                            class=\"icon icon-blank pull-left\"></i>\n                                    </div>";
	                });
	            }
	        },
	        userIsAdmin: {
	            value: function userIsAdmin(user) {
	                return _.find(this.usersData, function (userData) {
	                    return userData.name === user && (userData.admin === true || userData.groupAdmin);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.permissionsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getPermissionCloumns()).setRowTemplate("default");
	
	                this.buildPermissionsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getBuildPermissionColumns()).setRowTemplate("default");
	            }
	        },
	        _getPermissions: {
	            value: function _getPermissions() {
	                var _this = this;
	
	                this.groupPermissionsDao.get({ groups: [this.groupname] }).$promise.then(function (data) {
	                    _this.buildPermissionsGridOptions.setGridData(data.buildPermissions);
	
	                    _this._fixDataFormat(data.repoPermissions).then(function (fixedData) {
	                        _this.permissionsGridOptions.setGridData(fixedData);
	                    });
	                });
	            }
	        },
	        _fixDataFormat: {
	            value: function _fixDataFormat(data) {
	                var _this = this;
	
	                var defer = arguments[1] === undefined ? null : arguments[1];
	
	                defer = defer || this.$q.defer();
	                if (this.reposData.locals && this.reposData.remotes) {
	                    data.forEach(function (record) {
	                        if (record.repoKeys && record.repoKeys.length === 1 && record.repoKeys[0] === "ANY LOCAL") {
	                            record.repoKeysView = "ANY LOCAL";
	                            record.reposList = angular.copy(_this.reposData.locals);
	                        } else if (record.repoKeys && record.repoKeys.length === 1 && record.repoKeys[0] === "ANY REMOTE") {
	                            record.repoKeysView = "ANY REMOTE";
	                            record.reposList = angular.copy(_this.reposData.remotes);
	                        } else if (record.repoKeys && record.repoKeys.length === 1 && record.repoKeys[0] === "ANY DISTRIBUTION") {
	                            record.repoKeysView = "ANY DISTRIBUTION";
	                            record.reposList = angular.copy(_this.reposData.dists);
	                        } else if (record.repoKeys && record.repoKeys.length === 1 && record.repoKeys[0] === "ANY") {
	                            record.repoKeysView = "ANY";
	                            record.reposList = angular.copy(_this.reposData.remotes).concat(_this.reposData.locals).concat(_this.reposData.dists);
	                        } else if (record.repoKeys) {
	                            record.repoKeysView = record.repoKeys.join(", ");
	                            record.reposList = angular.copy(record.repoKeys);
	                        }
	                    });
	                    defer.resolve(data);
	                } else {
	                    this.$timeout(function () {
	                        _this._fixDataFormat(data, defer);
	                    });
	                }
	                return defer.promise;
	            }
	        },
	        updateGroup: {
	            value: function updateGroup() {
	                var _this = this;
	
	                var payload = angular.copy(this.groupdata);
	                _.extend(payload, this.input);
	                this.groupsDao.update({ name: this.groupdata.groupName }, payload).$promise.then(function (data) {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.groups");
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        createNewGroup: {
	            value: function createNewGroup() {
	                var _this = this;
	
	                var payload = angular.copy(this.groupdata);
	                payload.realm = this.DEFAULT_REALM;
	                _.extend(payload, this.input);
	                this.groupsDao.create(payload).$promise.then(function (data) {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.groups");
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	
	                if (this.mode === "edit") this.updateGroup();
	                if (this.mode === "create") this.createNewGroup();
	            }
	        },
	        isSaveDisabled: {
	            value: function isSaveDisabled() {
	                return this.savePending || this.groupForm.$invalid;
	            }
	        },
	        onAdminPrivelegesChange: {
	            value: function onAdminPrivelegesChange() {
	                if (this.groupdata.adminPrivileges) {
	                    this.saveLastNewUsersCheckbox = this.groupdata.newUserDefault;
	                    this.groupdata.newUserDefault = false;
	                } else {
	                    this.groupdata.newUserDefault = this.saveLastNewUsersCheckbox;
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.groups");
	            }
	        },
	        _getBuildPermissionColumns: {
	            value: function _getBuildPermissionColumns() {
	                var nameCellTemplate = "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" href ui-sref=\"admin.security.permissions.edit({permission: row.entity.permissionName})\">{{row.entity.permissionName}}</a></div>";
	                var permissions = [{
	                    field: "permissionName",
	                    name: "Permission Target",
	                    displayName: "Permission Target",
	                    cellTemplate: nameCellTemplate,
	                    width: "35%"
	                }, {
	                    field: "effectivePermission.principal",
	                    name: "Applied To",
	                    displayName: "Applied To",
	                    width: "40%"
	                }, {
	                    field: "effectivePermission.managed",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managed"),
	                    name: "Manage",
	                    displayName: "Manage",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.delete"),
	                    name: "Delete",
	                    displayName: "Delete",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.deploy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.deploy"),
	                    name: "Deploy",
	                    displayName: "Deploy",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.annotate",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.annotate"),
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.read",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.read"),
	                    name: "Read",
	                    displayName: "Read",
	                    width: "15%" }];
	
	                if (false) {
	                    //this.xrayEnabled
	                    permissions.push({
	                        field: "effectivePermission.managedXrayMeta",
	                        cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managedXrayMeta"),
	                        name: "ManagedXrayMeta",
	                        displayName: "Managed Xray Meta",
	                        width: "15%"
	                    }, {
	                        field: "effectivePermission.managedXrayWatchers",
	                        cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managedXrayWatchers"),
	                        name: "ManagedXrayWatchers",
	                        displayName: "Managed Xray Watchers",
	                        width: "15%" });
	                }
	                return permissions;
	            }
	        },
	        _getPermissionCloumns: {
	            value: function _getPermissionCloumns() {
	
	                var nameCellTemplate = "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" href ui-sref=\"admin.security.permissions.edit({permission: row.entity.permissionName})\">{{row.entity.permissionName}}</a></div>";
	
	                var permissions = [{
	                    field: "permissionName",
	                    name: "Permission Target",
	                    displayName: "Permission Target",
	                    cellTemplate: nameCellTemplate,
	                    width: "20%"
	                }, {
	                    field: "repoKeys",
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.reposList", "row.entity.permissionName", "row.entity.repoKeysView", true),
	                    width: "25%"
	                }, {
	                    field: "effectivePermission.managed",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managed"),
	                    name: "Manage",
	                    displayName: "Manage",
	                    width: "9%"
	                }, {
	                    field: "effectivePermission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.delete"),
	                    name: "Delete/Overwrite",
	                    displayName: "Delete/Overwrite",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.deploy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.deploy"),
	                    name: "Deploy/Cache",
	                    displayName: "Deploy/Cache",
	                    width: "14%"
	                }, {
	                    field: "effectivePermission.annotate",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.annotate"),
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    width: "9%"
	                }, {
	                    field: "effectivePermission.read",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.read"),
	                    name: "Read",
	                    displayName: "Read",
	                    width: "8%"
	                }];
	
	                if (false) {
	                    //this.xrayEnabled
	                    permissions.push({
	                        field: "effectivePermission.managedXrayMeta",
	                        cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managedXrayMeta"),
	                        name: "ManagedXrayMeta",
	                        displayName: "Managed Xray Meta",
	                        width: "8%"
	                    }, {
	                        field: "effectivePermission.managedXrayWatchers",
	                        cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managedXrayWatchers"),
	                        name: "Managed Xray Watchers",
	                        displayName: "Managed Xray Watchers",
	                        width: "8%"
	                    });
	                }
	
	                return permissions;
	            }
	        }
	    });
	
	    return AdminSecurityGroupFormController;
	})();

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminSecurityHttpSSoController = __webpack_require__(249).AdminSecurityHttpSSoController;
	
	function httpSsoConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.http_sso", {
	        params: { feature: "HTTPSSO" },
	        url: "/http_sso",
	        templateUrl: "states/admin/security/http_sso/http_sso.html",
	        controller: "AdminSecurityHttpSSoController as AdminSecurityHttpSSo"
	    });
	}
	
	module.exports = angular.module("security.http_sso", []).config(httpSsoConfig).controller("AdminSecurityHttpSSoController", AdminSecurityHttpSSoController);

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminSecurityHttpSSoController = exports.AdminSecurityHttpSSoController = (function () {
	    function AdminSecurityHttpSSoController(HttpSsoDao, JFrogEventBus, ArtifactoryModelSaver) {
	        _classCallCheck(this, AdminSecurityHttpSSoController);
	
	        this.JFrogEventBus = JFrogEventBus;
	        this.httpSsoDao = HttpSsoDao.getInstance();
	        this.sso = this.getSsoData();
	        this.TOOLTIP = TOOLTIP.admin.security.HTTPSSO;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["sso"]);
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	    }
	
	    _createClass(AdminSecurityHttpSSoController, {
	        getSsoData: {
	            value: function getSsoData() {
	                var _this = this;
	
	                this.httpSsoDao.get().$promise.then(function (sso) {
	                    _this.sso = sso;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	                });
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getSsoData();
	                });
	            }
	        },
	        save: {
	            value: function save(sso) {
	                var _this = this;
	
	                this.httpSsoDao.update(sso).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        }
	    });
	
	    return AdminSecurityHttpSSoController;
	})();

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminSecuritySshServerController = __webpack_require__(251).AdminSecuritySshServerController;
	
	function sshServerConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.ssh_server", {
	        params: { feature: "SSHSERVER" },
	        url: "/ssh_server",
	        templateUrl: "states/admin/security/ssh_server/ssh_server.html",
	        controller: "AdminSecuritySshServerController as AdminSecuritySshServer"
	    });
	}
	
	module.exports = angular.module("security.ssh_server", []).config(sshServerConfig).controller("AdminSecuritySshServerController", AdminSecuritySshServerController);

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var API = _interopRequire(__webpack_require__(98));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminSecuritySshServerController = exports.AdminSecuritySshServerController = (function () {
	    function AdminSecuritySshServerController($timeout, $scope, $state, FileUploader, SshServerDao, JFrogEventBus, ArtifactoryModelSaver, JFrogNotifications, JFrogModal) {
	        _classCallCheck(this, AdminSecuritySshServerController);
	
	        this.$timeout = $timeout;
	        this.$scope = $scope;
	        this.$state = $state;
	        this.FileUploader = FileUploader;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.SshServerDao = SshServerDao.getInstance();
	        this.TOOLTIP = TOOLTIP.admin.security.SSHSERVER;
	        this.modal = JFrogModal;
	
	        // Set flags for case added server keys (prior to upload)
	        this.serverKeysStatuses = {
	            addedPublicKeyFile: false,
	            addedPrivateKeyFile: false
	        };
	
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["sshServer", "serverKeysStatuses"]);
	        this.publicKeyValue = "No public key installed";
	        this.privateKeyValue = "No private key installed";
	        this.NO_VALUE_STRING = "** NO VALUE **";
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        this.getSshData();
	        this.initKeys();
	    }
	
	    _createClass(AdminSecuritySshServerController, {
	        initKeys: {
	            value: function initKeys() {
	                var _this = this;
	
	                this.uploaderPublicKey = new this.FileUploader();
	                this.uploaderPublicKey.onSuccessItem = this.onUploadPublicKeySuccess.bind(this);
	                this.uploaderPublicKey.url = "" + API.API_URL + "/sshserver/install?public=true";
	                this.uploaderPublicKey.headers = { "X-Requested-With": "artUI" };
	                this.uploaderPublicKey.removeAfterUpload = true;
	
	                // Raise flag when adding a public key to input
	                this.uploaderPublicKey.onAfterAddingAll = function (addedItems) {
	                    _this.serverKeysStatuses.addedPublicKeyFile = true;
	                };
	
	                this.uploaderPrivateKey = new this.FileUploader();
	                this.uploaderPrivateKey.url = "" + API.API_URL + "/sshserver/install?public=false";
	                this.uploaderPrivateKey.headers = { "X-Requested-With": "artUI" };
	                this.uploaderPrivateKey.onSuccessItem = this.onUploadPrivateKeySuccess.bind(this);
	                this.uploaderPrivateKey.removeAfterUpload = true;
	
	                // Raise flag when adding a private key to input
	                this.uploaderPrivateKey.onAfterAddingAll = function (addedItems) {
	                    _this.serverKeysStatuses.addedPrivateKeyFile = true;
	                };
	            }
	        },
	        getSshData: {
	            value: function getSshData() {
	                var _this = this;
	
	                var updateKeysStateOnly = arguments[0] === undefined ? false : arguments[0];
	
	                this.SshServerDao.get().$promise.then(function (sshServer) {
	                    if (!updateKeysStateOnly) _this.sshServer = sshServer;
	                    _this.publicKeyInstalled = sshServer.serverKey && sshServer.serverKey.publicKeyInstalled;
	                    _this.privateKeyInstalled = sshServer.serverKey && sshServer.serverKey.privateKeyInstalled;
	                    _this.publicKeyValue = _this.publicKeyInstalled ? "Public key is installed" : "No public key installed";
	                    _this.privateKeyValue = _this.privateKeyInstalled ? "Private key is installed" : "No private key installed";
	                    _this.publicKeyLink = sshServer.serverKey ? sshServer.serverKey.publicKeyLink : undefined;
	                    _this.passPhrase = sshServer.serverKey ? sshServer.serverKey.passPhrase : undefined;
	                    _this.sshServer.customUrlBase = _this.sshServer.customUrlBase || _this.NO_VALUE_STRING;
	                    if (!updateKeysStateOnly) _this.ArtifactoryModelSaver.save();
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	                });
	            }
	        },
	        clearServerKeysInputs: {
	            value: function clearServerKeysInputs() {
	                this.uploaderPrivateKey.clearQueue();
	                this.serverKeysStatuses.addedPrivateKeyFile = false;
	                this.uploaderPublicKey.clearQueue();
	                this.serverKeysStatuses.addedPublicKeyFile = false;
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getSshData();
	                    _this.clearServerKeysInputs();
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.sshServer.enableSshServer && this.sshServer.customUrlBase === this.NO_VALUE_STRING) {
	                    this._showUrlBaseAlert().then(function (gotoGenConf) {
	                        if (gotoGenConf) {
	                            _this.SshServerDao.update(_this.sshServer).$promise.then(function () {
	                                _this.ArtifactoryModelSaver.save();
	                                _this.$state.go("admin.configuration.general", { focusOnBaseUrl: true });
	                            });
	                        } else {
	                            _this.SshServerDao.update(_this.sshServer).$promise.then(function () {
	                                _this.ArtifactoryModelSaver.save();
	                            });
	                        }
	                    });
	                } else {
	                    this.SshServerDao.update(this.sshServer).$promise.then(function () {
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        _showUrlBaseAlert: {
	            value: function _showUrlBaseAlert() {
	                var modalScope = this.$scope.$new();
	                modalScope.context = "ssh";
	                return this.modal.launchModal("base_url_alert_modal", modalScope, "md").result;
	            }
	        },
	        onUploadPublicKeySuccess: {
	            value: function onUploadPublicKeySuccess(fileDetails, response) {
	                this.getSshData(true);
	                this.artifactoryNotifications.create(response.feedbackMsg);
	                this.serverKeysStatuses.addedPublicKeyFile = false;
	            }
	        },
	        onUploadPrivateKeySuccess: {
	            value: function onUploadPrivateKeySuccess(fileDetails, response) {
	                this.getSshData(true);
	                this.artifactoryNotifications.create(response.feedbackMsg);
	                this.serverKeysStatuses.addedPrivateKeyFile = false;
	            }
	        },
	        upload: {
	            value: function upload(type) {
	                if (type === "public") {
	                    this.uploaderPublicKey.queue[0].upload();
	                }
	                if (type === "private") {
	                    this.uploaderPrivateKey.queue[0].upload();
	                }
	            }
	        },
	        removeKey: {
	            value: function removeKey(isPublic) {
	                var _this = this;
	
	                this.SshServerDao["delete"]({ "public": isPublic }).$promise.then(function (result) {
	                    return _this.getSshData(true);
	                });
	            }
	        },
	        verifyPhrase: {
	            value: function verifyPhrase() {
	                var shouldNotify = arguments[0] === undefined ? true : arguments[0];
	
	                var method = shouldNotify ? "post" : "postWithoutNotifications";
	                if (this.SshServerDao[method]) {
	                    return this.SshServerDao[method]({ action: "verify", passPhrase: this.passPhrase }).$promise;
	                }
	            }
	        },
	        updatePhrase: {
	            value: function updatePhrase() {
	                var _this = this;
	
	                var verifyPromise = this.verifyPhrase(false);
	                if (verifyPromise) {
	                    verifyPromise.then(function () {
	                        _this.SshServerDao.put({ action: "update", passPhrase: _this.passPhrase });
	                    })["catch"](function (response) {
	                        return _this.artifactoryNotifications.create(response.data);
	                    });
	                    ;
	                }
	            }
	        },
	        canUploadSshKey: {
	            value: function canUploadSshKey(uploader) {
	                return this[uploader].queue.length;
	            }
	        },
	        canUpdatePhrase: {
	            value: function canUpdatePhrase() {
	                return this.publicKeyInstalled && this.privateKeyInstalled && this.passPhrase;
	            }
	        }
	    });
	
	    return AdminSecuritySshServerController;
	})();

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminSecurityPermissionsController = __webpack_require__(253).AdminSecurityPermissionsController;
	
	var AdminSecurityPermissionsFormController = __webpack_require__(256).AdminSecurityPermissionsFormController;
	
	function permissionsConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.permissions", {
	        url: "/permissions",
	        templateUrl: "states/admin/security/permissions/permissions_new.html",
	        controller: "AdminSecurityPermissionsController as Permissions"
	    }).state("admin.security.permissions.edit", {
	        parent: "admin.security",
	        url: "/permissions/{permission}/edit",
	        templateUrl: "states/admin/security/permissions/permission_form.html",
	        controller: "AdminSecurityPermissionsFormController as PermissionForm"
	    }).state("admin.security.permissions.new", {
	        parent: "admin.security",
	        url: "/permission/new",
	        templateUrl: "states/admin/security/permissions/permission_form.html",
	        controller: "AdminSecurityPermissionsFormController as PermissionForm"
	    });
	}
	
	module.exports = angular.module("security.permissions", []).config(permissionsConfig).controller("AdminSecurityPermissionsController", AdminSecurityPermissionsController).controller("AdminSecurityPermissionsFormController", AdminSecurityPermissionsFormController);

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var assign = __webpack_require__(254).assign;
	
	var AdminSecurityPermissionsController = exports.AdminSecurityPermissionsController = (function () {
	    function AdminSecurityPermissionsController($scope, $state, JFrogGridFactory, PermissionsDao, JFrogModal, uiGridConstants, User, commonGridColumns, JFrogTableViewOptions, $rootScope) {
	        _classCallCheck(this, AdminSecurityPermissionsController);
	
	        this.$state = $state;
	        this.currentTab = "repo";
	        this.modal = JFrogModal;
	        this.permissionsDao = PermissionsDao.getInstance();
	        this.$scope = $scope;
	        this.$rootScope = $rootScope;
	        this.commonGridColumns = commonGridColumns;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.uiGridConstants = uiGridConstants;
	        this.JFrogTableViewOptions = JFrogTableViewOptions;
	        this.user = User.getCurrent();
	        this._createGridNew();
	        // this.initPermission();
	        this.sortState = {};
	    }
	
	    _createClass(AdminSecurityPermissionsController, {
	        _createGridNew: {
	            value: function _createGridNew() {
	                var _this = this;
	
	                var paginationCallback = function (_ref) {
	                    var offset = _ref.offset;
	                    var numOfRows = _ref.numOfRows;
	
	                    if (_this.sorting) {
	                        _this.continueState = null;
	                        _this.sorting = false;
	                    }
	                    var queryParams = assign({}, { limit: 50, continueState: _this.continueState }, _this.sortState);
	                    return _this.permissionsDao.getAll(queryParams).$promise.then(function (response) {
	                        _this.continueState = response.continueState;
	                        _this.showNoDataMessage = !response.data.length;
	                        return assign({}, response, { hasMore: !!response.continueState });
	                    });
	                };
	
	                var externalSortCallback = function (orderBy, direction) {
	                    _this.sortState.direction = direction.toUpperCase();
	                    _this.sorting = true;
	                };
	
	                this.tableViewOptions = new this.JFrogTableViewOptions(this.$scope);
	                this.tableViewOptions.setColumns(this._getColumnsNew()).setRowsPerPage("auto").setSelection(this.tableViewOptions.MULTI_SELECTION).setActions(this._getActions()).setBatchActions(this._getBatchActions()).setEmptyTableText("No permissions").setPaginationMode(this.tableViewOptions.INFINITE_VIRTUAL_SCROLL, paginationCallback).setSortable(true).setNewEntityAction(function () {
	                    //TODO: is admin
	                    if (_this.user.isAdmin()) {
	                        return _this.$state.go("^.permissions.new");
	                    } else {
	                        return null;
	                    }
	                }).useExternalSortCallback(externalSortCallback);
	
	                // this.tableViewOptions.isRowSelectable = (row) => {
	                //     return row.entity.canDelete;
	                // }
	            }
	        },
	        onFilterChange: {
	            value: function onFilterChange() {
	                this.continueState = null;
	                this.sortState.searchStr = this.filter;
	                this.tableViewOptions.dirCtrl.vsApi.reset();
	                this.tableViewOptions.setData([]);
	                this.tableViewOptions.sendInfiniteScrollRequest();
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this._deletePermission(row);
	                    },
	                    visibleWhen: function () {
	                        return _this.user.isAdmin();
	                    }
	                }];
	            }
	        },
	        editPermission: {
	            value: function editPermission(row) {
	                this.$state.go("^.permissions.edit", { permission: row.name });
	            }
	        },
	        _deletePermission: {
	            value: function _deletePermission(row) {
	                var _this = this;
	
	                var json = { permissionTargetNames: [row.name] };
	                this.modal.confirm("Are you sure you want to delete permission '" + row.name + "?'").then(function () {
	                    return _this.permissionsDao.deletePermission(json).$promise.then(function () {
	                        return _this.onFilterChange();
	                    });
	                });
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;
	
	                var selectedRows = this.tableViewOptions.getSelectedRows();
	                var names = _.map(selectedRows, function (row) {
	                    return row.name;
	                });
	                var json = { permissionTargetNames: names };
	                this.modal.confirm("Are you sure you want to delete " + names.length + " permissions?").then(function () {
	                    return _this.permissionsDao.deletePermission(json).$promise.then(function () {
	                        return _this.onFilterChange();
	                    });
	                });
	            }
	        },
	        _getColumnsNew: {
	            value: function _getColumnsNew() {
	                var _this = this;
	
	                var resourcesCellTemplate = "<div class=\"resource-wrapper\">\n                                           <span ng-if=\"row.entity.hasBuilds\">Builds</span>\n                                           <span ng-if=\"row.entity.hasRepos && row.entity.hasBuilds\">,</span>\n                                           <span ng-if=\"row.entity.hasRepos\">Repositories</span>\n                                           <span ng-if=\"row.entity.hasRepos || row.entity.hasBuilds\"><span ng-click=\"grid.appScope.Permissions.showResources(row.entity)\" class=\"jf-link\">(See All)</span></span>\n                                      </div>";
	                return [{
	                    header: "Permission Target Name",
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a href class=\"jf-link\" ng-click=\"grid.appScope.Permissions.editPermission(row.entity)\">{{row.entity.name}}</a></div>",
	                    filterable: true
	                }, {
	                    header: "Resources",
	                    field: "",
	                    cellTemplate: resourcesCellTemplate,
	                    sortable: false,
	                    filterable: false
	                }, {
	                    header: "Groups",
	                    field: "groups",
	                    cellTemplate: this.JFrogTableViewOptions.cellTemplateGenerators.listableColumn("row.entity.groups", "row.entity.name", null, false, null, true, "row.entity.totalGroups"),
	                    asyncDataCallback: function (name) {
	                        return _this.permissionsDao.getEntity({ action: name, name: "groups" }).$promise;
	                    },
	                    sortable: false,
	                    filterable: false
	                }, {
	                    header: "Users",
	                    field: "users",
	                    cellTemplate: this.JFrogTableViewOptions.cellTemplateGenerators.listableColumn("row.entity.users", "row.entity.name", null, false, null, true, "row.entity.totalUsers"),
	                    asyncDataCallback: function (name) {
	                        return _this.permissionsDao.getEntity({ action: name, name: "users" }).$promise;
	                    },
	                    sortable: false,
	                    filterable: false
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    visibleWhen: function () {
	                        return _this.user.isAdmin();
	                    },
	                    callback: function () {
	                        return _this.bulkDelete();
	                    }
	                }];
	            }
	        },
	        showResources: {
	            value: function showResources(resource) {
	                var _this = this;
	
	                var resourcesPromise = this.permissionsDao.getResource({ action: resource.name, name: "resources" }).$promise;
	                resourcesPromise.then(function (response) {
	                    console.log("I am gere");
	                    _this.resourceModalScope = _this.$rootScope.$new();
	                    var selectedRepositories = [];
	                    if (response.repos) {
	                        response.repos.forEach(function (repo) {
	                            selectedRepositories.push(repo);
	                        });
	                    }
	
	                    _this.resourceModalScope.permissionName = resource.name;
	                    _this.resourceModalScope.repos = selectedRepositories;
	
	                    _this.resourceModalScope.tableData = {};
	                    _this.resourceModalScope.tableData = new _this.JFrogTableViewOptions(_this.resourceModalScope);
	                    _this.resourceModalScope.tableData.setColumns(_this._getRepoDataColumns());
	                    _this.resourceModalScope.tableData.setData(_this.resourceModalScope.repos);
	
	                    _this.resourceModalScope.buildExcludePatterns = response.buildExcludePatterns || [];
	                    _this.resourceModalScope.buildIncludePatterns = response.buildIncludePatterns || [];
	
	                    var tabs = [];
	                    if (resource.hasRepos) {
	                        tabs.push({ name: "Repositories" });
	                    }
	                    if (resource.hasBuilds) {
	                        tabs.push({ name: "Builds" });
	                    }
	                    _this.resourceModalScope.tabsDict = {
	                        Repositories: "Repositories",
	                        Builds: "Builds"
	                    };
	
	                    _this.resourceModalScope.tabs = tabs;
	                    _this.modal.launchModal("show_resources_modal", _this.resourceModalScope);
	                });
	            }
	        },
	        _getRepoDataColumns: {
	            value: function _getRepoDataColumns() {
	                return [{
	                    header: "Repository Key",
	                    field: "repoKey",
	                    sortable: true,
	                    filterable: true,
	                    cellTemplate: "<div><i class=\"icon-{{row.entity.type}}-repo\"></i> {{row.entity.repoKey}}</div>"
	                }, {
	                    header: "Type",
	                    field: "type",
	                    sortable: true,
	                    cellTemplate: "<div>{{row.entity.type | capitalize}}</div>"
	                }];
	            }
	        }
	    });
	
	    return AdminSecurityPermissionsController;
	})();

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {"use strict";;(function(){var undefined;var VERSION="4.17.21";var LARGE_ARRAY_SIZE=200;var CORE_ERROR_TEXT="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT="Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT="Invalid `variable` option passed into `_.template`";var HASH_UNDEFINED="__lodash_hash_undefined__";var MAX_MEMOIZE_SIZE=500;var PLACEHOLDER="__lodash_placeholder__";var CLONE_DEEP_FLAG=1, CLONE_FLAT_FLAG=2, CLONE_SYMBOLS_FLAG=4;var COMPARE_PARTIAL_FLAG=1, COMPARE_UNORDERED_FLAG=2;var WRAP_BIND_FLAG=1, WRAP_BIND_KEY_FLAG=2, WRAP_CURRY_BOUND_FLAG=4, WRAP_CURRY_FLAG=8, WRAP_CURRY_RIGHT_FLAG=16, WRAP_PARTIAL_FLAG=32, WRAP_PARTIAL_RIGHT_FLAG=64, WRAP_ARY_FLAG=128, WRAP_REARG_FLAG=256, WRAP_FLIP_FLAG=512;var DEFAULT_TRUNC_LENGTH=30, DEFAULT_TRUNC_OMISSION="...";var HOT_COUNT=800, HOT_SPAN=16;var LAZY_FILTER_FLAG=1, LAZY_MAP_FLAG=2, LAZY_WHILE_FLAG=3;var INFINITY=1 / 0, MAX_SAFE_INTEGER=9007199254740991, MAX_INTEGER=1.7976931348623157e+308, NAN=0 / 0;var MAX_ARRAY_LENGTH=4294967295, MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH >>> 1;var wrapFlags=[["ary", WRAP_ARY_FLAG], ["bind", WRAP_BIND_FLAG], ["bindKey", WRAP_BIND_KEY_FLAG], ["curry", WRAP_CURRY_FLAG], ["curryRight", WRAP_CURRY_RIGHT_FLAG], ["flip", WRAP_FLIP_FLAG], ["partial", WRAP_PARTIAL_FLAG], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG], ["rearg", WRAP_REARG_FLAG]];var argsTag="[object Arguments]", arrayTag="[object Array]", asyncTag="[object AsyncFunction]", boolTag="[object Boolean]", dateTag="[object Date]", domExcTag="[object DOMException]", errorTag="[object Error]", funcTag="[object Function]", genTag="[object GeneratorFunction]", mapTag="[object Map]", numberTag="[object Number]", nullTag="[object Null]", objectTag="[object Object]", promiseTag="[object Promise]", proxyTag="[object Proxy]", regexpTag="[object RegExp]", setTag="[object Set]", stringTag="[object String]", symbolTag="[object Symbol]", undefinedTag="[object Undefined]", weakMapTag="[object WeakMap]", weakSetTag="[object WeakSet]";var arrayBufferTag="[object ArrayBuffer]", dataViewTag="[object DataView]", float32Tag="[object Float32Array]", float64Tag="[object Float64Array]", int8Tag="[object Int8Array]", int16Tag="[object Int16Array]", int32Tag="[object Int32Array]", uint8Tag="[object Uint8Array]", uint8ClampedTag="[object Uint8ClampedArray]", uint16Tag="[object Uint16Array]", uint32Tag="[object Uint32Array]";var reEmptyStringLeading=/\b__p \+= '';/g, reEmptyStringMiddle=/\b(__p \+=) '' \+/g, reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml=/[&<>"']/g, reHasEscapedHtml=RegExp(reEscapedHtml.source), reHasUnescapedHtml=RegExp(reUnescapedHtml.source);var reEscape=/<%-([\s\S]+?)%>/g, reEvaluate=/<%([\s\S]+?)%>/g, reInterpolate=/<%=([\s\S]+?)%>/g;var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp=/^\w*$/, rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;var reRegExpChar=/[\\^$.*+?()[\]{}|]/g, reHasRegExpChar=RegExp(reRegExpChar.source);var reTrimStart=/^\s+/;var reWhitespace=/\s/;var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails=/,? & /;var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;var reEscapeChar=/\\(\\)?/g;var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;var reFlags=/\w*$/;var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;var reIsBinary=/^0b[01]+$/i;var reIsHostCtor=/^\[object .+?Constructor\]$/;var reIsOctal=/^0o[0-7]+$/i;var reIsUint=/^(?:0|[1-9]\d*)$/;var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;var reNoMatch=/($^)/;var reUnescapedString=/['\n\r\u2028\u2029\\]/g;var rsAstralRange="\\ud800-\\udfff", rsComboMarksRange="\\u0300-\\u036f", reComboHalfMarksRange="\\ufe20-\\ufe2f", rsComboSymbolsRange="\\u20d0-\\u20ff", rsComboRange=rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange="\\u2700-\\u27bf", rsLowerRange="a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange="\\xac\\xb1\\xd7\\xf7", rsNonCharRange="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange="\\u2000-\\u206f", rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange="A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange="\\ufe0e\\ufe0f", rsBreakRange=rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;var rsApos="['’]", rsAstral="[" + rsAstralRange + "]", rsBreak="[" + rsBreakRange + "]", rsCombo="[" + rsComboRange + "]", rsDigits="\\d+", rsDingbat="[" + rsDingbatRange + "]", rsLower="[" + rsLowerRange + "]", rsMisc="[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz="\\ud83c[\\udffb-\\udfff]", rsModifier="(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral="[^" + rsAstralRange + "]", rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper="[" + rsUpperRange + "]", rsZWJ="\\u200d";var rsMiscLower="(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper="(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower="(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper="(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod=rsModifier + "?", rsOptVar="[" + rsVarRange + "]?", rsOptJoin="(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq=rsOptVar + reOptMod + rsOptJoin, rsEmoji="(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol="(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";var reApos=RegExp(rsApos, "g");var reComboMark=RegExp(rsCombo, "g");var reUnicode=RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");var reUnicodeWord=RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");var reHasUnicode=RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;var contextProps=["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"];var templateCounter=-1;var typedArrayTags={};typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;var cloneableTags={};cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;var deburredLetters={À:"A", Á:"A", Â:"A", Ã:"A", Ä:"A", Å:"A", à:"a", á:"a", â:"a", ã:"a", ä:"a", å:"a", Ç:"C", ç:"c", Ð:"D", ð:"d", È:"E", É:"E", Ê:"E", Ë:"E", è:"e", é:"e", ê:"e", ë:"e", Ì:"I", Í:"I", Î:"I", Ï:"I", ì:"i", í:"i", î:"i", ï:"i", Ñ:"N", ñ:"n", Ò:"O", Ó:"O", Ô:"O", Õ:"O", Ö:"O", Ø:"O", ò:"o", ó:"o", ô:"o", õ:"o", ö:"o", ø:"o", Ù:"U", Ú:"U", Û:"U", Ü:"U", ù:"u", ú:"u", û:"u", ü:"u", Ý:"Y", ý:"y", ÿ:"y", Æ:"Ae", æ:"ae", Þ:"Th", þ:"th", ß:"ss", Ā:"A", Ă:"A", Ą:"A", ā:"a", ă:"a", ą:"a", Ć:"C", Ĉ:"C", Ċ:"C", Č:"C", ć:"c", ĉ:"c", ċ:"c", č:"c", Ď:"D", Đ:"D", ď:"d", đ:"d", Ē:"E", Ĕ:"E", Ė:"E", Ę:"E", Ě:"E", ē:"e", ĕ:"e", ė:"e", ę:"e", ě:"e", Ĝ:"G", Ğ:"G", Ġ:"G", Ģ:"G", ĝ:"g", ğ:"g", ġ:"g", ģ:"g", Ĥ:"H", Ħ:"H", ĥ:"h", ħ:"h", Ĩ:"I", Ī:"I", Ĭ:"I", Į:"I", İ:"I", ĩ:"i", ī:"i", ĭ:"i", į:"i", ı:"i", Ĵ:"J", ĵ:"j", Ķ:"K", ķ:"k", ĸ:"k", Ĺ:"L", Ļ:"L", Ľ:"L", Ŀ:"L", Ł:"L", ĺ:"l", ļ:"l", ľ:"l", ŀ:"l", ł:"l", Ń:"N", Ņ:"N", Ň:"N", Ŋ:"N", ń:"n", ņ:"n", ň:"n", ŋ:"n", Ō:"O", Ŏ:"O", Ő:"O", ō:"o", ŏ:"o", ő:"o", Ŕ:"R", Ŗ:"R", Ř:"R", ŕ:"r", ŗ:"r", ř:"r", Ś:"S", Ŝ:"S", Ş:"S", Š:"S", ś:"s", ŝ:"s", ş:"s", š:"s", Ţ:"T", Ť:"T", Ŧ:"T", ţ:"t", ť:"t", ŧ:"t", Ũ:"U", Ū:"U", Ŭ:"U", Ů:"U", Ű:"U", Ų:"U", ũ:"u", ū:"u", ŭ:"u", ů:"u", ű:"u", ų:"u", Ŵ:"W", ŵ:"w", Ŷ:"Y", ŷ:"y", Ÿ:"Y", Ź:"Z", Ż:"Z", Ž:"Z", ź:"z", ż:"z", ž:"z", Ĳ:"IJ", ĳ:"ij", Œ:"Oe", œ:"oe", ŉ:"'n", ſ:"s"};var htmlEscapes={"&":"&amp;", "<":"&lt;", ">":"&gt;", "\"":"&quot;", "'":"&#39;"};var htmlUnescapes={"&amp;":"&", "&lt;":"<", "&gt;":">", "&quot;":"\"", "&#39;":"'"};var stringEscapes={"\\":"\\", "'":"'", "\n":"n", "\r":"r", "\u2028":"u2028", "\u2029":"u2029"};var freeParseFloat=parseFloat, freeParseInt=parseInt;var freeGlobal=typeof global == "object" && global && global.Object === Object && global;var freeSelf=typeof self == "object" && self && self.Object === Object && self;var root=freeGlobal || freeSelf || Function("return this")();var freeExports=typeof exports == "object" && exports && !exports.nodeType && exports;var freeModule=freeExports && typeof module == "object" && module && !module.nodeType && module;var moduleExports=freeModule && freeModule.exports === freeExports;var freeProcess=moduleExports && freeGlobal.process;var nodeUtil=(function(){try{var types=freeModule && freeModule.require && freeModule.require("util").types;if(types){return types;}return freeProcess && freeProcess.binding && freeProcess.binding("util");}catch(e) {}})();var nodeIsArrayBuffer=nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate=nodeUtil && nodeUtil.isDate, nodeIsMap=nodeUtil && nodeUtil.isMap, nodeIsRegExp=nodeUtil && nodeUtil.isRegExp, nodeIsSet=nodeUtil && nodeUtil.isSet, nodeIsTypedArray=nodeUtil && nodeUtil.isTypedArray;function apply(func, thisArg, args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg, args[0]);case 2:return func.call(thisArg, args[0], args[1]);case 3:return func.call(thisArg, args[0], args[1], args[2]);}return func.apply(thisArg, args);}function arrayAggregator(array, setter, iteratee, accumulator){var index=-1, length=array == null?0:array.length;while(++index < length) {var value=array[index];setter(accumulator, value, iteratee(value), array);}return accumulator;}function arrayEach(array, iteratee){var index=-1, length=array == null?0:array.length;while(++index < length) {if(iteratee(array[index], index, array) === false){break;}}return array;}function arrayEachRight(array, iteratee){var length=array == null?0:array.length;while(length--) {if(iteratee(array[length], length, array) === false){break;}}return array;}function arrayEvery(array, predicate){var index=-1, length=array == null?0:array.length;while(++index < length) {if(!predicate(array[index], index, array)){return false;}}return true;}function arrayFilter(array, predicate){var index=-1, length=array == null?0:array.length, resIndex=0, result=[];while(++index < length) {var value=array[index];if(predicate(value, index, array)){result[resIndex++] = value;}}return result;}function arrayIncludes(array, value){var length=array == null?0:array.length;return !!length && baseIndexOf(array, value, 0) > -1;}function arrayIncludesWith(array, value, comparator){var index=-1, length=array == null?0:array.length;while(++index < length) {if(comparator(value, array[index])){return true;}}return false;}function arrayMap(array, iteratee){var index=-1, length=array == null?0:array.length, result=Array(length);while(++index < length) {result[index] = iteratee(array[index], index, array);}return result;}function arrayPush(array, values){var index=-1, length=values.length, offset=array.length;while(++index < length) {array[offset + index] = values[index];}return array;}function arrayReduce(array, iteratee, accumulator, initAccum){var index=-1, length=array == null?0:array.length;if(initAccum && length){accumulator = array[++index];}while(++index < length) {accumulator = iteratee(accumulator, array[index], index, array);}return accumulator;}function arrayReduceRight(array, iteratee, accumulator, initAccum){var length=array == null?0:array.length;if(initAccum && length){accumulator = array[--length];}while(length--) {accumulator = iteratee(accumulator, array[length], length, array);}return accumulator;}function arraySome(array, predicate){var index=-1, length=array == null?0:array.length;while(++index < length) {if(predicate(array[index], index, array)){return true;}}return false;}var asciiSize=baseProperty("length");function asciiToArray(string){return string.split("");}function asciiWords(string){return string.match(reAsciiWord) || [];}function baseFindKey(collection, predicate, eachFunc){var result;eachFunc(collection, function(value, key, collection){if(predicate(value, key, collection)){result = key;return false;}});return result;}function baseFindIndex(array, predicate, fromIndex, fromRight){var length=array.length, index=fromIndex + (fromRight?1:-1);while(fromRight?index--:++index < length) {if(predicate(array[index], index, array)){return index;}}return -1;}function baseIndexOf(array, value, fromIndex){return value === value?strictIndexOf(array, value, fromIndex):baseFindIndex(array, baseIsNaN, fromIndex);}function baseIndexOfWith(array, value, fromIndex, comparator){var index=fromIndex - 1, length=array.length;while(++index < length) {if(comparator(array[index], value)){return index;}}return -1;}function baseIsNaN(value){return value !== value;}function baseMean(array, iteratee){var length=array == null?0:array.length;return length?baseSum(array, iteratee) / length:NAN;}function baseProperty(key){return function(object){return object == null?undefined:object[key];};}function basePropertyOf(object){return function(key){return object == null?undefined:object[key];};}function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc){eachFunc(collection, function(value, index, collection){accumulator = initAccum?(initAccum = false, value):iteratee(accumulator, value, index, collection);});return accumulator;}function baseSortBy(array, comparer){var length=array.length;array.sort(comparer);while(length--) {array[length] = array[length].value;}return array;}function baseSum(array, iteratee){var result, index=-1, length=array.length;while(++index < length) {var current=iteratee(array[index]);if(current !== undefined){result = result === undefined?current:result + current;}}return result;}function baseTimes(n, iteratee){var index=-1, result=Array(n);while(++index < n) {result[index] = iteratee(index);}return result;}function baseToPairs(object, props){return arrayMap(props, function(key){return [key, object[key]];});}function baseTrim(string){return string?string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, ""):string;}function baseUnary(func){return function(value){return func(value);};}function baseValues(object, props){return arrayMap(props, function(key){return object[key];});}function cacheHas(cache, key){return cache.has(key);}function charsStartIndex(strSymbols, chrSymbols){var index=-1, length=strSymbols.length;while(++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}return index;}function charsEndIndex(strSymbols, chrSymbols){var index=strSymbols.length;while(index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}return index;}function countHolders(array, placeholder){var length=array.length, result=0;while(length--) {if(array[length] === placeholder){++result;}}return result;}var deburrLetter=basePropertyOf(deburredLetters);var escapeHtmlChar=basePropertyOf(htmlEscapes);function escapeStringChar(chr){return "\\" + stringEscapes[chr];}function getValue(object, key){return object == null?undefined:object[key];}function hasUnicode(string){return reHasUnicode.test(string);}function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}function iteratorToArray(iterator){var data, result=[];while(!(data = iterator.next()).done) {result.push(data.value);}return result;}function mapToArray(map){var index=-1, result=Array(map.size);map.forEach(function(value, key){result[++index] = [key, value];});return result;}function overArg(func, transform){return function(arg){return func(transform(arg));};}function replaceHolders(array, placeholder){var index=-1, length=array.length, resIndex=0, result=[];while(++index < length) {var value=array[index];if(value === placeholder || value === PLACEHOLDER){array[index] = PLACEHOLDER;result[resIndex++] = index;}}return result;}function setToArray(set){var index=-1, result=Array(set.size);set.forEach(function(value){result[++index] = value;});return result;}function setToPairs(set){var index=-1, result=Array(set.size);set.forEach(function(value){result[++index] = [value, value];});return result;}function strictIndexOf(array, value, fromIndex){var index=fromIndex - 1, length=array.length;while(++index < length) {if(array[index] === value){return index;}}return -1;}function strictLastIndexOf(array, value, fromIndex){var index=fromIndex + 1;while(index--) {if(array[index] === value){return index;}}return index;}function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}function trimmedEndIndex(string){var index=string.length;while(index-- && reWhitespace.test(string.charAt(index))) {}return index;}var unescapeHtmlChar=basePropertyOf(htmlUnescapes);function unicodeSize(string){var result=reUnicode.lastIndex = 0;while(reUnicode.test(string)) {++result;}return result;}function unicodeToArray(string){return string.match(reUnicode) || [];}function unicodeWords(string){return string.match(reUnicodeWord) || [];}var runInContext=function runInContext(context){context = context == null?root:_.defaults(root.Object(), context, _.pick(root, contextProps));var Array=context.Array, Date=context.Date, Error=context.Error, Function=context.Function, Math=context.Math, Object=context.Object, RegExp=context.RegExp, String=context.String, TypeError=context.TypeError;var arrayProto=Array.prototype, funcProto=Function.prototype, objectProto=Object.prototype;var coreJsData=context["__core-js_shared__"];var funcToString=funcProto.toString;var hasOwnProperty=objectProto.hasOwnProperty;var idCounter=0;var maskSrcKey=(function(){var uid=/[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");return uid?"Symbol(src)_1." + uid:"";})();var nativeObjectToString=objectProto.toString;var objectCtorString=funcToString.call(Object);var oldDash=root._;var reIsNative=RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");var Buffer=moduleExports?context.Buffer:undefined, Symbol=context.Symbol, Uint8Array=context.Uint8Array, allocUnsafe=Buffer?Buffer.allocUnsafe:undefined, getPrototype=overArg(Object.getPrototypeOf, Object), objectCreate=Object.create, propertyIsEnumerable=objectProto.propertyIsEnumerable, splice=arrayProto.splice, spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined, symIterator=Symbol?Symbol.iterator:undefined, symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=(function(){try{var func=getNative(Object, "defineProperty");func({}, "", {});return func;}catch(e) {}})();var ctxClearTimeout=context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow=Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout=context.setTimeout !== root.setTimeout && context.setTimeout;var nativeCeil=Math.ceil, nativeFloor=Math.floor, nativeGetSymbols=Object.getOwnPropertySymbols, nativeIsBuffer=Buffer?Buffer.isBuffer:undefined, nativeIsFinite=context.isFinite, nativeJoin=arrayProto.join, nativeKeys=overArg(Object.keys, Object), nativeMax=Math.max, nativeMin=Math.min, nativeNow=Date.now, nativeParseInt=context.parseInt, nativeRandom=Math.random, nativeReverse=arrayProto.reverse;var DataView=getNative(context, "DataView"), Map=getNative(context, "Map"), Promise=getNative(context, "Promise"), Set=getNative(context, "Set"), WeakMap=getNative(context, "WeakMap"), nativeCreate=getNative(Object, "create");var metaMap=WeakMap && new WeakMap();var realNames={};var dataViewCtorString=toSource(DataView), mapCtorString=toSource(Map), promiseCtorString=toSource(Promise), setCtorString=toSource(Set), weakMapCtorString=toSource(WeakMap);var symbolProto=Symbol?Symbol.prototype:undefined, symbolValueOf=symbolProto?symbolProto.valueOf:undefined, symbolToString=symbolProto?symbolProto.toString:undefined;function lodash(value){if(isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value, "__wrapped__")){return wrapperClone(value);}}return new LodashWrapper(value);}var baseCreate=(function(){function object(){}return function(proto){if(!isObject(proto)){return {};}if(objectCreate){return objectCreate(proto);}object.prototype = proto;var result=new object();object.prototype = undefined;return result;};})();function baseLodash(){}function LodashWrapper(value, chainAll){this.__wrapped__ = value;this.__actions__ = [];this.__chain__ = !!chainAll;this.__index__ = 0;this.__values__ = undefined;}lodash.templateSettings = {escape:reEscape, evaluate:reEvaluate, interpolate:reInterpolate, variable:"", imports:{_:lodash}};lodash.prototype = baseLodash.prototype;lodash.prototype.constructor = lodash;LodashWrapper.prototype = baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor = LodashWrapper;function LazyWrapper(value){this.__wrapped__ = value;this.__actions__ = [];this.__dir__ = 1;this.__filtered__ = false;this.__iteratees__ = [];this.__takeCount__ = MAX_ARRAY_LENGTH;this.__views__ = [];}function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__ = copyArray(this.__actions__);result.__dir__ = this.__dir__;result.__filtered__ = this.__filtered__;result.__iteratees__ = copyArray(this.__iteratees__);result.__takeCount__ = this.__takeCount__;result.__views__ = copyArray(this.__views__);return result;}function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__ = -1;result.__filtered__ = true;}else {result = this.clone();result.__dir__ *= -1;}return result;}function lazyValue(){var array=this.__wrapped__.value(), dir=this.__dir__, isArr=isArray(array), isRight=dir < 0, arrLength=isArr?array.length:0, view=getView(0, arrLength, this.__views__), start=view.start, end=view.end, length=end - start, index=isRight?end:start - 1, iteratees=this.__iteratees__, iterLength=iteratees.length, resIndex=0, takeCount=nativeMin(length, this.__takeCount__);if(!isArr || !isRight && arrLength == length && takeCount == length){return baseWrapperValue(array, this.__actions__);}var result=[];outer: while(length-- && resIndex < takeCount) {index += dir;var iterIndex=-1, value=array[index];while(++iterIndex < iterLength) {var data=iteratees[iterIndex], iteratee=data.iteratee, type=data.type, computed=iteratee(value);if(type == LAZY_MAP_FLAG){value = computed;}else if(!computed){if(type == LAZY_FILTER_FLAG){continue outer;}else {break outer;}}}result[resIndex++] = value;}return result;}LazyWrapper.prototype = baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor = LazyWrapper;function Hash(entries){var index=-1, length=entries == null?0:entries.length;this.clear();while(++index < length) {var entry=entries[index];this.set(entry[0], entry[1]);}}function hashClear(){this.__data__ = nativeCreate?nativeCreate(null):{};this.size = 0;}function hashDelete(key){var result=this.has(key) && delete this.__data__[key];this.size -= result?1:0;return result;}function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result === HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data, key)?data[key]:undefined;}function hashHas(key){var data=this.__data__;return nativeCreate?data[key] !== undefined:hasOwnProperty.call(data, key);}function hashSet(key, value){var data=this.__data__;this.size += this.has(key)?0:1;data[key] = nativeCreate && value === undefined?HASH_UNDEFINED:value;return this;}Hash.prototype.clear = hashClear;Hash.prototype["delete"] = hashDelete;Hash.prototype.get = hashGet;Hash.prototype.has = hashHas;Hash.prototype.set = hashSet;function ListCache(entries){var index=-1, length=entries == null?0:entries.length;this.clear();while(++index < length) {var entry=entries[index];this.set(entry[0], entry[1]);}}function listCacheClear(){this.__data__ = [];this.size = 0;}function listCacheDelete(key){var data=this.__data__, index=assocIndexOf(data, key);if(index < 0){return false;}var lastIndex=data.length - 1;if(index == lastIndex){data.pop();}else {splice.call(data, index, 1);}--this.size;return true;}function listCacheGet(key){var data=this.__data__, index=assocIndexOf(data, key);return index < 0?undefined:data[index][1];}function listCacheHas(key){return assocIndexOf(this.__data__, key) > -1;}function listCacheSet(key, value){var data=this.__data__, index=assocIndexOf(data, key);if(index < 0){++this.size;data.push([key, value]);}else {data[index][1] = value;}return this;}ListCache.prototype.clear = listCacheClear;ListCache.prototype["delete"] = listCacheDelete;ListCache.prototype.get = listCacheGet;ListCache.prototype.has = listCacheHas;ListCache.prototype.set = listCacheSet;function MapCache(entries){var index=-1, length=entries == null?0:entries.length;this.clear();while(++index < length) {var entry=entries[index];this.set(entry[0], entry[1]);}}function mapCacheClear(){this.size = 0;this.__data__ = {hash:new Hash(), map:new (Map || ListCache)(), string:new Hash()};}function mapCacheDelete(key){var result=getMapData(this, key)["delete"](key);this.size -= result?1:0;return result;}function mapCacheGet(key){return getMapData(this, key).get(key);}function mapCacheHas(key){return getMapData(this, key).has(key);}function mapCacheSet(key, value){var data=getMapData(this, key), size=data.size;data.set(key, value);this.size += data.size == size?0:1;return this;}MapCache.prototype.clear = mapCacheClear;MapCache.prototype["delete"] = mapCacheDelete;MapCache.prototype.get = mapCacheGet;MapCache.prototype.has = mapCacheHas;MapCache.prototype.set = mapCacheSet;function SetCache(values){var index=-1, length=values == null?0:values.length;this.__data__ = new MapCache();while(++index < length) {this.add(values[index]);}}function setCacheAdd(value){this.__data__.set(value, HASH_UNDEFINED);return this;}function setCacheHas(value){return this.__data__.has(value);}SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;SetCache.prototype.has = setCacheHas;function Stack(entries){var data=this.__data__ = new ListCache(entries);this.size = data.size;}function stackClear(){this.__data__ = new ListCache();this.size = 0;}function stackDelete(key){var data=this.__data__, result=data["delete"](key);this.size = data.size;return result;}function stackGet(key){return this.__data__.get(key);}function stackHas(key){return this.__data__.has(key);}function stackSet(key, value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map || pairs.length < LARGE_ARRAY_SIZE - 1){pairs.push([key, value]);this.size = ++data.size;return this;}data = this.__data__ = new MapCache(pairs);}data.set(key, value);this.size = data.size;return this;}Stack.prototype.clear = stackClear;Stack.prototype["delete"] = stackDelete;Stack.prototype.get = stackGet;Stack.prototype.has = stackHas;Stack.prototype.set = stackSet;function arrayLikeKeys(value, inherited){var isArr=isArray(value), isArg=!isArr && isArguments(value), isBuff=!isArr && !isArg && isBuffer(value), isType=!isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes=isArr || isArg || isBuff || isType, result=skipIndexes?baseTimes(value.length, String):[], length=result.length;for(var key in value) {if((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))){result.push(key);}}return result;}function arraySample(array){var length=array.length;return length?array[baseRandom(0, length - 1)]:undefined;}function arraySampleSize(array, n){return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));}function arrayShuffle(array){return shuffleSelf(copyArray(array));}function assignMergeValue(object, key, value){if(value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)){baseAssignValue(object, key, value);}}function assignValue(object, key, value){var objValue=object[key];if(!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)){baseAssignValue(object, key, value);}}function assocIndexOf(array, key){var length=array.length;while(length--) {if(eq(array[length][0], key)){return length;}}return -1;}function baseAggregator(collection, setter, iteratee, accumulator){baseEach(collection, function(value, key, collection){setter(accumulator, value, iteratee(value), collection);});return accumulator;}function baseAssign(object, source){return object && copyObject(source, keys(source), object);}function baseAssignIn(object, source){return object && copyObject(source, keysIn(source), object);}function baseAssignValue(object, key, value){if(key == "__proto__" && defineProperty){defineProperty(object, key, {configurable:true, enumerable:true, value:value, writable:true});}else {object[key] = value;}}function baseAt(object, paths){var index=-1, length=paths.length, result=Array(length), skip=object == null;while(++index < length) {result[index] = skip?undefined:get(object, paths[index]);}return result;}function baseClamp(number, lower, upper){if(number === number){if(upper !== undefined){number = number <= upper?number:upper;}if(lower !== undefined){number = number >= lower?number:lower;}}return number;}function baseClone(value, bitmask, customizer, key, object, stack){var result, isDeep=bitmask & CLONE_DEEP_FLAG, isFlat=bitmask & CLONE_FLAT_FLAG, isFull=bitmask & CLONE_SYMBOLS_FLAG;if(customizer){result = object?customizer(value, key, object, stack):customizer(value);}if(result !== undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result = initCloneArray(value);if(!isDeep){return copyArray(value, result);}}else {var tag=getTag(value), isFunc=tag == funcTag || tag == genTag;if(isBuffer(value)){return cloneBuffer(value, isDeep);}if(tag == objectTag || tag == argsTag || isFunc && !object){result = isFlat || isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value, baseAssignIn(result, value)):copySymbols(value, baseAssign(result, value));}}else {if(!cloneableTags[tag]){return object?value:{};}result = initCloneByTag(value, tag, isDeep);}}stack || (stack = new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value, result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));});}else if(isMap(value)){value.forEach(function(subValue, key){result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props || value, function(subValue, key){if(props){key = subValue;subValue = value[key];}assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));});return result;}function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object, source, props);};}function baseConformsTo(object, source, props){var length=props.length;if(object == null){return !length;}object = Object(object);while(length--) {var key=props[length], predicate=source[key], value=object[key];if(value === undefined && !(key in object) || !predicate(value)){return false;}}return true;}function baseDelay(func, wait, args){if(typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined, args);}, wait);}function baseDifference(array, values, iteratee, comparator){var index=-1, includes=arrayIncludes, isCommon=true, length=array.length, result=[], valuesLength=values.length;if(!length){return result;}if(iteratee){values = arrayMap(values, baseUnary(iteratee));}if(comparator){includes = arrayIncludesWith;isCommon = false;}else if(values.length >= LARGE_ARRAY_SIZE){includes = cacheHas;isCommon = false;values = new SetCache(values);}outer: while(++index < length) {var value=array[index], computed=iteratee == null?value:iteratee(value);value = comparator || value !== 0?value:0;if(isCommon && computed === computed){var valuesIndex=valuesLength;while(valuesIndex--) {if(values[valuesIndex] === computed){continue outer;}}result.push(value);}else if(!includes(values, computed, comparator)){result.push(value);}}return result;}var baseEach=createBaseEach(baseForOwn);var baseEachRight=createBaseEach(baseForOwnRight, true);function baseEvery(collection, predicate){var result=true;baseEach(collection, function(value, index, collection){result = !!predicate(value, index, collection);return result;});return result;}function baseExtremum(array, iteratee, comparator){var index=-1, length=array.length;while(++index < length) {var value=array[index], current=iteratee(value);if(current != null && (computed === undefined?current === current && !isSymbol(current):comparator(current, computed))){var computed=current, result=value;}}return result;}function baseFill(array, value, start, end){var length=array.length;start = toInteger(start);if(start < 0){start = -start > length?0:length + start;}end = end === undefined || end > length?length:toInteger(end);if(end < 0){end += length;}end = start > end?0:toLength(end);while(start < end) {array[start++] = value;}return array;}function baseFilter(collection, predicate){var result=[];baseEach(collection, function(value, index, collection){if(predicate(value, index, collection)){result.push(value);}});return result;}function baseFlatten(array, depth, predicate, isStrict, result){var index=-1, length=array.length;predicate || (predicate = isFlattenable);result || (result = []);while(++index < length) {var value=array[index];if(depth > 0 && predicate(value)){if(depth > 1){baseFlatten(value, depth - 1, predicate, isStrict, result);}else {arrayPush(result, value);}}else if(!isStrict){result[result.length] = value;}}return result;}var baseFor=createBaseFor();var baseForRight=createBaseFor(true);function baseForOwn(object, iteratee){return object && baseFor(object, iteratee, keys);}function baseForOwnRight(object, iteratee){return object && baseForRight(object, iteratee, keys);}function baseFunctions(object, props){return arrayFilter(props, function(key){return isFunction(object[key]);});}function baseGet(object, path){path = castPath(path, object);var index=0, length=path.length;while(object != null && index < length) {object = object[toKey(path[index++])];}return index && index == length?object:undefined;}function baseGetAllKeys(object, keysFunc, symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result, symbolsFunc(object));}function baseGetTag(value){if(value == null){return value === undefined?undefinedTag:nullTag;}return symToStringTag && symToStringTag in Object(value)?getRawTag(value):objectToString(value);}function baseGt(value, other){return value > other;}function baseHas(object, key){return object != null && hasOwnProperty.call(object, key);}function baseHasIn(object, key){return object != null && key in Object(object);}function baseInRange(number, start, end){return number >= nativeMin(start, end) && number < nativeMax(start, end);}function baseIntersection(arrays, iteratee, comparator){var includes=comparator?arrayIncludesWith:arrayIncludes, length=arrays[0].length, othLength=arrays.length, othIndex=othLength, caches=Array(othLength), maxLength=Infinity, result=[];while(othIndex--) {var array=arrays[othIndex];if(othIndex && iteratee){array = arrayMap(array, baseUnary(iteratee));}maxLength = nativeMin(array.length, maxLength);caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120)?new SetCache(othIndex && array):undefined;}array = arrays[0];var index=-1, seen=caches[0];outer: while(++index < length && result.length < maxLength) {var value=array[index], computed=iteratee?iteratee(value):value;value = comparator || value !== 0?value:0;if(!(seen?cacheHas(seen, computed):includes(result, computed, comparator))){othIndex = othLength;while(--othIndex) {var cache=caches[othIndex];if(!(cache?cacheHas(cache, computed):includes(arrays[othIndex], computed, comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}function baseInverter(object, setter, iteratee, accumulator){baseForOwn(object, function(value, key, object){setter(accumulator, iteratee(value), key, object);});return accumulator;}function baseInvoke(object, path, args){path = castPath(path, object);object = parent(object, path);var func=object == null?object:object[toKey(last(path))];return func == null?undefined:apply(func, object, args);}function baseIsArguments(value){return isObjectLike(value) && baseGetTag(value) == argsTag;}function baseIsArrayBuffer(value){return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;}function baseIsDate(value){return isObjectLike(value) && baseGetTag(value) == dateTag;}function baseIsEqual(value, other, bitmask, customizer, stack){if(value === other){return true;}if(value == null || other == null || !isObjectLike(value) && !isObjectLike(other)){return value !== value && other !== other;}return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);}function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack){var objIsArr=isArray(object), othIsArr=isArray(other), objTag=objIsArr?arrayTag:getTag(object), othTag=othIsArr?arrayTag:getTag(other);objTag = objTag == argsTag?objectTag:objTag;othTag = othTag == argsTag?objectTag:othTag;var objIsObj=objTag == objectTag, othIsObj=othTag == objectTag, isSameTag=objTag == othTag;if(isSameTag && isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr = true;objIsObj = false;}if(isSameTag && !objIsObj){stack || (stack = new Stack());return objIsArr || isTypedArray(object)?equalArrays(object, other, bitmask, customizer, equalFunc, stack):equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);}if(!(bitmask & COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped=othIsObj && hasOwnProperty.call(other, "__wrapped__");if(objIsWrapped || othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object, othUnwrapped=othIsWrapped?other.value():other;stack || (stack = new Stack());return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);}}if(!isSameTag){return false;}stack || (stack = new Stack());return equalObjects(object, other, bitmask, customizer, equalFunc, stack);}function baseIsMap(value){return isObjectLike(value) && getTag(value) == mapTag;}function baseIsMatch(object, source, matchData, customizer){var index=matchData.length, length=index, noCustomizer=!customizer;if(object == null){return !length;}object = Object(object);while(index--) {var data=matchData[index];if(noCustomizer && data[2]?data[1] !== object[data[0]]:!(data[0] in object)){return false;}}while(++index < length) {data = matchData[index];var key=data[0], objValue=object[key], srcValue=data[1];if(noCustomizer && data[2]){if(objValue === undefined && !(key in object)){return false;}}else {var stack=new Stack();if(customizer){var result=customizer(objValue, srcValue, key, object, source, stack);}if(!(result === undefined?baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack):result)){return false;}}}return true;}function baseIsNative(value){if(!isObject(value) || isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}function baseIsRegExp(value){return isObjectLike(value) && baseGetTag(value) == regexpTag;}function baseIsSet(value){return isObjectLike(value) && getTag(value) == setTag;}function baseIsTypedArray(value){return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];}function baseIteratee(value){if(typeof value == "function"){return value;}if(value == null){return identity;}if(typeof value == "object"){return isArray(value)?baseMatchesProperty(value[0], value[1]):baseMatches(value);}return property(value);}function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)) {if(hasOwnProperty.call(object, key) && key != "constructor"){result.push(key);}}return result;}function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object), result=[];for(var key in object) {if(!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))){result.push(key);}}return result;}function baseLt(value, other){return value < other;}function baseMap(collection, iteratee){var index=-1, result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection, function(value, key, collection){result[++index] = iteratee(value, key, collection);});return result;}function baseMatches(source){var matchData=getMatchData(source);if(matchData.length == 1 && matchData[0][2]){return matchesStrictComparable(matchData[0][0], matchData[0][1]);}return function(object){return object === source || baseIsMatch(object, source, matchData);};}function baseMatchesProperty(path, srcValue){if(isKey(path) && isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path), srcValue);}return function(object){var objValue=get(object, path);return objValue === undefined && objValue === srcValue?hasIn(object, path):baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);};}function baseMerge(object, source, srcIndex, customizer, stack){if(object === source){return;}baseFor(source, function(srcValue, key){stack || (stack = new Stack());if(isObject(srcValue)){baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);}else {var newValue=customizer?customizer(safeGet(object, key), srcValue, key + "", object, source, stack):undefined;if(newValue === undefined){newValue = srcValue;}assignMergeValue(object, key, newValue);}}, keysIn);}function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack){var objValue=safeGet(object, key), srcValue=safeGet(source, key), stacked=stack.get(srcValue);if(stacked){assignMergeValue(object, key, stacked);return;}var newValue=customizer?customizer(objValue, srcValue, key + "", object, source, stack):undefined;var isCommon=newValue === undefined;if(isCommon){var isArr=isArray(srcValue), isBuff=!isArr && isBuffer(srcValue), isTyped=!isArr && !isBuff && isTypedArray(srcValue);newValue = srcValue;if(isArr || isBuff || isTyped){if(isArray(objValue)){newValue = objValue;}else if(isArrayLikeObject(objValue)){newValue = copyArray(objValue);}else if(isBuff){isCommon = false;newValue = cloneBuffer(srcValue, true);}else if(isTyped){isCommon = false;newValue = cloneTypedArray(srcValue, true);}else {newValue = [];}}else if(isPlainObject(srcValue) || isArguments(srcValue)){newValue = objValue;if(isArguments(objValue)){newValue = toPlainObject(objValue);}else if(!isObject(objValue) || isFunction(objValue)){newValue = initCloneObject(srcValue);}}else {isCommon = false;}}if(isCommon){stack.set(srcValue, newValue);mergeFunc(newValue, srcValue, srcIndex, customizer, stack);stack["delete"](srcValue);}assignMergeValue(object, key, newValue);}function baseNth(array, n){var length=array.length;if(!length){return;}n += n < 0?length:0;return isIndex(n, length)?array[n]:undefined;}function baseOrderBy(collection, iteratees, orders){if(iteratees.length){iteratees = arrayMap(iteratees, function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value, iteratee.length === 1?iteratee[0]:iteratee);};}return iteratee;});}else {iteratees = [identity];}var index=-1;iteratees = arrayMap(iteratees, baseUnary(getIteratee()));var result=baseMap(collection, function(value, key, collection){var criteria=arrayMap(iteratees, function(iteratee){return iteratee(value);});return {criteria:criteria, index:++index, value:value};});return baseSortBy(result, function(object, other){return compareMultiple(object, other, orders);});}function basePick(object, paths){return basePickBy(object, paths, function(value, path){return hasIn(object, path);});}function basePickBy(object, paths, predicate){var index=-1, length=paths.length, result={};while(++index < length) {var path=paths[index], value=baseGet(object, path);if(predicate(value, path)){baseSet(result, castPath(path, object), value);}}return result;}function basePropertyDeep(path){return function(object){return baseGet(object, path);};}function basePullAll(array, values, iteratee, comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf, index=-1, length=values.length, seen=array;if(array === values){values = copyArray(values);}if(iteratee){seen = arrayMap(array, baseUnary(iteratee));}while(++index < length) {var fromIndex=0, value=values[index], computed=iteratee?iteratee(value):value;while((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {if(seen !== array){splice.call(seen, fromIndex, 1);}splice.call(array, fromIndex, 1);}}return array;}function basePullAt(array, indexes){var length=array?indexes.length:0, lastIndex=length - 1;while(length--) {var index=indexes[length];if(length == lastIndex || index !== previous){var previous=index;if(isIndex(index)){splice.call(array, index, 1);}else {baseUnset(array, index);}}}return array;}function baseRandom(lower, upper){return lower + nativeFloor(nativeRandom() * (upper - lower + 1));}function baseRange(start, end, step, fromRight){var index=-1, length=nativeMax(nativeCeil((end - start) / (step || 1)), 0), result=Array(length);while(length--) {result[fromRight?length:++index] = start;start += step;}return result;}function baseRepeat(string, n){var result="";if(!string || n < 1 || n > MAX_SAFE_INTEGER){return result;}do{if(n % 2){result += string;}n = nativeFloor(n / 2);if(n){string += string;}}while(n);return result;}function baseRest(func, start){return setToString(overRest(func, start, identity), func + "");}function baseSample(collection){return arraySample(values(collection));}function baseSampleSize(collection, n){var array=values(collection);return shuffleSelf(array, baseClamp(n, 0, array.length));}function baseSet(object, path, value, customizer){if(!isObject(object)){return object;}path = castPath(path, object);var index=-1, length=path.length, lastIndex=length - 1, nested=object;while(nested != null && ++index < length) {var key=toKey(path[index]), newValue=value;if(key === "__proto__" || key === "constructor" || key === "prototype"){return object;}if(index != lastIndex){var objValue=nested[key];newValue = customizer?customizer(objValue, key, nested):undefined;if(newValue === undefined){newValue = isObject(objValue)?objValue:isIndex(path[index + 1])?[]:{};}}assignValue(nested, key, newValue);nested = nested[key];}return object;}var baseSetData=!metaMap?identity:function(func, data){metaMap.set(func, data);return func;};var baseSetToString=!defineProperty?identity:function(func, string){return defineProperty(func, "toString", {configurable:true, enumerable:false, value:constant(string), writable:true});};function baseShuffle(collection){return shuffleSelf(values(collection));}function baseSlice(array, start, end){var index=-1, length=array.length;if(start < 0){start = -start > length?0:length + start;}end = end > length?length:end;if(end < 0){end += length;}length = start > end?0:end - start >>> 0;start >>>= 0;var result=Array(length);while(++index < length) {result[index] = array[index + start];}return result;}function baseSome(collection, predicate){var result;baseEach(collection, function(value, index, collection){result = predicate(value, index, collection);return !result;});return !!result;}function baseSortedIndex(array, value, retHighest){var low=0, high=array == null?low:array.length;if(typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH){while(low < high) {var mid=low + high >>> 1, computed=array[mid];if(computed !== null && !isSymbol(computed) && (retHighest?computed <= value:computed < value)){low = mid + 1;}else {high = mid;}}return high;}return baseSortedIndexBy(array, value, identity, retHighest);}function baseSortedIndexBy(array, value, iteratee, retHighest){var low=0, high=array == null?0:array.length;if(high === 0){return 0;}value = iteratee(value);var valIsNaN=value !== value, valIsNull=value === null, valIsSymbol=isSymbol(value), valIsUndefined=value === undefined;while(low < high) {var mid=nativeFloor((low + high) / 2), computed=iteratee(array[mid]), othIsDefined=computed !== undefined, othIsNull=computed === null, othIsReflexive=computed === computed, othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest || othIsReflexive;}else if(valIsUndefined){setLow = othIsReflexive && (retHighest || othIsDefined);}else if(valIsNull){setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);}else if(valIsSymbol){setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);}else if(othIsNull || othIsSymbol){setLow = false;}else {setLow = retHighest?computed <= value:computed < value;}if(setLow){low = mid + 1;}else {high = mid;}}return nativeMin(high, MAX_ARRAY_INDEX);}function baseSortedUniq(array, iteratee){var index=-1, length=array.length, resIndex=0, result=[];while(++index < length) {var value=array[index], computed=iteratee?iteratee(value):value;if(!index || !eq(computed, seen)){var seen=computed;result[resIndex++] = value === 0?0:value;}}return result;}function baseToNumber(value){if(typeof value == "number"){return value;}if(isSymbol(value)){return NAN;}return +value;}function baseToString(value){if(typeof value == "string"){return value;}if(isArray(value)){return arrayMap(value, baseToString) + "";}if(isSymbol(value)){return symbolToString?symbolToString.call(value):"";}var result=value + "";return result == "0" && 1 / value == -INFINITY?"-0":result;}function baseUniq(array, iteratee, comparator){var index=-1, includes=arrayIncludes, length=array.length, isCommon=true, result=[], seen=result;if(comparator){isCommon = false;includes = arrayIncludesWith;}else if(length >= LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon = false;includes = cacheHas;seen = new SetCache();}else {seen = iteratee?[]:result;}outer: while(++index < length) {var value=array[index], computed=iteratee?iteratee(value):value;value = comparator || value !== 0?value:0;if(isCommon && computed === computed){var seenIndex=seen.length;while(seenIndex--) {if(seen[seenIndex] === computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen, computed, comparator)){if(seen !== result){seen.push(computed);}result.push(value);}}return result;}function baseUnset(object, path){path = castPath(path, object);object = parent(object, path);return object == null || delete object[toKey(last(path))];}function baseUpdate(object, path, updater, customizer){return baseSet(object, path, updater(baseGet(object, path)), customizer);}function baseWhile(array, predicate, isDrop, fromRight){var length=array.length, index=fromRight?length:-1;while((fromRight?index--:++index < length) && predicate(array[index], index, array)) {}return isDrop?baseSlice(array, fromRight?0:index, fromRight?index + 1:length):baseSlice(array, fromRight?index + 1:0, fromRight?length:index);}function baseWrapperValue(value, actions){var result=value;if(result instanceof LazyWrapper){result = result.value();}return arrayReduce(actions, function(result, action){return action.func.apply(action.thisArg, arrayPush([result], action.args));}, result);}function baseXor(arrays, iteratee, comparator){var length=arrays.length;if(length < 2){return length?baseUniq(arrays[0]):[];}var index=-1, result=Array(length);while(++index < length) {var array=arrays[index], othIndex=-1;while(++othIndex < length) {if(othIndex != index){result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);}}}return baseUniq(baseFlatten(result, 1), iteratee, comparator);}function baseZipObject(props, values, assignFunc){var index=-1, length=props.length, valsLength=values.length, result={};while(++index < length) {var value=index < valsLength?values[index]:undefined;assignFunc(result, props[index], value);}return result;}function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}function castFunction(value){return typeof value == "function"?value:identity;}function castPath(value, object){if(isArray(value)){return value;}return isKey(value, object)?[value]:stringToPath(toString(value));}var castRest=baseRest;function castSlice(array, start, end){var length=array.length;end = end === undefined?length:end;return !start && end >= length?array:baseSlice(array, start, end);}var clearTimeout=ctxClearTimeout || function(id){return root.clearTimeout(id);};function cloneBuffer(buffer, isDeep){if(isDeep){return buffer.slice();}var length=buffer.length, result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}function cloneDataView(dataView, isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);}function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source, reFlags.exec(regexp));result.lastIndex = regexp.lastIndex;return result;}function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}function cloneTypedArray(typedArray, isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);}function compareAscending(value, other){if(value !== other){var valIsDefined=value !== undefined, valIsNull=value === null, valIsReflexive=value === value, valIsSymbol=isSymbol(value);var othIsDefined=other !== undefined, othIsNull=other === null, othIsReflexive=other === other, othIsSymbol=isSymbol(other);if(!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive){return 1;}if(!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive){return -1;}}return 0;}function compareMultiple(object, other, orders){var index=-1, objCriteria=object.criteria, othCriteria=other.criteria, length=objCriteria.length, ordersLength=orders.length;while(++index < length) {var result=compareAscending(objCriteria[index], othCriteria[index]);if(result){if(index >= ordersLength){return result;}var order=orders[index];return result * (order == "desc"?-1:1);}}return object.index - other.index;}function composeArgs(args, partials, holders, isCurried){var argsIndex=-1, argsLength=args.length, holdersLength=holders.length, leftIndex=-1, leftLength=partials.length, rangeLength=nativeMax(argsLength - holdersLength, 0), result=Array(leftLength + rangeLength), isUncurried=!isCurried;while(++leftIndex < leftLength) {result[leftIndex] = partials[leftIndex];}while(++argsIndex < holdersLength) {if(isUncurried || argsIndex < argsLength){result[holders[argsIndex]] = args[argsIndex];}}while(rangeLength--) {result[leftIndex++] = args[argsIndex++];}return result;}function composeArgsRight(args, partials, holders, isCurried){var argsIndex=-1, argsLength=args.length, holdersIndex=-1, holdersLength=holders.length, rightIndex=-1, rightLength=partials.length, rangeLength=nativeMax(argsLength - holdersLength, 0), result=Array(rangeLength + rightLength), isUncurried=!isCurried;while(++argsIndex < rangeLength) {result[argsIndex] = args[argsIndex];}var offset=argsIndex;while(++rightIndex < rightLength) {result[offset + rightIndex] = partials[rightIndex];}while(++holdersIndex < holdersLength) {if(isUncurried || argsIndex < argsLength){result[offset + holders[holdersIndex]] = args[argsIndex++];}}return result;}function copyArray(source, array){var index=-1, length=source.length;array || (array = Array(length));while(++index < length) {array[index] = source[index];}return array;}function copyObject(source, props, object, customizer){var isNew=!object;object || (object = {});var index=-1, length=props.length;while(++index < length) {var key=props[index];var newValue=customizer?customizer(object[key], source[key], key, object, source):undefined;if(newValue === undefined){newValue = source[key];}if(isNew){baseAssignValue(object, key, newValue);}else {assignValue(object, key, newValue);}}return object;}function copySymbols(source, object){return copyObject(source, getSymbols(source), object);}function copySymbolsIn(source, object){return copyObject(source, getSymbolsIn(source), object);}function createAggregator(setter, initializer){return function(collection, iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator, accumulator=initializer?initializer():{};return func(collection, setter, getIteratee(iteratee, 2), accumulator);};}function createAssigner(assigner){return baseRest(function(object, sources){var index=-1, length=sources.length, customizer=length > 1?sources[length - 1]:undefined, guard=length > 2?sources[2]:undefined;customizer = assigner.length > 3 && typeof customizer == "function"?(length--, customizer):undefined;if(guard && isIterateeCall(sources[0], sources[1], guard)){customizer = length < 3?undefined:customizer;length = 1;}object = Object(object);while(++index < length) {var source=sources[index];if(source){assigner(object, source, index, customizer);}}return object;});}function createBaseEach(eachFunc, fromRight){return function(collection, iteratee){if(collection == null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection, iteratee);}var length=collection.length, index=fromRight?length:-1, iterable=Object(collection);while(fromRight?index--:++index < length) {if(iteratee(iterable[index], index, iterable) === false){break;}}return collection;};}function createBaseFor(fromRight){return function(object, iteratee, keysFunc){var index=-1, iterable=Object(object), props=keysFunc(object), length=props.length;while(length--) {var key=props[fromRight?length:++index];if(iteratee(iterable[key], key, iterable) === false){break;}}return object;};}function createBind(func, bitmask, thisArg){var isBind=bitmask & WRAP_BIND_FLAG, Ctor=createCtor(func);function wrapper(){var fn=this && this !== root && this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this, arguments);}return wrapper;}function createCaseFirst(methodName){return function(string){string = toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols, 1).join(""):string.slice(1);return chr[methodName]() + trailing;};}function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");};}function createCtor(Ctor){return function(){var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0], args[1]);case 3:return new Ctor(args[0], args[1], args[2]);case 4:return new Ctor(args[0], args[1], args[2], args[3]);case 5:return new Ctor(args[0], args[1], args[2], args[3], args[4]);case 6:return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);case 7:return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);}var thisBinding=baseCreate(Ctor.prototype), result=Ctor.apply(thisBinding, args);return isObject(result)?result:thisBinding;};}function createCurry(func, bitmask, arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length, args=Array(length), index=length, placeholder=getHolder(wrapper);while(index--) {args[index] = arguments[index];}var holders=length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder?[]:replaceHolders(args, placeholder);length -= holders.length;if(length < arity){return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);}var fn=this && this !== root && this instanceof wrapper?Ctor:func;return apply(fn, this, args);}return wrapper;}function createFind(findIndexFunc){return function(collection, predicate, fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate, 3);collection = keys(collection);predicate = function(key){return iteratee(iterable[key], key, iterable);};}var index=findIndexFunc(collection, predicate, fromIndex);return index > -1?iterable[iteratee?collection[index]:index]:undefined;};}function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length, index=length, prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--) {var func=funcs[index];if(typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq && !wrapper && getFuncName(func) == "wrapper"){var wrapper=new LodashWrapper([], true);}}index = wrapper?index:length;while(++index < length) {func = funcs[index];var funcName=getFuncName(func), data=funcName == "wrapper"?getData(func):undefined;if(data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1){wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);}else {wrapper = func.length == 1 && isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments, value=args[0];if(wrapper && args.length == 1 && isArray(value)){return wrapper.plant(value).value();}var index=0, result=length?funcs[index].apply(this, args):value;while(++index < length) {result = funcs[index].call(this, result);}return result;};});}function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity){var isAry=bitmask & WRAP_ARY_FLAG, isBind=bitmask & WRAP_BIND_FLAG, isBindKey=bitmask & WRAP_BIND_KEY_FLAG, isCurried=bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip=bitmask & WRAP_FLIP_FLAG, Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length, args=Array(length), index=length;while(index--) {args[index] = arguments[index];}if(isCurried){var placeholder=getHolder(wrapper), holdersCount=countHolders(args, placeholder);}if(partials){args = composeArgs(args, partials, holders, isCurried);}if(partialsRight){args = composeArgsRight(args, partialsRight, holdersRight, isCurried);}length -= holdersCount;if(isCurried && length < arity){var newHolders=replaceHolders(args, placeholder);return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);}var thisBinding=isBind?thisArg:this, fn=isBindKey?thisBinding[func]:func;length = args.length;if(argPos){args = reorder(args, argPos);}else if(isFlip && length > 1){args.reverse();}if(isAry && ary < length){args.length = ary;}if(this && this !== root && this instanceof wrapper){fn = Ctor || createCtor(fn);}return fn.apply(thisBinding, args);}return wrapper;}function createInverter(setter, toIteratee){return function(object, iteratee){return baseInverter(object, setter, toIteratee(iteratee), {});};}function createMathOperation(operator, defaultValue){return function(value, other){var result;if(value === undefined && other === undefined){return defaultValue;}if(value !== undefined){result = value;}if(other !== undefined){if(result === undefined){return other;}if(typeof value == "string" || typeof other == "string"){value = baseToString(value);other = baseToString(other);}else {value = baseToNumber(value);other = baseToNumber(other);}result = operator(value, other);}return result;};}function createOver(arrayFunc){return flatRest(function(iteratees){iteratees = arrayMap(iteratees, baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees, function(iteratee){return apply(iteratee, thisArg, args);});});});}function createPadding(length, chars){chars = chars === undefined?" ":baseToString(chars);var charsLength=chars.length;if(charsLength < 2){return charsLength?baseRepeat(chars, length):chars;}var result=baseRepeat(chars, nativeCeil(length / stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result), 0, length).join(""):result.slice(0, length);}function createPartial(func, bitmask, thisArg, partials){var isBind=bitmask & WRAP_BIND_FLAG, Ctor=createCtor(func);function wrapper(){var argsIndex=-1, argsLength=arguments.length, leftIndex=-1, leftLength=partials.length, args=Array(leftLength + argsLength), fn=this && this !== root && this instanceof wrapper?Ctor:func;while(++leftIndex < leftLength) {args[leftIndex] = partials[leftIndex];}while(argsLength--) {args[leftIndex++] = arguments[++argsIndex];}return apply(fn, isBind?thisArg:this, args);}return wrapper;}function createRange(fromRight){return function(start, end, step){if(step && typeof step != "number" && isIterateeCall(start, end, step)){end = step = undefined;}start = toFinite(start);if(end === undefined){end = start;start = 0;}else {end = toFinite(end);}step = step === undefined?start < end?1:-1:toFinite(step);return baseRange(start, end, step, fromRight);};}function createRelationalOperation(operator){return function(value, other){if(!(typeof value == "string" && typeof other == "string")){value = toNumber(value);other = toNumber(other);}return operator(value, other);};}function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity){var isCurry=bitmask & WRAP_CURRY_FLAG, newHolders=isCurry?holders:undefined, newHoldersRight=isCurry?undefined:holders, newPartials=isCurry?partials:undefined, newPartialsRight=isCurry?undefined:partials;bitmask |= isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask &= ~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask & WRAP_CURRY_BOUND_FLAG)){bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);}var newData=[func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];var result=wrapFunc.apply(undefined, newData);if(isLaziable(func)){setData(result, newData);}result.placeholder = placeholder;return setWrapToString(result, func, bitmask);}function createRound(methodName){var func=Math[methodName];return function(number, precision){number = toNumber(number);precision = precision == null?0:nativeMin(toInteger(precision), 292);if(precision && nativeIsFinite(number)){var pair=(toString(number) + "e").split("e"), value=func(pair[0] + "e" + (+pair[1] + precision));pair = (toString(value) + "e").split("e");return +(pair[0] + "e" + (+pair[1] - precision));}return func(number);};}var createSet=!(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY)?noop:function(values){return new Set(values);};function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag == mapTag){return mapToArray(object);}if(tag == setTag){return setToPairs(object);}return baseToPairs(object, keysFunc(object));};}function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity){var isBindKey=bitmask & WRAP_BIND_KEY_FLAG;if(!isBindKey && typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);partials = holders = undefined;}ary = ary === undefined?ary:nativeMax(toInteger(ary), 0);arity = arity === undefined?arity:toInteger(arity);length -= holders?holders.length:0;if(bitmask & WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials, holdersRight=holders;partials = holders = undefined;}var data=isBindKey?undefined:getData(func);var newData=[func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];if(data){mergeData(newData, data);}func = newData[0];bitmask = newData[1];thisArg = newData[2];partials = newData[3];holders = newData[4];arity = newData[9] = newData[9] === undefined?isBindKey?0:func.length:nativeMax(newData[9] - length, 0);if(!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)){bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);}if(!bitmask || bitmask == WRAP_BIND_FLAG){var result=createBind(func, bitmask, thisArg);}else if(bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG){result = createCurry(func, bitmask, arity);}else if((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length){result = createPartial(func, bitmask, thisArg, partials);}else {result = createHybrid.apply(undefined, newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result, newData), func, bitmask);}function customDefaultsAssignIn(objValue, srcValue, key, object){if(objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)){return srcValue;}return objValue;}function customDefaultsMerge(objValue, srcValue, key, object, source, stack){if(isObject(objValue) && isObject(srcValue)){stack.set(srcValue, objValue);baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);stack["delete"](srcValue);}return objValue;}function customOmitClone(value){return isPlainObject(value)?undefined:value;}function equalArrays(array, other, bitmask, customizer, equalFunc, stack){var isPartial=bitmask & COMPARE_PARTIAL_FLAG, arrLength=array.length, othLength=other.length;if(arrLength != othLength && !(isPartial && othLength > arrLength)){return false;}var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked && othStacked){return arrStacked == other && othStacked == array;}var index=-1, result=true, seen=bitmask & COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array, other);stack.set(other, array);while(++index < arrLength) {var arrValue=array[index], othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue, arrValue, index, other, array, stack):customizer(arrValue, othValue, index, array, other, stack);}if(compared !== undefined){if(compared){continue;}result = false;break;}if(seen){if(!arraySome(other, function(othValue, othIndex){if(!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))){return seen.push(othIndex);}})){result = false;break;}}else if(!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))){result = false;break;}}stack["delete"](array);stack["delete"](other);return result;}function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack){switch(tag){case dataViewTag:if(object.byteLength != other.byteLength || object.byteOffset != other.byteOffset){return false;}object = object.buffer;other = other.buffer;case arrayBufferTag:if(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:return eq(+object, +other);case errorTag:return object.name == other.name && object.message == other.message;case regexpTag:case stringTag:return object == other + "";case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask & COMPARE_PARTIAL_FLAG;convert || (convert = setToArray);if(object.size != other.size && !isPartial){return false;}var stacked=stack.get(object);if(stacked){return stacked == other;}bitmask |= COMPARE_UNORDERED_FLAG;stack.set(object, other);var result=equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);stack["delete"](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object) == symbolValueOf.call(other);}}return false;}function equalObjects(object, other, bitmask, customizer, equalFunc, stack){var isPartial=bitmask & COMPARE_PARTIAL_FLAG, objProps=getAllKeys(object), objLength=objProps.length, othProps=getAllKeys(other), othLength=othProps.length;if(objLength != othLength && !isPartial){return false;}var index=objLength;while(index--) {var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other, key))){return false;}}var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked && othStacked){return objStacked == other && othStacked == object;}var result=true;stack.set(object, other);stack.set(other, object);var skipCtor=isPartial;while(++index < objLength) {key = objProps[index];var objValue=object[key], othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue, objValue, key, other, object, stack):customizer(objValue, othValue, key, object, other, stack);}if(!(compared === undefined?objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack):compared)){result = false;break;}skipCtor || (skipCtor = key == "constructor");}if(result && !skipCtor){var objCtor=object.constructor, othCtor=other.constructor;if(objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)){result = false;}}stack["delete"](object);stack["delete"](other);return result;}function flatRest(func){return setToString(overRest(func, undefined, flatten), func + "");}function getAllKeys(object){return baseGetAllKeys(object, keys, getSymbols);}function getAllKeysIn(object){return baseGetAllKeys(object, keysIn, getSymbolsIn);}var getData=!metaMap?noop:function(func){return metaMap.get(func);};function getFuncName(func){var result=func.name + "", array=realNames[result], length=hasOwnProperty.call(realNames, result)?array.length:0;while(length--) {var data=array[length], otherFunc=data.func;if(otherFunc == null || otherFunc == func){return data.name;}}return result;}function getHolder(func){var object=hasOwnProperty.call(lodash, "placeholder")?lodash:func;return object.placeholder;}function getIteratee(){var result=lodash.iteratee || iteratee;result = result === iteratee?baseIteratee:result;return arguments.length?result(arguments[0], arguments[1]):result;}function getMapData(map, key){var data=map.__data__;return isKeyable(key)?data[typeof key == "string"?"string":"hash"]:data.map;}function getMatchData(object){var result=keys(object), length=result.length;while(length--) {var key=result[length], value=object[key];result[length] = [key, value, isStrictComparable(value)];}return result;}function getNative(object, key){var value=getValue(object, key);return baseIsNative(value)?value:undefined;}function getRawTag(value){var isOwn=hasOwnProperty.call(value, symToStringTag), tag=value[symToStringTag];try{value[symToStringTag] = undefined;var unmasked=true;}catch(e) {}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag] = tag;}else {delete value[symToStringTag];}}return result;}var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object == null){return [];}object = Object(object);return arrayFilter(nativeGetSymbols(object), function(symbol){return propertyIsEnumerable.call(object, symbol);});};var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object) {arrayPush(result, getSymbols(object));object = getPrototype(object);}return result;};var getTag=baseGetTag;if(DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag){getTag = function(value){var result=baseGetTag(value), Ctor=result == objectTag?value.constructor:undefined, ctorString=Ctor?toSource(Ctor):"";if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}function getView(start, end, transforms){var index=-1, length=transforms.length;while(++index < length) {var data=transforms[index], size=data.size;switch(data.type){case "drop":start += size;break;case "dropRight":end -= size;break;case "take":end = nativeMin(end, start + size);break;case "takeRight":start = nativeMax(start, end - size);break;}}return {start:start, end:end};}function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}function hasPath(object, path, hasFunc){path = castPath(path, object);var index=-1, length=path.length, result=false;while(++index < length) {var key=toKey(path[index]);if(!(result = object != null && hasFunc(object, key))){break;}object = object[key];}if(result || ++index != length){return result;}length = object == null?0:object.length;return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));}function initCloneArray(array){var length=array.length, result=new array.constructor(length);if(length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")){result.index = array.index;result.input = array.input;}return result;}function initCloneObject(object){return typeof object.constructor == "function" && !isPrototype(object)?baseCreate(getPrototype(object)):{};}function initCloneByTag(object, tag, isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object, isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object, isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}function insertWrapDetails(source, details){var length=details.length;if(!length){return source;}var lastIndex=length - 1;details[lastIndex] = (length > 1?"& ":"") + details[lastIndex];details = details.join(length > 2?", ":" ");return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");}function isFlattenable(value){return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);}function isIndex(value, length){var type=typeof value;length = length == null?MAX_SAFE_INTEGER:length;return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);}function isIterateeCall(value, index, object){if(!isObject(object)){return false;}var type=typeof index;if(type == "number"?isArrayLike(object) && isIndex(index, object.length):type == "string" && index in object){return eq(object[index], value);}return false;}function isKey(value, object){if(isArray(value)){return false;}var type=typeof value;if(type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)){return true;}return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);}function isKeyable(value){var type=typeof value;return type == "string" || type == "number" || type == "symbol" || type == "boolean"?value !== "__proto__":value === null;}function isLaziable(func){var funcName=getFuncName(func), other=lodash[funcName];if(typeof other != "function" || !(funcName in LazyWrapper.prototype)){return false;}if(func === other){return true;}var data=getData(other);return !!data && func === data[0];}function isMasked(func){return !!maskSrcKey && maskSrcKey in func;}var isMaskable=coreJsData?isFunction:stubFalse;function isPrototype(value){var Ctor=value && value.constructor, proto=typeof Ctor == "function" && Ctor.prototype || objectProto;return value === proto;}function isStrictComparable(value){return value === value && !isObject(value);}function matchesStrictComparable(key, srcValue){return function(object){if(object == null){return false;}return object[key] === srcValue && (srcValue !== undefined || key in Object(object));};}function memoizeCapped(func){var result=memoize(func, function(key){if(cache.size === MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}function mergeData(data, source){var bitmask=data[1], srcBitmask=source[1], newBitmask=bitmask | srcBitmask, isCommon=newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);var isCombo=srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;if(!(isCommon || isCombo)){return data;}if(srcBitmask & WRAP_BIND_FLAG){data[2] = source[2];newBitmask |= bitmask & WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}var value=source[3];if(value){var partials=data[3];data[3] = partials?composeArgs(partials, value, source[4]):value;data[4] = partials?replaceHolders(data[3], PLACEHOLDER):source[4];}value = source[5];if(value){partials = data[5];data[5] = partials?composeArgsRight(partials, value, source[6]):value;data[6] = partials?replaceHolders(data[5], PLACEHOLDER):source[6];}value = source[7];if(value){data[7] = value;}if(srcBitmask & WRAP_ARY_FLAG){data[8] = data[8] == null?source[8]:nativeMin(data[8], source[8]);}if(data[9] == null){data[9] = source[9];}data[0] = source[0];data[1] = newBitmask;return data;}function nativeKeysIn(object){var result=[];if(object != null){for(var key in Object(object)) {result.push(key);}}return result;}function objectToString(value){return nativeObjectToString.call(value);}function overRest(func, start, transform){start = nativeMax(start === undefined?func.length - 1:start, 0);return function(){var args=arguments, index=-1, length=nativeMax(args.length - start, 0), array=Array(length);while(++index < length) {array[index] = args[start + index];}index = -1;var otherArgs=Array(start + 1);while(++index < start) {otherArgs[index] = args[index];}otherArgs[start] = transform(array);return apply(func, this, otherArgs);};}function parent(object, path){return path.length < 2?object:baseGet(object, baseSlice(path, 0, -1));}function reorder(array, indexes){var arrLength=array.length, length=nativeMin(indexes.length, arrLength), oldArray=copyArray(array);while(length--) {var index=indexes[length];array[length] = isIndex(index, arrLength)?oldArray[index]:undefined;}return array;}function safeGet(object, key){if(key === "constructor" && typeof object[key] === "function"){return;}if(key == "__proto__"){return;}return object[key];}var setData=shortOut(baseSetData);var setTimeout=ctxSetTimeout || function(func, wait){return root.setTimeout(func, wait);};var setToString=shortOut(baseSetToString);function setWrapToString(wrapper, reference, bitmask){var source=reference + "";return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));}function shortOut(func){var count=0, lastCalled=0;return function(){var stamp=nativeNow(), remaining=HOT_SPAN - (stamp - lastCalled);lastCalled = stamp;if(remaining > 0){if(++count >= HOT_COUNT){return arguments[0];}}else {count = 0;}return func.apply(undefined, arguments);};}function shuffleSelf(array, size){var index=-1, length=array.length, lastIndex=length - 1;size = size === undefined?length:size;while(++index < size) {var rand=baseRandom(index, lastIndex), value=array[rand];array[rand] = array[index];array[index] = value;}array.length = size;return array;}var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0) === 46){result.push("");}string.replace(rePropName, function(match, number, quote, subString){result.push(quote?subString.replace(reEscapeChar, "$1"):number || match);});return result;});function toKey(value){if(typeof value == "string" || isSymbol(value)){return value;}var result=value + "";return result == "0" && 1 / value == -INFINITY?"-0":result;}function toSource(func){if(func != null){try{return funcToString.call(func);}catch(e) {}try{return func + "";}catch(e) {}}return "";}function updateWrapDetails(details, bitmask){arrayEach(wrapFlags, function(pair){var value="_." + pair[0];if(bitmask & pair[1] && !arrayIncludes(details, value)){details.push(value);}});return details.sort();}function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);result.__actions__ = copyArray(wrapper.__actions__);result.__index__ = wrapper.__index__;result.__values__ = wrapper.__values__;return result;}function chunk(array, size, guard){if(guard?isIterateeCall(array, size, guard):size === undefined){size = 1;}else {size = nativeMax(toInteger(size), 0);}var length=array == null?0:array.length;if(!length || size < 1){return [];}var index=0, resIndex=0, result=Array(nativeCeil(length / size));while(index < length) {result[resIndex++] = baseSlice(array, index, index += size);}return result;}function compact(array){var index=-1, length=array == null?0:array.length, resIndex=0, result=[];while(++index < length) {var value=array[index];if(value){result[resIndex++] = value;}}return result;}function concat(){var length=arguments.length;if(!length){return [];}var args=Array(length - 1), array=arguments[0], index=length;while(index--) {args[index - 1] = arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array], baseFlatten(args, 1));}var difference=baseRest(function(array, values){return isArrayLikeObject(array)?baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)):[];});var differenceBy=baseRest(function(array, values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee = undefined;}return isArrayLikeObject(array)?baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)):[];});var differenceWith=baseRest(function(array, values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator = undefined;}return isArrayLikeObject(array)?baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator):[];});function drop(array, n, guard){var length=array == null?0:array.length;if(!length){return [];}n = guard || n === undefined?1:toInteger(n);return baseSlice(array, n < 0?0:n, length);}function dropRight(array, n, guard){var length=array == null?0:array.length;if(!length){return [];}n = guard || n === undefined?1:toInteger(n);n = length - n;return baseSlice(array, 0, n < 0?0:n);}function dropRightWhile(array, predicate){return array && array.length?baseWhile(array, getIteratee(predicate, 3), true, true):[];}function dropWhile(array, predicate){return array && array.length?baseWhile(array, getIteratee(predicate, 3), true):[];}function fill(array, value, start, end){var length=array == null?0:array.length;if(!length){return [];}if(start && typeof start != "number" && isIterateeCall(array, value, start)){start = 0;end = length;}return baseFill(array, value, start, end);}function findIndex(array, predicate, fromIndex){var length=array == null?0:array.length;if(!length){return -1;}var index=fromIndex == null?0:toInteger(fromIndex);if(index < 0){index = nativeMax(length + index, 0);}return baseFindIndex(array, getIteratee(predicate, 3), index);}function findLastIndex(array, predicate, fromIndex){var length=array == null?0:array.length;if(!length){return -1;}var index=length - 1;if(fromIndex !== undefined){index = toInteger(fromIndex);index = fromIndex < 0?nativeMax(length + index, 0):nativeMin(index, length - 1);}return baseFindIndex(array, getIteratee(predicate, 3), index, true);}function flatten(array){var length=array == null?0:array.length;return length?baseFlatten(array, 1):[];}function flattenDeep(array){var length=array == null?0:array.length;return length?baseFlatten(array, INFINITY):[];}function flattenDepth(array, depth){var length=array == null?0:array.length;if(!length){return [];}depth = depth === undefined?1:toInteger(depth);return baseFlatten(array, depth);}function fromPairs(pairs){var index=-1, length=pairs == null?0:pairs.length, result={};while(++index < length) {var pair=pairs[index];result[pair[0]] = pair[1];}return result;}function head(array){return array && array.length?array[0]:undefined;}function indexOf(array, value, fromIndex){var length=array == null?0:array.length;if(!length){return -1;}var index=fromIndex == null?0:toInteger(fromIndex);if(index < 0){index = nativeMax(length + index, 0);}return baseIndexOf(array, value, index);}function initial(array){var length=array == null?0:array.length;return length?baseSlice(array, 0, -1):[];}var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays, castArrayLikeObject);return mapped.length && mapped[0] === arrays[0]?baseIntersection(mapped):[];});var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays), mapped=arrayMap(arrays, castArrayLikeObject);if(iteratee === last(mapped)){iteratee = undefined;}else {mapped.pop();}return mapped.length && mapped[0] === arrays[0]?baseIntersection(mapped, getIteratee(iteratee, 2)):[];});var intersectionWith=baseRest(function(arrays){var comparator=last(arrays), mapped=arrayMap(arrays, castArrayLikeObject);comparator = typeof comparator == "function"?comparator:undefined;if(comparator){mapped.pop();}return mapped.length && mapped[0] === arrays[0]?baseIntersection(mapped, undefined, comparator):[];});function join(array, separator){return array == null?"":nativeJoin.call(array, separator);}function last(array){var length=array == null?0:array.length;return length?array[length - 1]:undefined;}function lastIndexOf(array, value, fromIndex){var length=array == null?0:array.length;if(!length){return -1;}var index=length;if(fromIndex !== undefined){index = toInteger(fromIndex);index = index < 0?nativeMax(length + index, 0):nativeMin(index, length - 1);}return value === value?strictLastIndexOf(array, value, index):baseFindIndex(array, baseIsNaN, index, true);}function nth(array, n){return array && array.length?baseNth(array, toInteger(n)):undefined;}var pull=baseRest(pullAll);function pullAll(array, values){return array && array.length && values && values.length?basePullAll(array, values):array;}function pullAllBy(array, values, iteratee){return array && array.length && values && values.length?basePullAll(array, values, getIteratee(iteratee, 2)):array;}function pullAllWith(array, values, comparator){return array && array.length && values && values.length?basePullAll(array, values, undefined, comparator):array;}var pullAt=flatRest(function(array, indexes){var length=array == null?0:array.length, result=baseAt(array, indexes);basePullAt(array, arrayMap(indexes, function(index){return isIndex(index, length)?+index:index;}).sort(compareAscending));return result;});function remove(array, predicate){var result=[];if(!(array && array.length)){return result;}var index=-1, indexes=[], length=array.length;predicate = getIteratee(predicate, 3);while(++index < length) {var value=array[index];if(predicate(value, index, array)){result.push(value);indexes.push(index);}}basePullAt(array, indexes);return result;}function reverse(array){return array == null?array:nativeReverse.call(array);}function slice(array, start, end){var length=array == null?0:array.length;if(!length){return [];}if(end && typeof end != "number" && isIterateeCall(array, start, end)){start = 0;end = length;}else {start = start == null?0:toInteger(start);end = end === undefined?length:toInteger(end);}return baseSlice(array, start, end);}function sortedIndex(array, value){return baseSortedIndex(array, value);}function sortedIndexBy(array, value, iteratee){return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));}function sortedIndexOf(array, value){var length=array == null?0:array.length;if(length){var index=baseSortedIndex(array, value);if(index < length && eq(array[index], value)){return index;}}return -1;}function sortedLastIndex(array, value){return baseSortedIndex(array, value, true);}function sortedLastIndexBy(array, value, iteratee){return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);}function sortedLastIndexOf(array, value){var length=array == null?0:array.length;if(length){var index=baseSortedIndex(array, value, true) - 1;if(eq(array[index], value)){return index;}}return -1;}function sortedUniq(array){return array && array.length?baseSortedUniq(array):[];}function sortedUniqBy(array, iteratee){return array && array.length?baseSortedUniq(array, getIteratee(iteratee, 2)):[];}function tail(array){var length=array == null?0:array.length;return length?baseSlice(array, 1, length):[];}function take(array, n, guard){if(!(array && array.length)){return [];}n = guard || n === undefined?1:toInteger(n);return baseSlice(array, 0, n < 0?0:n);}function takeRight(array, n, guard){var length=array == null?0:array.length;if(!length){return [];}n = guard || n === undefined?1:toInteger(n);n = length - n;return baseSlice(array, n < 0?0:n, length);}function takeRightWhile(array, predicate){return array && array.length?baseWhile(array, getIteratee(predicate, 3), false, true):[];}function takeWhile(array, predicate){return array && array.length?baseWhile(array, getIteratee(predicate, 3)):[];}var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));});var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee = undefined;}return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));});var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator = typeof comparator == "function"?comparator:undefined;return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);});function uniq(array){return array && array.length?baseUniq(array):[];}function uniqBy(array, iteratee){return array && array.length?baseUniq(array, getIteratee(iteratee, 2)):[];}function uniqWith(array, comparator){comparator = typeof comparator == "function"?comparator:undefined;return array && array.length?baseUniq(array, undefined, comparator):[];}function unzip(array){if(!(array && array.length)){return [];}var length=0;array = arrayFilter(array, function(group){if(isArrayLikeObject(group)){length = nativeMax(group.length, length);return true;}});return baseTimes(length, function(index){return arrayMap(array, baseProperty(index));});}function unzipWith(array, iteratee){if(!(array && array.length)){return [];}var result=unzip(array);if(iteratee == null){return result;}return arrayMap(result, function(group){return apply(iteratee, undefined, group);});}var without=baseRest(function(array, values){return isArrayLikeObject(array)?baseDifference(array, values):[];});var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays, isArrayLikeObject));});var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee = undefined;}return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));});var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator = typeof comparator == "function"?comparator:undefined;return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);});var zip=baseRest(unzip);function zipObject(props, values){return baseZipObject(props || [], values || [], assignValue);}function zipObjectDeep(props, values){return baseZipObject(props || [], values || [], baseSet);}var zipWith=baseRest(function(arrays){var length=arrays.length, iteratee=length > 1?arrays[length - 1]:undefined;iteratee = typeof iteratee == "function"?(arrays.pop(), iteratee):undefined;return unzipWith(arrays, iteratee);});function chain(value){var result=lodash(value);result.__chain__ = true;return result;}function tap(value, interceptor){interceptor(value);return value;}function thru(value, interceptor){return interceptor(value);}var wrapperAt=flatRest(function(paths){var length=paths.length, start=length?paths[0]:0, value=this.__wrapped__, interceptor=function interceptor(object){return baseAt(object, paths);};if(length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)){return this.thru(interceptor);}value = value.slice(start, +start + (length?1:0));value.__actions__.push({func:thru, args:[interceptor], thisArg:undefined});return new LodashWrapper(value, this.__chain__).thru(function(array){if(length && !array.length){array.push(undefined);}return array;});});function wrapperChain(){return chain(this);}function wrapperCommit(){return new LodashWrapper(this.value(), this.__chain__);}function wrapperNext(){if(this.__values__ === undefined){this.__values__ = toArray(this.value());}var done=this.__index__ >= this.__values__.length, value=done?undefined:this.__values__[this.__index__++];return {done:done, value:value};}function wrapperToIterator(){return this;}function wrapperPlant(value){var result, parent=this;while(parent instanceof baseLodash) {var clone=wrapperClone(parent);clone.__index__ = 0;clone.__values__ = undefined;if(result){previous.__wrapped__ = clone;}else {result = clone;}var previous=clone;parent = parent.__wrapped__;}previous.__wrapped__ = value;return result;}function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped = new LazyWrapper(this);}wrapped = wrapped.reverse();wrapped.__actions__.push({func:thru, args:[reverse], thisArg:undefined});return new LodashWrapper(wrapped, this.__chain__);}return this.thru(reverse);}function wrapperValue(){return baseWrapperValue(this.__wrapped__, this.__actions__);}var countBy=createAggregator(function(result, value, key){if(hasOwnProperty.call(result, key)){++result[key];}else {baseAssignValue(result, key, 1);}});function every(collection, predicate, guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard && isIterateeCall(collection, predicate, guard)){predicate = undefined;}return func(collection, getIteratee(predicate, 3));}function filter(collection, predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection, getIteratee(predicate, 3));}var find=createFind(findIndex);var findLast=createFind(findLastIndex);function flatMap(collection, iteratee){return baseFlatten(map(collection, iteratee), 1);}function flatMapDeep(collection, iteratee){return baseFlatten(map(collection, iteratee), INFINITY);}function flatMapDepth(collection, iteratee, depth){depth = depth === undefined?1:toInteger(depth);return baseFlatten(map(collection, iteratee), depth);}function forEach(collection, iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection, getIteratee(iteratee, 3));}function forEachRight(collection, iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection, getIteratee(iteratee, 3));}var groupBy=createAggregator(function(result, value, key){if(hasOwnProperty.call(result, key)){result[key].push(value);}else {baseAssignValue(result, key, [value]);}});function includes(collection, value, fromIndex, guard){collection = isArrayLike(collection)?collection:values(collection);fromIndex = fromIndex && !guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex < 0){fromIndex = nativeMax(length + fromIndex, 0);}return isString(collection)?fromIndex <= length && collection.indexOf(value, fromIndex) > -1:!!length && baseIndexOf(collection, value, fromIndex) > -1;}var invokeMap=baseRest(function(collection, path, args){var index=-1, isFunc=typeof path == "function", result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection, function(value){result[++index] = isFunc?apply(path, value, args):baseInvoke(value, path, args);});return result;});var keyBy=createAggregator(function(result, value, key){baseAssignValue(result, key, value);});function map(collection, iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection, getIteratee(iteratee, 3));}function orderBy(collection, iteratees, orders, guard){if(collection == null){return [];}if(!isArray(iteratees)){iteratees = iteratees == null?[]:[iteratees];}orders = guard?undefined:orders;if(!isArray(orders)){orders = orders == null?[]:[orders];}return baseOrderBy(collection, iteratees, orders);}var partition=createAggregator(function(result, value, key){result[key?0:1].push(value);}, function(){return [[], []];});function reduce(collection, iteratee, accumulator){var func=isArray(collection)?arrayReduce:baseReduce, initAccum=arguments.length < 3;return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);}function reduceRight(collection, iteratee, accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce, initAccum=arguments.length < 3;return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);}function reject(collection, predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection, negate(getIteratee(predicate, 3)));}function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}function sampleSize(collection, n, guard){if(guard?isIterateeCall(collection, n, guard):n === undefined){n = 1;}else {n = toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection, n);}function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}function size(collection){if(collection == null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag == mapTag || tag == setTag){return collection.size;}return baseKeys(collection).length;}function some(collection, predicate, guard){var func=isArray(collection)?arraySome:baseSome;if(guard && isIterateeCall(collection, predicate, guard)){predicate = undefined;}return func(collection, getIteratee(predicate, 3));}var sortBy=baseRest(function(collection, iteratees){if(collection == null){return [];}var length=iteratees.length;if(length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])){iteratees = [];}else if(length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])){iteratees = [iteratees[0]];}return baseOrderBy(collection, baseFlatten(iteratees, 1), []);});var now=ctxNow || function(){return root.Date.now();};function after(n, func){if(typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}n = toInteger(n);return function(){if(--n < 1){return func.apply(this, arguments);}};}function ary(func, n, guard){n = guard?undefined:n;n = func && n == null?func.length:n;return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);}function before(n, func){var result;if(typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}n = toInteger(n);return function(){if(--n > 0){result = func.apply(this, arguments);}if(n <= 1){func = undefined;}return result;};}var bind=baseRest(function(func, thisArg, partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials, getHolder(bind));bitmask |= WRAP_PARTIAL_FLAG;}return createWrap(func, bitmask, thisArg, partials, holders);});var bindKey=baseRest(function(object, key, partials){var bitmask=WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials, getHolder(bindKey));bitmask |= WRAP_PARTIAL_FLAG;}return createWrap(key, bitmask, object, partials, holders);});function curry(func, arity, guard){arity = guard?undefined:arity;var result=createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);result.placeholder = curry.placeholder;return result;}function curryRight(func, arity, guard){arity = guard?undefined:arity;var result=createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);result.placeholder = curryRight.placeholder;return result;}function debounce(func, wait, options){var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime=0, leading=false, maxing=false, trailing=true;if(typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}wait = toNumber(wait) || 0;if(isObject(options)){leading = !!options.leading;maxing = "maxWait" in options;maxWait = maxing?nativeMax(toNumber(options.maxWait) || 0, wait):maxWait;trailing = "trailing" in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs, thisArg=lastThis;lastArgs = lastThis = undefined;lastInvokeTime = time;result = func.apply(thisArg, args);return result;}function leadingEdge(time){lastInvokeTime = time;timerId = setTimeout(timerExpired, wait);return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time - lastCallTime, timeSinceLastInvoke=time - lastInvokeTime, timeWaiting=wait - timeSinceLastCall;return maxing?nativeMin(timeWaiting, maxWait - timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time - lastCallTime, timeSinceLastInvoke=time - lastInvokeTime;return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}timerId = setTimeout(timerExpired, remainingWait(time));}function trailingEdge(time){timerId = undefined;if(trailing && lastArgs){return invokeFunc(time);}lastArgs = lastThis = undefined;return result;}function cancel(){if(timerId !== undefined){clearTimeout(timerId);}lastInvokeTime = 0;lastArgs = lastCallTime = lastThis = timerId = undefined;}function flush(){return timerId === undefined?result:trailingEdge(now());}function debounced(){var time=now(), isInvoking=shouldInvoke(time);lastArgs = arguments;lastThis = this;lastCallTime = time;if(isInvoking){if(timerId === undefined){return leadingEdge(lastCallTime);}if(maxing){clearTimeout(timerId);timerId = setTimeout(timerExpired, wait);return invokeFunc(lastCallTime);}}if(timerId === undefined){timerId = setTimeout(timerExpired, wait);}return result;}debounced.cancel = cancel;debounced.flush = flush;return debounced;}var defer=baseRest(function(func, args){return baseDelay(func, 1, args);});var delay=baseRest(function(func, wait, args){return baseDelay(func, toNumber(wait) || 0, args);});function flip(func){return createWrap(func, WRAP_FLIP_FLAG);}function memoize(func, resolver){if(typeof func != "function" || resolver != null && typeof resolver != "function"){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=(function(_memoized){var _memoizedWrapper=function memoized(){return _memoized.apply(this, arguments);};_memoizedWrapper.toString = function(){return _memoized.toString();};return _memoizedWrapper;})(function(){var args=arguments, key=resolver?resolver.apply(this, args):args[0], cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this, args);memoized.cache = cache.set(key, result) || cache;return result;});memoized.cache = new (memoize.Cache || MapCache)();return memoized;}memoize.Cache = MapCache;function negate(predicate){if(typeof predicate != "function"){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return !predicate.call(this);case 1:return !predicate.call(this, args[0]);case 2:return !predicate.call(this, args[0], args[1]);case 3:return !predicate.call(this, args[0], args[1], args[2]);}return !predicate.apply(this, args);};}function once(func){return before(2, func);}var overArgs=castRest(function(func, transforms){transforms = transforms.length == 1 && isArray(transforms[0])?arrayMap(transforms[0], baseUnary(getIteratee())):arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1, length=nativeMin(args.length, funcsLength);while(++index < length) {args[index] = transforms[index].call(this, args[index]);}return apply(func, this, args);});});var partial=baseRest(function(func, partials){var holders=replaceHolders(partials, getHolder(partial));return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);});var partialRight=baseRest(function(func, partials){var holders=replaceHolders(partials, getHolder(partialRight));return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);});var rearg=flatRest(function(func, indexes){return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);});function rest(func, start){if(typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}start = start === undefined?start:toInteger(start);return baseRest(func, start);}function spread(func, start){if(typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}start = start == null?0:nativeMax(toInteger(start), 0);return baseRest(function(args){var array=args[start], otherArgs=castSlice(args, 0, start);if(array){arrayPush(otherArgs, array);}return apply(func, this, otherArgs);});}function throttle(func, wait, options){var leading=true, trailing=true;if(typeof func != "function"){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading = "leading" in options?!!options.leading:leading;trailing = "trailing" in options?!!options.trailing:trailing;}return debounce(func, wait, {leading:leading, maxWait:wait, trailing:trailing});}function unary(func){return ary(func, 1);}function wrap(value, wrapper){return partial(castFunction(wrapper), value);}function castArray(){if(!arguments.length){return [];}var value=arguments[0];return isArray(value)?value:[value];}function clone(value){return baseClone(value, CLONE_SYMBOLS_FLAG);}function cloneWith(value, customizer){customizer = typeof customizer == "function"?customizer:undefined;return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);}function cloneDeep(value){return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);}function cloneDeepWith(value, customizer){customizer = typeof customizer == "function"?customizer:undefined;return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);}function conformsTo(object, source){return source == null || baseConformsTo(object, source, keys(source));}function eq(value, other){return value === other || value !== value && other !== other;}var gt=createRelationalOperation(baseGt);var gte=createRelationalOperation(function(value, other){return value >= other;});var isArguments=baseIsArguments((function(){return arguments;})())?baseIsArguments:function(value){return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");};var isArray=Array.isArray;var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;function isArrayLike(value){return value != null && isLength(value.length) && !isFunction(value);}function isArrayLikeObject(value){return isObjectLike(value) && isArrayLike(value);}function isBoolean(value){return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;}var isBuffer=nativeIsBuffer || stubFalse;var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;function isElement(value){return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);}function isEmpty(value){if(value == null){return true;}if(isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))){return !value.length;}var tag=getTag(value);if(tag == mapTag || tag == setTag){return !value.size;}if(isPrototype(value)){return !baseKeys(value).length;}for(var key in value) {if(hasOwnProperty.call(value, key)){return false;}}return true;}function isEqual(value, other){return baseIsEqual(value, other);}function isEqualWith(value, other, customizer){customizer = typeof customizer == "function"?customizer:undefined;var result=customizer?customizer(value, other):undefined;return result === undefined?baseIsEqual(value, other, undefined, customizer):!!result;}function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);}function isFinite(value){return typeof value == "number" && nativeIsFinite(value);}function isFunction(value){if(!isObject(value)){return false;}var tag=baseGetTag(value);return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;}function isInteger(value){return typeof value == "number" && value == toInteger(value);}function isLength(value){return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;}function isObject(value){var type=typeof value;return value != null && (type == "object" || type == "function");}function isObjectLike(value){return value != null && typeof value == "object";}var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;function isMatch(object, source){return object === source || baseIsMatch(object, source, getMatchData(source));}function isMatchWith(object, source, customizer){customizer = typeof customizer == "function"?customizer:undefined;return baseIsMatch(object, source, getMatchData(source), customizer);}function isNaN(value){return isNumber(value) && value != +value;}function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}function isNull(value){return value === null;}function isNil(value){return value == null;}function isNumber(value){return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;}function isPlainObject(value){if(!isObjectLike(value) || baseGetTag(value) != objectTag){return false;}var proto=getPrototype(value);if(proto === null){return true;}var Ctor=hasOwnProperty.call(proto, "constructor") && proto.constructor;return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;}var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;function isSafeInteger(value){return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;}var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;function isString(value){return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;}function isSymbol(value){return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;}var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;function isUndefined(value){return value === undefined;}function isWeakMap(value){return isObjectLike(value) && getTag(value) == weakMapTag;}function isWeakSet(value){return isObjectLike(value) && baseGetTag(value) == weakSetTag;}var lt=createRelationalOperation(baseLt);var lte=createRelationalOperation(function(value, other){return value <= other;});function toArray(value){if(!value){return [];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator && value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value), func=tag == mapTag?mapToArray:tag == setTag?setToArray:values;return func(value);}function toFinite(value){if(!value){return value === 0?value:0;}value = toNumber(value);if(value === INFINITY || value === -INFINITY){var sign=value < 0?-1:1;return sign * MAX_INTEGER;}return value === value?value:0;}function toInteger(value){var result=toFinite(value), remainder=result % 1;return result === result?remainder?result - remainder:result:0;}function toLength(value){return value?baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH):0;}function toNumber(value){if(typeof value == "number"){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf == "function"?value.valueOf():value;value = isObject(other)?other + "":other;}if(typeof value != "string"){return value === 0?value:+value;}value = baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary || reIsOctal.test(value)?freeParseInt(value.slice(2), isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}function toPlainObject(value){return copyObject(value, keysIn(value));}function toSafeInteger(value){return value?baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER):value === 0?value:0;}function toString(value){return value == null?"":baseToString(value);}var assign=createAssigner(function(object, source){if(isPrototype(source) || isArrayLike(source)){copyObject(source, keys(source), object);return;}for(var key in source) {if(hasOwnProperty.call(source, key)){assignValue(object, key, source[key]);}}});var assignIn=createAssigner(function(object, source){copyObject(source, keysIn(source), object);});var assignInWith=createAssigner(function(object, source, srcIndex, customizer){copyObject(source, keysIn(source), object, customizer);});var assignWith=createAssigner(function(object, source, srcIndex, customizer){copyObject(source, keys(source), object, customizer);});var at=flatRest(baseAt);function create(prototype, properties){var result=baseCreate(prototype);return properties == null?result:baseAssign(result, properties);}var defaults=baseRest(function(object, sources){object = Object(object);var index=-1;var length=sources.length;var guard=length > 2?sources[2]:undefined;if(guard && isIterateeCall(sources[0], sources[1], guard)){length = 1;}while(++index < length) {var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex < propsLength) {var key=props[propsIndex];var value=object[key];if(value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)){object[key] = source[key];}}}return object;});var defaultsDeep=baseRest(function(args){args.push(undefined, customDefaultsMerge);return apply(mergeWith, undefined, args);});function findKey(object, predicate){return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);}function findLastKey(object, predicate){return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);}function forIn(object, iteratee){return object == null?object:baseFor(object, getIteratee(iteratee, 3), keysIn);}function forInRight(object, iteratee){return object == null?object:baseForRight(object, getIteratee(iteratee, 3), keysIn);}function forOwn(object, iteratee){return object && baseForOwn(object, getIteratee(iteratee, 3));}function forOwnRight(object, iteratee){return object && baseForOwnRight(object, getIteratee(iteratee, 3));}function functions(object){return object == null?[]:baseFunctions(object, keys(object));}function functionsIn(object){return object == null?[]:baseFunctions(object, keysIn(object));}function get(object, path, defaultValue){var result=object == null?undefined:baseGet(object, path);return result === undefined?defaultValue:result;}function has(object, path){return object != null && hasPath(object, path, baseHas);}function hasIn(object, path){return object != null && hasPath(object, path, baseHasIn);}var invert=createInverter(function(result, value, key){if(value != null && typeof value.toString != "function"){value = nativeObjectToString.call(value);}result[value] = key;}, constant(identity));var invertBy=createInverter(function(result, value, key){if(value != null && typeof value.toString != "function"){value = nativeObjectToString.call(value);}if(hasOwnProperty.call(result, value)){result[value].push(key);}else {result[value] = [key];}}, getIteratee);var invoke=baseRest(baseInvoke);function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object, true):baseKeysIn(object);}function mapKeys(object, iteratee){var result={};iteratee = getIteratee(iteratee, 3);baseForOwn(object, function(value, key, object){baseAssignValue(result, iteratee(value, key, object), value);});return result;}function mapValues(object, iteratee){var result={};iteratee = getIteratee(iteratee, 3);baseForOwn(object, function(value, key, object){baseAssignValue(result, key, iteratee(value, key, object));});return result;}var merge=createAssigner(function(object, source, srcIndex){baseMerge(object, source, srcIndex);});var mergeWith=createAssigner(function(object, source, srcIndex, customizer){baseMerge(object, source, srcIndex, customizer);});var omit=flatRest(function(object, paths){var result={};if(object == null){return result;}var isDeep=false;paths = arrayMap(paths, function(path){path = castPath(path, object);isDeep || (isDeep = path.length > 1);return path;});copyObject(object, getAllKeysIn(object), result);if(isDeep){result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);}var length=paths.length;while(length--) {baseUnset(result, paths[length]);}return result;});function omitBy(object, predicate){return pickBy(object, negate(getIteratee(predicate)));}var pick=flatRest(function(object, paths){return object == null?{}:basePick(object, paths);});function pickBy(object, predicate){if(object == null){return {};}var props=arrayMap(getAllKeysIn(object), function(prop){return [prop];});predicate = getIteratee(predicate);return basePickBy(object, props, function(value, path){return predicate(value, path[0]);});}function result(object, path, defaultValue){path = castPath(path, object);var index=-1, length=path.length;if(!length){length = 1;object = undefined;}while(++index < length) {var value=object == null?undefined:object[toKey(path[index])];if(value === undefined){index = length;value = defaultValue;}object = isFunction(value)?value.call(object):value;}return object;}function set(object, path, value){return object == null?object:baseSet(object, path, value);}function setWith(object, path, value, customizer){customizer = typeof customizer == "function"?customizer:undefined;return object == null?object:baseSet(object, path, value, customizer);}var toPairs=createToPairs(keys);var toPairsIn=createToPairs(keysIn);function transform(object, iteratee, accumulator){var isArr=isArray(object), isArrLike=isArr || isBuffer(object) || isTypedArray(object);iteratee = getIteratee(iteratee, 4);if(accumulator == null){var Ctor=object && object.constructor;if(isArrLike){accumulator = isArr?new Ctor():[];}else if(isObject(object)){accumulator = isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else {accumulator = {};}}(isArrLike?arrayEach:baseForOwn)(object, function(value, index, object){return iteratee(accumulator, value, index, object);});return accumulator;}function unset(object, path){return object == null?true:baseUnset(object, path);}function update(object, path, updater){return object == null?object:baseUpdate(object, path, castFunction(updater));}function updateWith(object, path, updater, customizer){customizer = typeof customizer == "function"?customizer:undefined;return object == null?object:baseUpdate(object, path, castFunction(updater), customizer);}function values(object){return object == null?[]:baseValues(object, keys(object));}function valuesIn(object){return object == null?[]:baseValues(object, keysIn(object));}function clamp(number, lower, upper){if(upper === undefined){upper = lower;lower = undefined;}if(upper !== undefined){upper = toNumber(upper);upper = upper === upper?upper:0;}if(lower !== undefined){lower = toNumber(lower);lower = lower === lower?lower:0;}return baseClamp(toNumber(number), lower, upper);}function inRange(number, start, end){start = toFinite(start);if(end === undefined){end = start;start = 0;}else {end = toFinite(end);}number = toNumber(number);return baseInRange(number, start, end);}function random(lower, upper, floating){if(floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)){upper = floating = undefined;}if(floating === undefined){if(typeof upper == "boolean"){floating = upper;upper = undefined;}else if(typeof lower == "boolean"){floating = lower;lower = undefined;}}if(lower === undefined && upper === undefined){lower = 0;upper = 1;}else {lower = toFinite(lower);if(upper === undefined){upper = lower;lower = 0;}else {upper = toFinite(upper);}}if(lower > upper){var temp=lower;lower = upper;upper = temp;}if(floating || lower % 1 || upper % 1){var rand=nativeRandom();return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);}return baseRandom(lower, upper);}var camelCase=createCompounder(function(result, word, index){word = word.toLowerCase();return result + (index?capitalize(word):word);});function capitalize(string){return upperFirst(toString(string).toLowerCase());}function deburr(string){string = toString(string);return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");}function endsWith(string, target, position){string = toString(string);target = baseToString(target);var length=string.length;position = position === undefined?length:baseClamp(toInteger(position), 0, length);var end=position;position -= target.length;return position >= 0 && string.slice(position, end) == target;}function escape(string){string = toString(string);return string && reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml, escapeHtmlChar):string;}function escapeRegExp(string){string = toString(string);return string && reHasRegExpChar.test(string)?string.replace(reRegExpChar, "\\$&"):string;}var kebabCase=createCompounder(function(result, word, index){return result + (index?"-":"") + word.toLowerCase();});var lowerCase=createCompounder(function(result, word, index){return result + (index?" ":"") + word.toLowerCase();});var lowerFirst=createCaseFirst("toLowerCase");function pad(string, length, chars){string = toString(string);length = toInteger(length);var strLength=length?stringSize(string):0;if(!length || strLength >= length){return string;}var mid=(length - strLength) / 2;return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);}function padEnd(string, length, chars){string = toString(string);length = toInteger(length);var strLength=length?stringSize(string):0;return length && strLength < length?string + createPadding(length - strLength, chars):string;}function padStart(string, length, chars){string = toString(string);length = toInteger(length);var strLength=length?stringSize(string):0;return length && strLength < length?createPadding(length - strLength, chars) + string:string;}function parseInt(string, radix, guard){if(guard || radix == null){radix = 0;}else if(radix){radix = +radix;}return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);}function repeat(string, n, guard){if(guard?isIterateeCall(string, n, guard):n === undefined){n = 1;}else {n = toInteger(n);}return baseRepeat(toString(string), n);}function replace(){var args=arguments, string=toString(args[0]);return args.length < 3?string:string.replace(args[1], args[2]);}var snakeCase=createCompounder(function(result, word, index){return result + (index?"_":"") + word.toLowerCase();});function split(string, separator, limit){if(limit && typeof limit != "number" && isIterateeCall(string, separator, limit)){separator = limit = undefined;}limit = limit === undefined?MAX_ARRAY_LENGTH:limit >>> 0;if(!limit){return [];}string = toString(string);if(string && (typeof separator == "string" || separator != null && !isRegExp(separator))){separator = baseToString(separator);if(!separator && hasUnicode(string)){return castSlice(stringToArray(string), 0, limit);}}return string.split(separator, limit);}var startCase=createCompounder(function(result, word, index){return result + (index?" ":"") + upperFirst(word);});function startsWith(string, target, position){string = toString(string);position = position == null?0:baseClamp(toInteger(position), 0, string.length);target = baseToString(target);return string.slice(position, position + target.length) == target;}function template(string, options, guard){var settings=lodash.templateSettings;if(guard && isIterateeCall(string, options, guard)){options = undefined;}string = toString(string);options = assignInWith({}, options, settings, customDefaultsAssignIn);var imports=assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys=keys(imports), importsValues=baseValues(imports, importsKeys);var isEscaping, isEvaluating, index=0, interpolate=options.interpolate || reNoMatch, source="__p += '";var reDelimiters=RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate?reEsTemplate:reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");var sourceURL="//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL")?(options.sourceURL + "").replace(/\s/g, " "):"lodash.templateSources[" + ++templateCounter + "]") + "\n";string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset){interpolateValue || (interpolateValue = esTemplateValue);source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);if(escapeValue){isEscaping = true;source += "' +\n__e(" + escapeValue + ") +\n'";}if(evaluateValue){isEvaluating = true;source += "';\n" + evaluateValue + ";\n__p += '";}if(interpolateValue){source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";}index = offset + match.length;return match;});source += "';\n";var variable=hasOwnProperty.call(options, "variable") && options.variable;if(!variable){source = "with (obj) {\n" + source + "\n}\n";}else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}source = (isEvaluating?source.replace(reEmptyStringLeading, ""):source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");source = "function(" + (variable || "obj") + ") {\n" + (variable?"":"obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping?", __e = _.escape":"") + (isEvaluating?", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n":";\n") + source + "return __p\n}";var result=attempt(function(){return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);});result.source = source;if(isError(result)){throw result;}return result;}function toLower(value){return toString(value).toLowerCase();}function toUpper(value){return toString(value).toUpperCase();}function trim(string, chars, guard){string = toString(string);if(string && (guard || chars === undefined)){return baseTrim(string);}if(!string || !(chars = baseToString(chars))){return string;}var strSymbols=stringToArray(string), chrSymbols=stringToArray(chars), start=charsStartIndex(strSymbols, chrSymbols), end=charsEndIndex(strSymbols, chrSymbols) + 1;return castSlice(strSymbols, start, end).join("");}function trimEnd(string, chars, guard){string = toString(string);if(string && (guard || chars === undefined)){return string.slice(0, trimmedEndIndex(string) + 1);}if(!string || !(chars = baseToString(chars))){return string;}var strSymbols=stringToArray(string), end=charsEndIndex(strSymbols, stringToArray(chars)) + 1;return castSlice(strSymbols, 0, end).join("");}function trimStart(string, chars, guard){string = toString(string);if(string && (guard || chars === undefined)){return string.replace(reTrimStart, "");}if(!string || !(chars = baseToString(chars))){return string;}var strSymbols=stringToArray(string), start=charsStartIndex(strSymbols, stringToArray(chars));return castSlice(strSymbols, start).join("");}function truncate(string, options){var length=DEFAULT_TRUNC_LENGTH, omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator="separator" in options?options.separator:separator;length = "length" in options?toInteger(options.length):length;omission = "omission" in options?baseToString(options.omission):omission;}string = toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength = strSymbols.length;}if(length >= strLength){return string;}var end=length - stringSize(omission);if(end < 1){return omission;}var result=strSymbols?castSlice(strSymbols, 0, end).join(""):string.slice(0, end);if(separator === undefined){return result + omission;}if(strSymbols){end += result.length - end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match, substring=result;if(!separator.global){separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");}separator.lastIndex = 0;while(match = separator.exec(substring)) {var newEnd=match.index;}result = result.slice(0, newEnd === undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator), end) != end){var index=result.lastIndexOf(separator);if(index > -1){result = result.slice(0, index);}}return result + omission;}function unescape(string){string = toString(string);return string && reHasEscapedHtml.test(string)?string.replace(reEscapedHtml, unescapeHtmlChar):string;}var upperCase=createCompounder(function(result, word, index){return result + (index?" ":"") + word.toUpperCase();});var upperFirst=createCaseFirst("toUpperCase");function words(string, pattern, guard){string = toString(string);pattern = guard?undefined:pattern;if(pattern === undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern) || [];}var attempt=baseRest(function(func, args){try{return apply(func, undefined, args);}catch(e) {return isError(e)?e:new Error(e);}});var bindAll=flatRest(function(object, methodNames){arrayEach(methodNames, function(key){key = toKey(key);baseAssignValue(object, key, bind(object[key], object));});return object;});function cond(pairs){var length=pairs == null?0:pairs.length, toIteratee=getIteratee();pairs = !length?[]:arrayMap(pairs, function(pair){if(typeof pair[1] != "function"){throw new TypeError(FUNC_ERROR_TEXT);}return [toIteratee(pair[0]), pair[1]];});return baseRest(function(args){var index=-1;while(++index < length) {var pair=pairs[index];if(apply(pair[0], this, args)){return apply(pair[1], this, args);}}});}function conforms(source){return baseConforms(baseClone(source, CLONE_DEEP_FLAG));}function constant(value){return function(){return value;};}function defaultTo(value, defaultValue){return value == null || value !== value?defaultValue:value;}var flow=createFlow();var flowRight=createFlow(true);function identity(value){return value;}function iteratee(func){return baseIteratee(typeof func == "function"?func:baseClone(func, CLONE_DEEP_FLAG));}function matches(source){return baseMatches(baseClone(source, CLONE_DEEP_FLAG));}function matchesProperty(path, srcValue){return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));}var method=baseRest(function(path, args){return function(object){return baseInvoke(object, path, args);};});var methodOf=baseRest(function(object, args){return function(path){return baseInvoke(object, path, args);};});function mixin(object, source, options){var props=keys(source), methodNames=baseFunctions(source, props);if(options == null && !(isObject(source) && (methodNames.length || !props.length))){options = source;source = object;object = this;methodNames = baseFunctions(source, keys(source));}var chain=!(isObject(options) && "chain" in options) || !!options.chain, isFunc=isFunction(object);arrayEach(methodNames, function(methodName){var func=source[methodName];object[methodName] = func;if(isFunc){object.prototype[methodName] = function(){var chainAll=this.__chain__;if(chain || chainAll){var result=object(this.__wrapped__), actions=result.__actions__ = copyArray(this.__actions__);actions.push({func:func, args:arguments, thisArg:object});result.__chain__ = chainAll;return result;}return func.apply(object, arrayPush([this.value()], arguments));};}});return object;}function noConflict(){if(root._ === this){root._ = oldDash;}return this;}function noop(){}function nthArg(n){n = toInteger(n);return baseRest(function(args){return baseNth(args, n);});}var over=createOver(arrayMap);var overEvery=createOver(arrayEvery);var overSome=createOver(arraySome);function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}function propertyOf(object){return function(path){return object == null?undefined:baseGet(object, path);};}var range=createRange();var rangeRight=createRange(true);function stubArray(){return [];}function stubFalse(){return false;}function stubObject(){return {};}function stubString(){return "";}function stubTrue(){return true;}function times(n, iteratee){n = toInteger(n);if(n < 1 || n > MAX_SAFE_INTEGER){return [];}var index=MAX_ARRAY_LENGTH, length=nativeMin(n, MAX_ARRAY_LENGTH);iteratee = getIteratee(iteratee);n -= MAX_ARRAY_LENGTH;var result=baseTimes(length, iteratee);while(++index < n) {iteratee(index);}return result;}function toPath(value){if(isArray(value)){return arrayMap(value, toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}function uniqueId(prefix){var id=++idCounter;return toString(prefix) + id;}var add=createMathOperation(function(augend, addend){return augend + addend;}, 0);var ceil=createRound("ceil");var divide=createMathOperation(function(dividend, divisor){return dividend / divisor;}, 1);var floor=createRound("floor");function max(array){return array && array.length?baseExtremum(array, identity, baseGt):undefined;}function maxBy(array, iteratee){return array && array.length?baseExtremum(array, getIteratee(iteratee, 2), baseGt):undefined;}function mean(array){return baseMean(array, identity);}function meanBy(array, iteratee){return baseMean(array, getIteratee(iteratee, 2));}function min(array){return array && array.length?baseExtremum(array, identity, baseLt):undefined;}function minBy(array, iteratee){return array && array.length?baseExtremum(array, getIteratee(iteratee, 2), baseLt):undefined;}var multiply=createMathOperation(function(multiplier, multiplicand){return multiplier * multiplicand;}, 1);var round=createRound("round");var subtract=createMathOperation(function(minuend, subtrahend){return minuend - subtrahend;}, 0);function sum(array){return array && array.length?baseSum(array, identity):0;}function sumBy(array, iteratee){return array && array.length?baseSum(array, getIteratee(iteratee, 2)):0;}lodash.after = after;lodash.ary = ary;lodash.assign = assign;lodash.assignIn = assignIn;lodash.assignInWith = assignInWith;lodash.assignWith = assignWith;lodash.at = at;lodash.before = before;lodash.bind = bind;lodash.bindAll = bindAll;lodash.bindKey = bindKey;lodash.castArray = castArray;lodash.chain = chain;lodash.chunk = chunk;lodash.compact = compact;lodash.concat = concat;lodash.cond = cond;lodash.conforms = conforms;lodash.constant = constant;lodash.countBy = countBy;lodash.create = create;lodash.curry = curry;lodash.curryRight = curryRight;lodash.debounce = debounce;lodash.defaults = defaults;lodash.defaultsDeep = defaultsDeep;lodash.defer = defer;lodash.delay = delay;lodash.difference = difference;lodash.differenceBy = differenceBy;lodash.differenceWith = differenceWith;lodash.drop = drop;lodash.dropRight = dropRight;lodash.dropRightWhile = dropRightWhile;lodash.dropWhile = dropWhile;lodash.fill = fill;lodash.filter = filter;lodash.flatMap = flatMap;lodash.flatMapDeep = flatMapDeep;lodash.flatMapDepth = flatMapDepth;lodash.flatten = flatten;lodash.flattenDeep = flattenDeep;lodash.flattenDepth = flattenDepth;lodash.flip = flip;lodash.flow = flow;lodash.flowRight = flowRight;lodash.fromPairs = fromPairs;lodash.functions = functions;lodash.functionsIn = functionsIn;lodash.groupBy = groupBy;lodash.initial = initial;lodash.intersection = intersection;lodash.intersectionBy = intersectionBy;lodash.intersectionWith = intersectionWith;lodash.invert = invert;lodash.invertBy = invertBy;lodash.invokeMap = invokeMap;lodash.iteratee = iteratee;lodash.keyBy = keyBy;lodash.keys = keys;lodash.keysIn = keysIn;lodash.map = map;lodash.mapKeys = mapKeys;lodash.mapValues = mapValues;lodash.matches = matches;lodash.matchesProperty = matchesProperty;lodash.memoize = memoize;lodash.merge = merge;lodash.mergeWith = mergeWith;lodash.method = method;lodash.methodOf = methodOf;lodash.mixin = mixin;lodash.negate = negate;lodash.nthArg = nthArg;lodash.omit = omit;lodash.omitBy = omitBy;lodash.once = once;lodash.orderBy = orderBy;lodash.over = over;lodash.overArgs = overArgs;lodash.overEvery = overEvery;lodash.overSome = overSome;lodash.partial = partial;lodash.partialRight = partialRight;lodash.partition = partition;lodash.pick = pick;lodash.pickBy = pickBy;lodash.property = property;lodash.propertyOf = propertyOf;lodash.pull = pull;lodash.pullAll = pullAll;lodash.pullAllBy = pullAllBy;lodash.pullAllWith = pullAllWith;lodash.pullAt = pullAt;lodash.range = range;lodash.rangeRight = rangeRight;lodash.rearg = rearg;lodash.reject = reject;lodash.remove = remove;lodash.rest = rest;lodash.reverse = reverse;lodash.sampleSize = sampleSize;lodash.set = set;lodash.setWith = setWith;lodash.shuffle = shuffle;lodash.slice = slice;lodash.sortBy = sortBy;lodash.sortedUniq = sortedUniq;lodash.sortedUniqBy = sortedUniqBy;lodash.split = split;lodash.spread = spread;lodash.tail = tail;lodash.take = take;lodash.takeRight = takeRight;lodash.takeRightWhile = takeRightWhile;lodash.takeWhile = takeWhile;lodash.tap = tap;lodash.throttle = throttle;lodash.thru = thru;lodash.toArray = toArray;lodash.toPairs = toPairs;lodash.toPairsIn = toPairsIn;lodash.toPath = toPath;lodash.toPlainObject = toPlainObject;lodash.transform = transform;lodash.unary = unary;lodash.union = union;lodash.unionBy = unionBy;lodash.unionWith = unionWith;lodash.uniq = uniq;lodash.uniqBy = uniqBy;lodash.uniqWith = uniqWith;lodash.unset = unset;lodash.unzip = unzip;lodash.unzipWith = unzipWith;lodash.update = update;lodash.updateWith = updateWith;lodash.values = values;lodash.valuesIn = valuesIn;lodash.without = without;lodash.words = words;lodash.wrap = wrap;lodash.xor = xor;lodash.xorBy = xorBy;lodash.xorWith = xorWith;lodash.zip = zip;lodash.zipObject = zipObject;lodash.zipObjectDeep = zipObjectDeep;lodash.zipWith = zipWith;lodash.entries = toPairs;lodash.entriesIn = toPairsIn;lodash.extend = assignIn;lodash.extendWith = assignInWith;mixin(lodash, lodash);lodash.add = add;lodash.attempt = attempt;lodash.camelCase = camelCase;lodash.capitalize = capitalize;lodash.ceil = ceil;lodash.clamp = clamp;lodash.clone = clone;lodash.cloneDeep = cloneDeep;lodash.cloneDeepWith = cloneDeepWith;lodash.cloneWith = cloneWith;lodash.conformsTo = conformsTo;lodash.deburr = deburr;lodash.defaultTo = defaultTo;lodash.divide = divide;lodash.endsWith = endsWith;lodash.eq = eq;lodash.escape = escape;lodash.escapeRegExp = escapeRegExp;lodash.every = every;lodash.find = find;lodash.findIndex = findIndex;lodash.findKey = findKey;lodash.findLast = findLast;lodash.findLastIndex = findLastIndex;lodash.findLastKey = findLastKey;lodash.floor = floor;lodash.forEach = forEach;lodash.forEachRight = forEachRight;lodash.forIn = forIn;lodash.forInRight = forInRight;lodash.forOwn = forOwn;lodash.forOwnRight = forOwnRight;lodash.get = get;lodash.gt = gt;lodash.gte = gte;lodash.has = has;lodash.hasIn = hasIn;lodash.head = head;lodash.identity = identity;lodash.includes = includes;lodash.indexOf = indexOf;lodash.inRange = inRange;lodash.invoke = invoke;lodash.isArguments = isArguments;lodash.isArray = isArray;lodash.isArrayBuffer = isArrayBuffer;lodash.isArrayLike = isArrayLike;lodash.isArrayLikeObject = isArrayLikeObject;lodash.isBoolean = isBoolean;lodash.isBuffer = isBuffer;lodash.isDate = isDate;lodash.isElement = isElement;lodash.isEmpty = isEmpty;lodash.isEqual = isEqual;lodash.isEqualWith = isEqualWith;lodash.isError = isError;lodash.isFinite = isFinite;lodash.isFunction = isFunction;lodash.isInteger = isInteger;lodash.isLength = isLength;lodash.isMap = isMap;lodash.isMatch = isMatch;lodash.isMatchWith = isMatchWith;lodash.isNaN = isNaN;lodash.isNative = isNative;lodash.isNil = isNil;lodash.isNull = isNull;lodash.isNumber = isNumber;lodash.isObject = isObject;lodash.isObjectLike = isObjectLike;lodash.isPlainObject = isPlainObject;lodash.isRegExp = isRegExp;lodash.isSafeInteger = isSafeInteger;lodash.isSet = isSet;lodash.isString = isString;lodash.isSymbol = isSymbol;lodash.isTypedArray = isTypedArray;lodash.isUndefined = isUndefined;lodash.isWeakMap = isWeakMap;lodash.isWeakSet = isWeakSet;lodash.join = join;lodash.kebabCase = kebabCase;lodash.last = last;lodash.lastIndexOf = lastIndexOf;lodash.lowerCase = lowerCase;lodash.lowerFirst = lowerFirst;lodash.lt = lt;lodash.lte = lte;lodash.max = max;lodash.maxBy = maxBy;lodash.mean = mean;lodash.meanBy = meanBy;lodash.min = min;lodash.minBy = minBy;lodash.stubArray = stubArray;lodash.stubFalse = stubFalse;lodash.stubObject = stubObject;lodash.stubString = stubString;lodash.stubTrue = stubTrue;lodash.multiply = multiply;lodash.nth = nth;lodash.noConflict = noConflict;lodash.noop = noop;lodash.now = now;lodash.pad = pad;lodash.padEnd = padEnd;lodash.padStart = padStart;lodash.parseInt = parseInt;lodash.random = random;lodash.reduce = reduce;lodash.reduceRight = reduceRight;lodash.repeat = repeat;lodash.replace = replace;lodash.result = result;lodash.round = round;lodash.runInContext = runInContext;lodash.sample = sample;lodash.size = size;lodash.snakeCase = snakeCase;lodash.some = some;lodash.sortedIndex = sortedIndex;lodash.sortedIndexBy = sortedIndexBy;lodash.sortedIndexOf = sortedIndexOf;lodash.sortedLastIndex = sortedLastIndex;lodash.sortedLastIndexBy = sortedLastIndexBy;lodash.sortedLastIndexOf = sortedLastIndexOf;lodash.startCase = startCase;lodash.startsWith = startsWith;lodash.subtract = subtract;lodash.sum = sum;lodash.sumBy = sumBy;lodash.template = template;lodash.times = times;lodash.toFinite = toFinite;lodash.toInteger = toInteger;lodash.toLength = toLength;lodash.toLower = toLower;lodash.toNumber = toNumber;lodash.toSafeInteger = toSafeInteger;lodash.toString = toString;lodash.toUpper = toUpper;lodash.trim = trim;lodash.trimEnd = trimEnd;lodash.trimStart = trimStart;lodash.truncate = truncate;lodash.unescape = unescape;lodash.uniqueId = uniqueId;lodash.upperCase = upperCase;lodash.upperFirst = upperFirst;lodash.each = forEach;lodash.eachRight = forEachRight;lodash.first = head;mixin(lodash, (function(){var source={};baseForOwn(lodash, function(func, methodName){if(!hasOwnProperty.call(lodash.prototype, methodName)){source[methodName] = func;}});return source;})(), {chain:false});lodash.VERSION = VERSION;arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName){lodash[methodName].placeholder = lodash;});arrayEach(["drop", "take"], function(methodName, index){LazyWrapper.prototype[methodName] = function(n){n = n === undefined?1:nativeMax(toInteger(n), 0);var result=this.__filtered__ && !index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__ = nativeMin(n, result.__takeCount__);}else {result.__views__.push({size:nativeMin(n, MAX_ARRAY_LENGTH), type:methodName + (result.__dir__ < 0?"Right":"")});}return result;};LazyWrapper.prototype[methodName + "Right"] = function(n){return this.reverse()[methodName](n).reverse();};});arrayEach(["filter", "map", "takeWhile"], function(methodName, index){var type=index + 1, isFilter=type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName] = function(iteratee){var result=this.clone();result.__iteratees__.push({iteratee:getIteratee(iteratee, 3), type:type});result.__filtered__ = result.__filtered__ || isFilter;return result;};});arrayEach(["head", "last"], function(methodName, index){var takeName="take" + (index?"Right":"");LazyWrapper.prototype[methodName] = function(){return this[takeName](1).value()[0];};});arrayEach(["initial", "tail"], function(methodName, index){var dropName="drop" + (index?"":"Right");LazyWrapper.prototype[methodName] = function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact = function(){return this.filter(identity);};LazyWrapper.prototype.find = function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast = function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap = baseRest(function(path, args){if(typeof path == "function"){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value, path, args);});});LazyWrapper.prototype.reject = function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice = function(start, end){start = toInteger(start);var result=this;if(result.__filtered__ && (start > 0 || end < 0)){return new LazyWrapper(result);}if(start < 0){result = result.takeRight(-start);}else if(start){result = result.drop(start);}if(end !== undefined){end = toInteger(end);result = end < 0?result.dropRight(-end):result.take(end - start);}return result;};LazyWrapper.prototype.takeRightWhile = function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray = function(){return this.take(MAX_ARRAY_LENGTH);};baseForOwn(LazyWrapper.prototype, function(func, methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName), isTaker=/^(?:head|last)$/.test(methodName), lodashFunc=lodash[isTaker?"take" + (methodName == "last"?"Right":""):methodName], retUnwrapped=isTaker || /^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName] = function(){var value=this.__wrapped__, args=isTaker?[1]:arguments, isLazy=value instanceof LazyWrapper, iteratee=args[0], useLazy=isLazy || isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash, arrayPush([value], args));return isTaker && chainAll?result[0]:result;};if(useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1){isLazy = useLazy = false;}var chainAll=this.__chain__, isHybrid=!!this.__actions__.length, isUnwrapped=retUnwrapped && !chainAll, onlyLazy=isLazy && !isHybrid;if(!retUnwrapped && useLazy){value = onlyLazy?value:new LazyWrapper(this);var result=func.apply(value, args);result.__actions__.push({func:thru, args:[interceptor], thisArg:undefined});return new LodashWrapper(result, chainAll);}if(isUnwrapped && onlyLazy){return func.apply(this, args);}result = this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName){var func=arrayProto[methodName], chainName=/^(?:push|sort|unshift)$/.test(methodName)?"tap":"thru", retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName] = function(){var args=arguments;if(retUnwrapped && !this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[], args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[], args);});};});baseForOwn(LazyWrapper.prototype, function(func, methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name + "";if(!hasOwnProperty.call(realNames, key)){realNames[key] = [];}realNames[key].push({name:methodName, func:lodashFunc});}});realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{name:"wrapper", func:undefined}];LazyWrapper.prototype.clone = lazyClone;LazyWrapper.prototype.reverse = lazyReverse;LazyWrapper.prototype.value = lazyValue;lodash.prototype.at = wrapperAt;lodash.prototype.chain = wrapperChain;lodash.prototype.commit = wrapperCommit;lodash.prototype.next = wrapperNext;lodash.prototype.plant = wrapperPlant;lodash.prototype.reverse = wrapperReverse;lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;lodash.prototype.first = lodash.prototype.head;if(symIterator){lodash.prototype[symIterator] = wrapperToIterator;}return lodash;};var _=runInContext();if(true){root._ = _;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return _;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else if(freeModule){(freeModule.exports = _)._ = _;freeExports._ = _;}else {root._ = _;}}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(255)(module)))

/***/ }),
/* 255 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
	
	var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var AdminSecurityPermissionsFormController = exports.AdminSecurityPermissionsFormController = (function () {
	    function AdminSecurityPermissionsFormController($scope, $state, $stateParams, $q, JFrogModal, JFrogGridFactory, RepoDataDao, PermissionsDao, User, ArtifactoryModelSaver, JFrogEventBus, BuildsDao, $timeout) {
	        _classCallCheck(this, AdminSecurityPermissionsFormController);
	
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$stateParams = $stateParams;
	        this.user = User.getCurrent();
	        this.modal = JFrogModal;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["permissionName", "buildPermission", "selectedRepositories", "repoPermission", "selectedBuilds", "selectedUsers", "selectedGroups"]);
	        this.$state = $state;
	        this.TOOLTIP = TOOLTIP.admin.security.permissionsForm;
	
	        // Daos
	        this.repoDataDao = RepoDataDao;
	        this.BuildsDao = BuildsDao;
	        this.permissionsDao = PermissionsDao.getInstance();
	
	        // Setups
	        this.title = "New Permission";
	        this.tabs = ["Add Repositories", "Add Builds", "Summary"];
	
	        this.selectedRepositories = [];
	        this.repoPermission = {};
	        this.selectedBuilds = [];
	        this.buildPermission = [];
	        this.selectedUsers = [];
	        this.selectedGroups = [];
	
	        this.buildPermission = {
	            includePatterns: [],
	            excludePatterns: []
	        };
	
	        this.newPermission = false;
	
	        // Drag & Drop Repositories columns
	        this.repositoriesColumns = [{
	            header: "Name",
	            field: "repoKey",
	            filterable: true,
	            cellTemplate: "<div><i class=\"{{row.entity._iconClass}}\"></i> {{row.entity.repoKey}}</div>",
	            width: "50%"
	        }];
	        // Drag & Drop Builds columns
	        this.buildsColumns = [{
	            header: "Build Name",
	            field: "buildName",
	            filterable: true,
	            cellTemplate: "<div><i class=\"icon-json\"></i> {{row.entity.buildName}}</div>",
	            width: "100%"
	        }];
	
	        var usersAndGroupsTemplate = {
	            field: "principal",
	            filterable: true,
	            cellTemplate: "<div disable-tooltip-on-overflow ng-if=\"row.entity.admin\">\n                                <span jf-tooltip=\"" + this.TOOLTIP.adminIcon.user + "\">\n                                    <i class=\"icon-admin-new\"></i> \n                                    {{row.entity.principal}}\n                                </span>\n                               </div><div ng-if=\"!row.entity.admin\">{{row.entity.principal}}</div>",
	            width: "100%"
	        };
	
	        this.usersColumns = [_.assign({ header: "User Name" }, usersAndGroupsTemplate)];
	        this.groupsColumns = [_.assign({ header: "Group Name" }, usersAndGroupsTemplate)];
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {});
	    }
	
	    _createClass(AdminSecurityPermissionsFormController, {
	        $onInit: {
	            value: function $onInit() {
	                this.initPermissionForm();
	            }
	        },
	        initPermissionForm: {
	            value: function initPermissionForm() {
	                var _this = this;
	
	                this.permissionsDao.getBuildGlobalBasicReadAllowed().$promise.then(function (response) {
	                    _this.globalBasicReadAllowed = response.buildGlobalBasicReadAllowed;
	                });
	
	                this._getAllRepos().then(function () {
	                    _this.availableRepositories = _.map(_this.allRepos, function (repo) {
	                        return _this.getRepoWithIcon(repo);
	                    });
	                }).then(function () {
	
	                    _this.$q.all([_this._getAllBuildsNames(), _this._getUsersAndGroups()]).then(function () {
	                        _this.savePending = false;
	                        if (_this.$stateParams.permission) {
	                            _this.newPermission = false;
	                            _this.title = "Edit " + _this.$stateParams.permission + " Permission";
	                            _this.initUpdatePermissionForm(_this.$stateParams.permission);
	                        } else {
	                            _this.newPermission = true;
	                            _this._initNewPermissionForm();
	                        }
	                    });
	                });
	            }
	        },
	        initUpdatePermissionForm: {
	            value: function initUpdatePermissionForm(permissionName) {
	                var _this = this;
	
	                this.permissionName = permissionName;
	                this.permissionsDao.getPermission({ name: permissionName }).$promise.then(function (result) {
	                    if (!_this.user.isAdmin() && _this.user.canManage) {
	                        if (!result.repoPermission) {
	                            _this.tabs.splice(_this.tabs.indexOf("Add Repositories"), 1);
	                            _this.switchedValue = "Add Builds";
	                        }
	                        if (!result.buildPermission) {
	                            _this.tabs.splice(_this.tabs.indexOf("Add Builds"), 1);
	                            _this.switchedValue = "Add Repositories";
	                        }
	                    }
	
	                    var setUpUsersAndGroups = function (data, context) {
	                        if (!data.length) return;
	
	                        // Get array of permissions and return object
	                        var formatPermissions = function (permissions) {
	                            var response = {};
	                            permissions.forEach(function (perm) {
	                                _.assign(response, _defineProperty({}, perm, true));
	                            });
	                            return response;
	                        };
	
	                        // sorting data of users and groups with there's permissions
	                        var sortItems = function (available, selected, target) {
	                            data.forEach(function (item) {
	                                var index = _.findIndex(available, function (i) {
	                                    return i.principal === item.principal;
	                                });
	                                if (index >= 0) {
	                                    var entity = available.splice(index, 1);
	                                    entity[0][target] = formatPermissions(item.actions);
	                                    entity[0].draggable = true;
	                                    selected.push(entity[0]);
	                                } else {
	                                    index = _.findIndex(selected, function (i) {
	                                        return i.principal === item.principal;
	                                    });
	                                    selected[index][target] = formatPermissions(item.actions);
	                                }
	                            });
	                        };
	
	                        if (context[0] === "repo" && context[1] === "user") sortItems(_this.availableUsers, _this.selectedUsers, "repoPermissions");
	                        if (context[0] === "repo" && context[1] === "group") sortItems(_this.availableGroups, _this.selectedGroups, "repoPermissions");
	                        if (context[0] === "build" && context[1] === "user") sortItems(_this.availableUsers, _this.selectedUsers, "buildsPermissions");
	                        if (context[0] === "build" && context[1] === "group") sortItems(_this.availableGroups, _this.selectedGroups, "buildsPermissions");
	                    };
	
	                    if (result.buildPermission) {
	                        _this.buildPermission.includePatterns = result.buildPermission.includePatterns || [];
	                        _this.buildPermission.excludePatterns = result.buildPermission.excludePatterns || [];
	
	                        if (_.includes(_this.buildPermission.includePatterns, "**")) _this.allBuilds = true;
	                        _this.updateBuildsList(true);
	
	                        if (result.buildPermission.groupPermissionActions) setUpUsersAndGroups(result.buildPermission.userPermissionActions, ["build", "user"]);
	                        if (result.buildPermission.groupPermissionActions) setUpUsersAndGroups(result.buildPermission.groupPermissionActions, ["build", "group"]);
	                    }
	
	                    if (result.repoPermission) {
	                        _this.repoPermission.includePatterns = result.repoPermission.includePatterns || [];
	                        _this.repoPermission.excludePatterns = result.repoPermission.excludePatterns || [];
	
	                        var repoKeys = result.repoPermission.repoKeys || [];
	
	                        if (repoKeys[0] === "ANY") {
	                            repoKeys = ["ANY LOCAL", "ANY REMOTE", "ANY DISTRIBUTION"];
	                        }
	
	                        if (_.includes(repoKeys, "ANY LOCAL") || _.includes(repoKeys, "ANY REMOTE") || _.includes(repoKeys, "ANY DISTRIBUTION")) {
	                            // includes any
	                            var anys = _.remove(repoKeys, function (repoKey) {
	                                return repoKey === "ANY LOCAL" || repoKey === "ANY REMOTE" || repoKey === "ANY DISTRIBUTION";
	                            });
	                            _.forEach(anys, function (any) {
	                                if (any === "ANY LOCAL") {
	                                    _this.anyLocal = true;
	                                    _this.setAnyRepoOfType("local", _this.anyLocal);
	                                }
	                                if (any === "ANY REMOTE") {
	                                    _this.anyRemote = true;
	                                    _this.setAnyRepoOfType("remote", _this.anyRemote);
	                                }
	                                if (any === "ANY DISTRIBUTION") {
	                                    _this.anyDistribution = true;
	                                    _this.setAnyRepoOfType("distribution", _this.anyDistribution);
	                                }
	                            });
	
	                            if (repoKeys.length) {
	                                repoKeys.forEach(function (repoKey) {
	
	                                    var moveToSelected = _.remove(_this.availableRepositories, function (repo) {
	                                        return repo.repoKey === repoKey;
	                                    });
	                                    _this.selectedRepositories.unshift(moveToSelected[0]);
	                                });
	                            }
	                        } else if (repoKeys.length) {
	                            repoKeys.forEach(function (repoKey) {
	                                var _selectedRepositories;
	
	                                (_selectedRepositories = _this.selectedRepositories).push.apply(_selectedRepositories, _toConsumableArray(_.remove(_this.availableRepositories, function (repo) {
	                                    return repo.repoKey === repoKey;
	                                })));
	                            });
	                        }
	
	                        if (result.repoPermission.userPermissionActions) setUpUsersAndGroups(result.repoPermission.userPermissionActions, ["repo", "user"]);
	                        if (result.repoPermission.groupPermissionActions) setUpUsersAndGroups(result.repoPermission.groupPermissionActions, ["repo", "group"]);
	                    }
	
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _getAllBuildsNames: {
	            value: function _getAllBuildsNames() {
	                var _this = this;
	
	                var deferred = this.$q.defer();
	                this.BuildsDao.getAllBuildsNames().$promise.then(function (response) {
	                    _this.availableBuilds = [];
	                    _.forEach(response, function (item) {
	                        return _this.availableBuilds.push({ buildName: item });
	                    });
	                    deferred.resolve();
	                });
	                return deferred.promise;
	            }
	        },
	        markAllBuilds: {
	            value: function markAllBuilds(isChecked) {
	
	                if (isChecked) {
	                    this.buildPermission.includePatterns.splice(0);
	                    this.buildPermission.includePatterns.push("**");
	                    this.buildsChange(true);
	                } else {
	                    var _availableBuilds;
	
	                    if (_.includes(this.buildPermission.includePatterns, "**")) this.buildPermission.includePatterns.splice(this.buildPermission.includePatterns.indexOf("**"), 1);
	                    var buildsToMove = this.selectedBuilds.splice(0);
	                    (_availableBuilds = this.availableBuilds).push.apply(_availableBuilds, _toConsumableArray(buildsToMove));
	                    this.availableBuilds.forEach(function (build) {
	                        return delete build.draggable;
	                    });
	                }
	            }
	        },
	        buildsChange: {
	            value: function buildsChange(markAll) {
	                var _this = this;
	
	                var _buildPermission$includePatterns;
	
	                this.selectedBuilds.map(function (i) {
	                    return i.draggable = false;
	                });
	
	                if (!markAll) {
	                    this.selectedBuilds.forEach(function (build) {
	                        _this.buildPermission.includePatterns.push(build.buildName + "/**");
	                    });
	                }
	
	                (_buildPermission$includePatterns = this.buildPermission.includePatterns).splice.apply(_buildPermission$includePatterns, [0, this.buildPermission.includePatterns.length].concat(_toConsumableArray(_.uniq(this.buildPermission.includePatterns))));
	                this.updateBuildsList();
	            }
	        },
	        reposChanged: {
	            value: function reposChanged() {
	                if (this.selectedRepositories.length === 0) {
	                    this.selectedUsers.forEach(function (user) {
	                        return delete user.repoPermissions;
	                    });
	                    this.selectedGroups.forEach(function (group) {
	                        return delete group.repoPermissions;
	                    });
	                }
	            }
	        },
	        updateBuildsList: {
	            value: function updateBuildsList(saveModel) {
	                var _this = this;
	
	                var payload = { includePatterns: this.buildPermission.includePatterns, excludePatterns: this.buildPermission.excludePatterns };
	                this.permissionsDao.buildPatterns(payload).$promise.then(function (response) {
	                    var _availableBuilds;
	
	                    var selectedBuildsByPatterns = response.builds;
	
	                    // reset all items (move all items to available)
	                    var itemsToReset = _this.selectedBuilds.splice(0);
	                    (_availableBuilds = _this.availableBuilds).push.apply(_availableBuilds, _toConsumableArray(itemsToReset));
	                    _this.availableBuilds.map(function (build) {
	                        return delete build.draggable;
	                    });
	
	                    // Itereate all builds list and set them in the selected builds list
	                    if (!_this.buildPermission.includePatterns.length && !_this.buildPermission.excludePatterns.length) {
	                        _this.selectedUsers.forEach(function (user) {
	                            return delete user.buildsPermissions;
	                        });
	                        _this.selectedGroups.forEach(function (group) {
	                            return delete group.buildsPermissions;
	                        });
	                        return;
	                    }
	
	                    selectedBuildsByPatterns.forEach(function (buildName) {
	                        var _selectedBuilds;
	
	                        var buildToMove = _.remove(_this.availableBuilds, function (build) {
	                            return build.buildName === buildName;
	                        });
	                        if (buildToMove) (_selectedBuilds = _this.selectedBuilds).push.apply(_selectedBuilds, _toConsumableArray(buildToMove));
	                        _this.selectedBuilds.map(function (build) {
	                            return build.draggable = false;
	                        });
	                    });
	
	                    if (saveModel) _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _getUsersAndGroups: {
	            value: function _getUsersAndGroups() {
	                var _this = this;
	
	                var deferred = this.$q.defer();
	                this.permissionsDao.getAllUsersAndGroups().$promise.then(function (response) {
	                    _this.availableUsers = response.allUsers;
	                    _this.availableGroups = response.allGroups;
	                }).then(function () {
	                    _.map(_this.availableUsers, function (i) {
	                        if (i.admin) i.draggable = false;
	                    });
	                    _this.availableUsers = _.sortBy(_this.availableUsers, function (user) {
	                        return !user.admin;
	                    });
	
	                    _.map(_this.availableGroups, function (i) {
	                        if (i.admin) i.draggable = false;
	                    });
	
	                    _this.availableGroups = _.sortBy(_this.availableGroups, function (group) {
	                        return !group.admin;
	                    });
	                    deferred.resolve();
	                });
	                return deferred.promise;
	            }
	        },
	        changeSelections: {
	            value: function changeSelections(type) {
	                if (type === "user") {
	                    this.availableUsers.forEach(function (user) {
	                        delete user.customClass;
	                        user.draggable = !user.admin;
	                    });
	                    if (_.includes(this.availableUsers, this.activeUser)) {
	                        delete this.activeUser;
	                    }
	
	                    var isAnyUserSelected = _.filter(this.selectedUsers, function (user) {
	                        return user.customClass;
	                    });
	                    if (this.selectedUsers.length && !isAnyUserSelected.length) {
	                        this.selectedUsers[0].customClass = "active";
	                        this.activeUser = this.selectedUsers[0];
	                    }
	                } else if (type === "group") {
	                    this.availableGroups.forEach(function (group) {
	                        return delete group.customClass;
	                    });
	                    if (_.includes(this.availableGroups, this.activeGroup)) {
	                        delete this.activeGroup;
	                    }
	
	                    var isAnyGroupSelected = _.filter(this.selectedGroups, function (group) {
	                        return group.customClass;
	                    });
	                    if (this.selectedGroups.length && !isAnyGroupSelected.length) {
	                        this.selectedGroups[0].customClass = "active";
	                        this.activeGroup = this.selectedGroups[0];
	                    }
	                }
	            }
	        },
	        _getAllRepos: {
	            value: function _getAllRepos() {
	                var _this = this;
	
	                var deferred = this.$q.defer();
	                this.repoDataDao.getAllForPerms({ permission: true }).$promise.then(function (result) {
	                    _this.allRepos = result.repoTypesList;
	                    deferred.resolve();
	                });
	                return deferred.promise;
	            }
	        },
	        getRepoWithIcon: {
	            value: function getRepoWithIcon(repo) {
	                repo._iconClass = "icon " + (repo.type === "local" ? "icon-local-repo" : repo.type === "remote" ? "icon-remote-repo" : repo.type === "virtual" ? "icon-virtual-repo" : repo.type === "distribution" ? "icon-distribution-repo" : "icon-notif-error");
	                return repo;
	            }
	        },
	        setAnyRepoOfType: {
	            value: function setAnyRepoOfType(type, isAnyRepoOfThisTypeCheckboxIsChecked) {
	                var _this = this;
	
	                if (isAnyRepoOfThisTypeCheckboxIsChecked) {
	                    this.availableRepositories.forEach(function (repo) {
	                        if (type === repo.type) {
	                            repo.draggable = false;
	                            if (!_.includes(_this.selectedRepositories, repo)) {
	                                // if the repo isn't exist in selected add it
	                                _this.selectedRepositories.push(repo);
	                            }
	                        }
	                    });
	                    this.selectedRepositories.forEach(function (repo) {
	                        if (type === repo.type) {
	                            repo.draggable = false;
	                        }
	                    });
	                    _.remove(this.availableRepositories, { type: type }); // remove all this type from the available
	                } else {
	
	                    this.selectedRepositories.forEach(function (repo) {
	                        if (type === repo.type && !_.includes(_this.availableRepositories, repo)) {
	                            delete repo.draggable;
	                            _this.availableRepositories.push(repo);
	                        }
	                    });
	                    _.remove(this.selectedRepositories, { type: type });
	                }
	
	                this.reposChanged();
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.savePending) {
	                    return;
	                }
	
	                this.savePending = true;
	
	                // Get selected repo keys
	                var getSelectedRepoKeys = function () {
	                    var anyRepositories = _.pickBy({ "ANY LOCAL": _this.anyLocal, "ANY REMOTE": _this.anyRemote, "ANY DISTRIBUTION": _this.anyDistribution }, _.identity);
	                    var selectedRepositories = [].concat(_toConsumableArray(_this.selectedRepositories));
	
	                    if (!_.isEmpty(anyRepositories)) {
	                        if (_this.anyLocal && _this.anyRemote && _this.anyDistribution) return ["ANY"];
	
	                        Object.keys(anyRepositories).forEach(function (i) {
	                            if (i === "ANY LOCAL") _.remove(selectedRepositories, function (repo) {
	                                return repo.type === "local";
	                            });
	                            if (i === "ANY REMOTE") _.remove(selectedRepositories, function (repo) {
	                                return repo.type === "remote";
	                            });
	                            if (i === "ANY DISTRIBUTION") _.remove(selectedRepositories, function (repo) {
	                                return repo.type === "distribution";
	                            });
	                        });
	                    }
	
	                    var selectedRepositoriesRepoKeys = _.map(selectedRepositories, function (i) {
	                        return i.repoKey;
	                    });
	                    var repoKeys = [].concat(_toConsumableArray(Object.keys(anyRepositories)), _toConsumableArray(selectedRepositoriesRepoKeys));
	
	                    return repoKeys;
	                };
	
	                // Get permissions object and return array
	                var setPermissionsActionsArray = function (actions) {
	                    if (!actions) return [];
	
	                    var response = [];
	
	                    _.forEach(actions, function (value, key) {
	                        if (value) response.push(key);
	                    });
	
	                    return response;
	                };
	
	                // Return permissions objects for user/groups repo/build
	                var getPermissionsActions = function (data, context) {
	                    var permissionsData = [];
	
	                    if (data.length) {
	                        if (context === "repo") {
	                            data.forEach(function (item) {
	                                if (item.repoPermissions) permissionsData.push({ principal: item.principal, actions: setPermissionsActionsArray(item.repoPermissions) });
	                            });
	                        } else if (context === "build") {
	                            data.forEach(function (item) {
	                                if (item.buildsPermissions) permissionsData.push({ principal: item.principal, actions: setPermissionsActionsArray(item.buildsPermissions) });
	                            });
	                        }
	                    }
	                    return permissionsData;
	                };
	
	                var permission = {
	                    name: this.permissionName,
	                    repoPermission: {
	                        repoKeys: getSelectedRepoKeys(),
	                        userPermissionActions: getPermissionsActions(this.selectedUsers, "repo"),
	                        groupPermissionActions: getPermissionsActions(this.selectedGroups, "repo"),
	                        includePatterns: this.repoPermission.includePatterns,
	                        excludePatterns: this.repoPermission.excludePatterns
	                    },
	                    buildPermission: {
	                        userPermissionActions: getPermissionsActions(this.selectedUsers, "build"),
	                        groupPermissionActions: getPermissionsActions(this.selectedGroups, "build"),
	                        includePatterns: this.buildPermission.includePatterns,
	                        excludePatterns: this.buildPermission.excludePatterns
	                    }
	                };
	
	                // delete repos/builds objects if non selected
	                if (!this.isBuildsSelected()) delete permission.buildPermission;
	                if (!this.isReposSelected()) delete permission.repoPermission;
	
	                if (this.newPermission) {
	                    // SET NEW PERMISSION
	                    this.permissionsDao.create(permission).$promise.then(function () {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.permissions");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                } else {
	                    // UPDATE EXISTING PERMISSION
	                    this.permissionsDao.update(permission).$promise.then(function () {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.permissions");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                }
	            }
	        },
	        formInvalid: {
	            value: function formInvalid() {
	                return this.savePending || this.form.$invalid || !this.permissionName || !this.isBuildsSelected() && !this.isReposSelected();
	            }
	        },
	        onRowClick: {
	            value: function onRowClick(row, list, context) {
	                if (list === "selected") {
	                    if (context === "user") {
	                        this.selectedUsers.forEach(function (i) {
	                            return delete i.customClass;
	                        });
	                        this.activeUser = _.find(this.selectedUsers, function (user) {
	                            return user.principal === row.principal;
	                        });
	                    } else if (context === "group") {
	                        this.selectedGroups.forEach(function (i) {
	                            return delete i.customClass;
	                        });
	                        this.activeGroup = _.find(this.selectedGroups, function (group) {
	                            return group.principal === row.principal;
	                        });
	                    }
	                    row.customClass = "active";
	                }
	            }
	        },
	        _initNewPermissionForm: {
	            value: function _initNewPermissionForm() {
	                this.anyLocal = this.anyRemote = this.anyDistribution = this.allBuilds = false;
	
	                this.repoPermission.includePatterns = ["**"];
	                this.repoPermission.excludePatterns = [];
	
	                this.buildPermission.includePatterns = [];
	                this.buildPermission.excludePatterns = [];
	            }
	        },
	        isBuildsSelected: {
	            value: function isBuildsSelected() {
	                return this.buildPermission.includePatterns.length >= 1 || this.buildPermission.excludePatterns.length >= 1;
	            }
	        },
	        isReposSelected: {
	            value: function isReposSelected() {
	                return this.selectedRepositories.length;
	            }
	        }
	    });
	
	    return AdminSecurityPermissionsFormController;
	})();

	// TODO UPDATE DATA WHEN CREATING NEW REPOS FROM QUICK WIZARD

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminSecurityUserController = __webpack_require__(258).AdminSecurityUserController;
	
	var AdminSecurityUserFormController = __webpack_require__(259).AdminSecurityUserFormController;
	
	function usersConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.users", {
	        url: "/users",
	        templateUrl: "states/admin/security/users/users.html",
	        controller: "AdminSecurityUserController as AdminSecurityUser"
	    }).state("admin.security.users.edit", {
	        parent: "admin.security",
	        url: "/users/{username}/edit",
	        templateUrl: "states/admin/security/users/user_form.html",
	        controller: "AdminSecurityUserFormController as UserForm"
	    }).state("admin.security.users.new", {
	        parent: "admin.security",
	        url: "/users/new",
	        templateUrl: "states/admin/security/users/user_form.html",
	        controller: "AdminSecurityUserFormController as UserForm"
	    });
	}
	
	module.exports = angular.module("security.users", []).config(usersConfig).controller("AdminSecurityUserController", AdminSecurityUserController).controller("AdminSecurityUserFormController", AdminSecurityUserFormController);

/***/ }),
/* 258 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminSecurityUserController = exports.AdminSecurityUserController = (function () {
	    function AdminSecurityUserController($state, JFrogModal, UserDao, $scope, GroupsDao, JFrogGridFactory, uiGridConstants, AdminSecurityGeneralDao, commonGridColumns) {
	        _classCallCheck(this, AdminSecurityUserController);
	
	        this.userDao = UserDao.getInstance();
	        this.adminSecurityGeneralDao = AdminSecurityGeneralDao;
	        this.uiGridConstants = uiGridConstants;
	        this.groupsDao = GroupsDao.getInstance();
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.commonGridColumns = commonGridColumns;
	        this.$scope = $scope;
	        this.$state = $state;
	        this._createGrid();
	        this._initUsers();
	    }
	
	    _createClass(AdminSecurityUserController, {
	        _initUsers: {
	            value: function _initUsers() {
	                var _this = this;
	
	                this.userDao.getAll().$promise.then(function (users) {
	                    //console.log(users);
	                    users.forEach(function (user) {
	                        user.permissions = _.map(user.permissionsList, "permissionName");
	                        user.effectiveAdmin = user.admin || user.groupAdmin;
	                    });
	                    _this.gridOption.setGridData(users);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setMultiSelect().setButtons(this._getActions()).setRowTemplate("default").setBatchActions(this._getBatchActions());
	
	                this.gridOption.isRowSelectable = function (row) {
	                    return row.entity.name !== "anonymous";
	                };
	            }
	        },
	        deleteUser: {
	            value: function deleteUser(user) {
	                var _this = this;
	
	                var json = { userNames: [user.name] };
	                this.modal.confirm("Are you sure you want to delete user '" + user.name + "?'").then(function () {
	                    return _this.userDao["delete"](json).$promise.then(function () {
	                        return _this._initUsers();
	                    });
	                });
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete() {
	                var _this = this;
	
	                // Get All selected users
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                // Create an array of the selected users names
	                var names = _.map(selectedRows, function (user) {
	                    return user.name;
	                });
	                // Create Json for the bulk request
	                var json = { userNames: names };
	                // console.log('Bulk delete....');
	                // Ask for confirmation before delete and if confirmed then delete bulk of users
	                this.modal.confirm("Are you sure you want to delete " + names.length + " users?").then(function () {
	                    return _this.userDao["delete"](json).$promise.then(function () {
	                        return _this._initUsers();
	                    });
	                });
	            }
	        },
	        updateUser: {
	            value: function updateUser(user) {
	                var _this = this;
	
	                this.userDao.update(user).$promise.then(function () {
	                    return _this._initUsers();
	                });
	            }
	        },
	        checkExternalStatus: {
	            value: function checkExternalStatus(user) {
	                this.userDao.checkExternalStatus(user).$promise.then(function (dataRes) {
	                    //            console.log(dataRes);
	                    user.externalRealmStatus = dataRes.data.externalRealmStatus;
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" ui-sref=\"^.users.edit({username: row.entity.name})\"><a href=\"\" class=\"jf-link\">{{row.entity.name}}</a></div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "33%"
	                    //width: '15%'
	                }, {
	                    name: "Email",
	                    displayName: "Email",
	                    field: "email",
	                    width: "15%"
	                }, {
	                    name: "Realm",
	                    displayName: "Realm",
	                    field: "realm",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.realm}}" + "<span ng-if=\"row.entity.externalRealmStatus\"> | {{row.entity.externalRealmStatus}}</span>" + "<span ng-if=\"!row.entity.externalRealmStatus && row.entity.externalRealmLink\"> | <a href=\"\" ng-click=\"grid.appScope.AdminSecurityUser.checkExternalStatus(row.entity)\" class=\"jf-link\">{{row.entity.externalRealmLink}}</a></span></div>",
	                    width: "10%"
	                }, {
	                    field: "groups",
	                    name: "Related Groups",
	                    displayName: "Related Groups",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.groups", "row.entity.name"),
	                    width: "18%"
	                }, /*
	                   {
	                     field: "permissions",
	                     name: "Related Permissions",
	                     displayName: "Related Permissions",
	                     cellTemplate: this.commonGridColumns.listableColumn('row.entity.permissions','row.entity.name'),
	                     width: '18%'
	                   },*/
	                {
	                    name: "Admin",
	                    displayName: "Admin",
	                    field: "effectiveAdmin",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectiveAdmin"),
	                    width: "7%"
	                }, {
	                    name: "Lock",
	                    displayName: "Locked",
	                    field: "locked",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-lock\" ng-if=\"row.entity.locked\" cm-aditional-action=\"Unlock\" ng-click=\"grid.appScope.AdminSecurityUser.unlockUsers(row.entity.name)\" jf-tooltip=\"Unlock\"></a></div>",
	                    width: "7%"
	                }, {
	                    field: "lastLoggedInMillis",
	                    name: "Last Login",
	                    displayName: "Last Login",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.lastLoggedIn}}</div>",
	                    width: "10%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteUser(row);
	                    },
	                    visibleWhen: function (row) {
	                        return row.name != "anonymous";
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.bulkDelete();
	                    }
	                }, {
	                    icon: "unlock",
	                    name: "Unlock",
	                    callback: function () {
	                        return _this.bulkUnlock();
	                    },
	                    disabledWhen: function () {
	                        return !_this.hasSelectedUnlockedUsers();
	                    }
	                }];
	            }
	        },
	        unlockUsers: {
	            value: function unlockUsers(users) {
	                var _this = this;
	
	                if (!_.isArray(users)) users = [users];
	
	                this.adminSecurityGeneralDao.unlockUsers({}, users).$promise.then(function (res) {
	                    if (res.status === 200) {
	                        _this._initUsers();
	                    }
	                });
	            }
	        },
	        hasSelectedUnlockedUsers: {
	            value: function hasSelectedUnlockedUsers() {
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                return _.find(selectedRows, { locked: true });
	            }
	        },
	        bulkUnlock: {
	            value: function bulkUnlock() {
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                var locked = _.filter(selectedRows, function (row) {
	                    return row.locked;
	                });
	                var names = _.map(locked, "name");
	                this.unlockUsers(names);
	            }
	        }
	    });
	
	    return AdminSecurityUserController;
	})();

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var ACTIONS = _interopRequire(__webpack_require__(260));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var MESSAGES = _interopRequire(__webpack_require__(190));
	
	var merge = _interopRequire(__webpack_require__(261));
	
	var AdminSecurityUserFormController = exports.AdminSecurityUserFormController = (function () {
	    function AdminSecurityUserFormController($scope, $state, $stateParams, $timeout, $q, $http, RESOURCE, JFrogGridFactory, UserDao, GroupsDao, GroupPermissionsDao, AdminSecurityGeneralDao, User, uiGridConstants, commonGridColumns, ArtifactoryModelSaver, RepositoriesDao, UserProfileDao, JFrogModal, JFrogNotifications, ArtifactoryState, FooterDao) {
	        var _this = this;
	
	        _classCallCheck(this, AdminSecurityUserFormController);
	
	        this.$scope = $scope;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.$http = $http;
	        this.RESOURCE = RESOURCE;
	        this.User = User;
	        this.repositoriesDao = RepositoriesDao;
	        this.adminSecurityGeneralDao = AdminSecurityGeneralDao;
	        this.modal = JFrogModal;
	        this.userDao = UserDao.getInstance();
	        this.groupsDao = GroupsDao.getInstance();
	        this.groupPermissionsDao = GroupPermissionsDao.getInstance();
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["userdata", "input"], ["locked"]);
	        this.permissionsGridOptions = {};
	        this.buildsPermissionsGridOptions = {};
	        this.userProfileDao = UserProfileDao;
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.TOOLTIP = TOOLTIP.admin.security.usersForm;
	        this.MESSAGES = MESSAGES.admin.security.users.userForm;
	        this.input = {};
	        this.artifactoryState = ArtifactoryState;
	        this.emailChanged = false;
	        this.setDisabledChecked = true;
	        this.passwordRank = 0;
	        this.lastSavedUserSettings = {};
	        this.footerDao = FooterDao;
	
	        this._getPasswordExpirationState();
	
	        if ($stateParams.username) {
	            this.mode = "edit";
	            this.username = $stateParams.username;
	            this.title = "Edit " + this.username + " User";
	            this._getUserData();
	        } else {
	            this.mode = "create";
	            this.title = "Add New User";
	            this.userdata = {
	                groups: [],
	                profileUpdatable: true,
	                disableUIAccess: false,
	                internalPasswordDisabled: false
	            };
	            this.saveCheckboxes();
	        }
	        this._createGrid();
	        this._getAllRepos();
	        this._getAllGroups();
	
	        this.footerDao.get().then(function (response) {
	            _this.xrayEnabled = response.xrayEnabled;
	        });
	    }
	
	    _createClass(AdminSecurityUserFormController, {
	        userIsEffectiveAdmin: {
	            value: function userIsEffectiveAdmin() {
	                return this.userdata.admin || this.isInAdminGroup;
	            }
	        },
	        _getAllRepos: {
	            value: function _getAllRepos() {
	                var _this = this;
	
	                this.reposData = {};
	                this.repositoriesDao.getRepositories({ type: "local" }).$promise.then(function (data) {
	                    _this.reposData.locals = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	                this.repositoriesDao.getRepositories({ type: "remote" }).$promise.then(function (data) {
	                    _this.reposData.remotes = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	                this.repositoriesDao.getRepositories({ type: "distribution" }).$promise.then(function (data) {
	                    _this.reposData.dists = _.map(data, function (r) {
	                        return r.repoKey;
	                    });
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.permissionsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getPermissionColumns()).setRowTemplate("default");
	
	                this.buildsPermissionsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getBuildPermissionCloumns()).setRowTemplate("default");
	            }
	        },
	        _getAllGroups: {
	            value: function _getAllGroups() {
	                var _this = this;
	
	                this.userDao.getAllGroups().$promise.then(function (data) {
	                    _this.groupsData = data;
	                    _this.groupsList = _.map(_this.groupsData, function (group) {
	                        if (group.autoJoin && _this.mode === "create") {
	                            _this.userdata.groups.push(group.groupName);
	                            _this.ArtifactoryModelSaver.save();
	                        }
	                        return group.groupName;
	                    });
	                    if (_this.mode === "create") {
	                        _this._getGroupsPermissions();
	                    }
	
	                    _this.groupDndTemplate = "<div style=\"min-width:200px\">\n                                        {{getItemInfo().text}}\n                                        <i ng-if=\"userScope.UserForm.groupIsAdmin(getItemInfo().text)\" \n                                           jf-tooltip=\"Admin Privileges\"\n                                           class=\"icon icon-admin-new pull-left\"></i>\n                                        <i ng-if=\"!userScope.UserForm.groupIsAdmin(getItemInfo().text)\" \n                                            class=\"icon icon-blank pull-left\"></i>\n                                    </div>";
	                });
	            }
	        },
	        _getUserPermissions: {
	            value: function _getUserPermissions() {
	                var _this = this;
	
	                this.userDao.getPermissions({ userOnly: true }, { name: this.username }).$promise.then(function (data) {
	                    _this.userRepoPermissions = data.repoPermissions;
	                    _this.userBuildPermissions = data.buildPermissions;
	                    if (!_this.userdata.groups || !_this.userdata.groups.length || _this.groupsRepoPermissions || _this.groupsBuildPermissions) {
	                        _this._setGridData();
	                    }
	                });
	            }
	        },
	        _getGroupsPermissions: {
	            value: function _getGroupsPermissions() {
	                var _this = this;
	
	                if (!this.userdata) {
	                    return;
	                }if (!this.userdata.groups || !this.userdata.groups.length) {
	                    this.groupsRepoPermissions = [];
	                    this.groupsBuildPermissions = [];
	                    if (this.mode === "create") {
	                        this.permissionsGridOptions.setGridData(this.groupsRepoPermissions);
	                        this.buildsPermissionsGridOptions.setGridData(this.groupsBuildPermissions);
	                    } else if (this.userRepoPermissions || this.userBuildPermissions) {
	                        this._setGridData();
	                    }
	                } else {
	                    this.groupPermissionsDao.get({ groups: this.userdata.groups }).$promise.then(function (data) {
	
	                        var groupByPermissionName = function (data) {
	
	                            var groups = _.groupBy(data, function (i) {
	                                return i.permissionName;
	                            });
	                            var permissionsKeys = Object.keys(groups);
	
	                            var newPermissionObject = {};
	                            _.forEach(permissionsKeys, function (key) {
	                                // copy the first item as basis
	                                newPermissionObject[key] = angular.copy(groups[key][0]);
	
	                                var unifiedPermissions = [];
	                                if (groups[key].length > 1) {
	                                    (function () {
	                                        // if more than 1 permission re-create the object
	                                        delete newPermissionObject[key].effectivePermission;
	
	                                        _.forEach(groups[key], function (group) {
	                                            return unifiedPermissions.push(group.effectivePermission);
	                                        });
	
	                                        var principals = _.map(unifiedPermissions, "principal").join(", ");
	
	                                        var permissionsBase = {
	                                            "delete": false,
	                                            deploy: false,
	                                            annotate: false,
	                                            read: false,
	                                            managed: false
	                                        };
	
	                                        _.forEach(unifiedPermissions, function (permissionsSet) {
	                                            var cleanObject = _.pick(permissionsSet, ["delete", "deploy", "annotate", "read", "managed"]);
	                                            _.forEach(cleanObject, function (val, key) {
	                                                if (val) permissionsBase[key] = val;
	                                            });
	                                        });
	
	                                        newPermissionObject[key].effectivePermission = {
	                                            principal: principals
	                                        };
	
	                                        merge(newPermissionObject[key].effectivePermission, permissionsBase);
	                                    })();
	                                }
	                            });
	
	                            return Object.values(newPermissionObject);
	                        };
	
	                        _this.groupsRepoPermissions = groupByPermissionName(data.repoPermissions);
	                        // create joined repositories list for the table
	                        _.forEach(_this.groupsRepoPermissions, function (item) {
	                            return item.repoKeysList = item.repoKeys.join(", ");
	                        });
	
	                        _this.groupsBuildPermissions = groupByPermissionName(data.buildPermissions);
	
	                        if (_this.mode === "create") {
	                            _this.permissionsGridOptions.setGridData(_this.groupsRepoPermissions);
	                            _this.buildsPermissionsGridOptions.setGridData(_this.groupsBuildPermissions);
	                        } else if (_this.userRepoPermissions || _this.userBuildPermissions) {
	                            _this._setGridData();
	                        }
	                    });
	                }
	            }
	        },
	        _setGridData: {
	            value: function _setGridData() {
	                var _this = this;
	
	                var groupsRepoPermissions = this.groupsRepoPermissions || [];
	                var groupsBuildPermissions = this.groupsBuildPermissions || [];
	
	                this.buildsPermissionsGridOptions.setGridData(this.userBuildPermissions.concat(groupsBuildPermissions));
	
	                this._fixDataFormat(this.userRepoPermissions).then(function (fixedData) {
	                    _this.permissionsGridOptions.setGridData(fixedData.concat(groupsRepoPermissions));
	                });
	            }
	        },
	        _fixDataFormat: {
	            value: function _fixDataFormat(data) {
	                var _this = this;
	
	                var defer = arguments[1] === undefined ? null : arguments[1];
	
	                defer = defer || this.$q.defer();
	                if (this.reposData.locals && this.reposData.remotes) {
	                    data.forEach(function (record) {
	                        if (record.repoKeys && record.repoKeys.length === 1 && record.repoKeys[0] === "ANY LOCAL") {
	                            record.repoKeysView = "ANY LOCAL";
	                            record.reposList = angular.copy(_this.reposData.locals);
	                        } else if (record.repoKeys && record.repoKeys.length === 1 && record.repoKeys[0] === "ANY REMOTE") {
	                            record.repoKeysView = "ANY REMOTE";
	                            record.reposList = angular.copy(_this.reposData.remotes);
	                        } else if (record.repoKeys && record.repoKeys.length === 1 && record.repoKeys[0] === "ANY DISTRIBUTION") {
	                            record.repoKeysView = "ANY DISTRIBUTION";
	                            record.reposList = angular.copy(_this.reposData.dists);
	                        } else if (record.repoKeys && record.repoKeys.length === 1 && record.repoKeys[0] === "ANY") {
	                            record.repoKeysView = "ANY";
	                            record.reposList = angular.copy(_this.reposData.remotes).concat(_this.reposData.locals).concat(_this.reposData.dists);
	                        } else if (record.repoKeys) {
	                            record.repoKeysView = record.repoKeys.join(", ");
	                            record.reposList = angular.copy(record.repoKeys);
	                        }
	                    });
	                    defer.resolve(data);
	                } else {
	                    this.$timeout(function () {
	                        _this._fixDataFormat(data, defer);
	                    });
	                }
	                return defer.promise;
	            }
	        },
	        _getUserData: {
	            value: function _getUserData() {
	                var _this = this;
	
	                this.userDao.getSingle({ name: this.username }).$promise.then(function (data) {
	                    _this.userdata = data.data;
	                    _this._getUserPermissions();
	                    _this.isInAdminGroup = _this.userdata.groupAdmin;
	
	                    if (_this.userdata.internalPasswordDisabled) {
	                        _this.passwordOriginalyDisabled = true;
	                    }
	                    if (!_this.userdata.groups) {
	                        _this.userdata.groups = [];
	                    } else {
	                        _this._getGroupsPermissions();
	                    }
	                    _this.saveCheckboxes();
	                    _this.ArtifactoryModelSaver.save();
	                });
	                this._getApiKeyState();
	            }
	        },
	        _getApiKeyState: {
	            value: function _getApiKeyState() {
	                var _this = this;
	
	                this.userProfileDao.hasApiKey({}, { username: this.username }).$promise.then(function (res) {
	                    _this.apiKeyExist = true;
	                })["catch"](function () {
	                    _this.apiKeyExist = false;
	                });
	            }
	        },
	        _fixGroups: {
	            value: function _fixGroups(userdata) {
	                var _this = this;
	
	                var groups = userdata.groups;
	                var groupsObjects = [];
	                groups.forEach(function (group) {
	                    var realm = _.find(_this.groupsData, { groupName: group }).realm;
	                    groupsObjects.push({ groupName: group, realm: realm });
	                });
	                delete userdata.groups;
	                userdata.userGroups = groupsObjects;
	            }
	        },
	        onEmailChanged: {
	            value: function onEmailChanged() {
	                this.emailChanged = true;
	            }
	        },
	        updateUser: {
	            value: function updateUser() {
	                var _this = this;
	
	                var payload = angular.copy(this.userdata);
	                _.extend(payload, this.input);
	                this._fixGroups(payload);
	                this.userDao.update({ name: this.userdata.name }, payload).$promise.then(function (data) {
	                    _this.savePending = false;
	                    if (_this.userdata.name === _this.User.currentUser.name) {
	                        if (_this.emailChanged) {
	                            _this.artifactoryState.removeState("setMeUpUserData");
	                        }
	                        _this.User.reload();
	                    }
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.users");
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        createNewUser: {
	            value: function createNewUser() {
	                var _this = this;
	
	                var payload = angular.copy(this.userdata);
	                _.extend(payload, this.input);
	                this._fixGroups(payload);
	                this.userDao.create(payload).$promise.then(function (data) {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.$state.go("^.users");
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	
	                if (this.mode == "edit") this.updateUser();
	                if (this.mode == "create") this.createNewUser();
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.users");
	            }
	        },
	        deleteUser: {
	            value: function deleteUser() {
	                var _this = this;
	
	                var json = { userNames: [this.username] };
	                this.modal.confirm("Are you sure you want to delete user '" + this.username + "?'").then(function () {
	                    return _this.userDao["delete"](json).$promise.then(function () {
	                        return _this.cancel();
	                    });
	                });
	            }
	        },
	        userIsInAdminGroup: {
	            value: function userIsInAdminGroup() {
	                var groups = this.userdata.groups;
	                var groupsData = this.groupsData;
	                for (var i in groups) {
	                    for (var j = 0; j < groupsData.length; j++) {
	                        if (groupsData[j].name === groups[i] && groupsData[j].adminPrivileges) {
	                            return true;
	                        }
	                    }
	                }
	                return false;
	            }
	        },
	        groupIsAdmin: {
	            value: function groupIsAdmin(group) {
	                return _.find(this.groupsData, { groupName: group, adminPrivileges: true });
	            }
	        },
	        onCheckboxChanged: {
	            value: function onCheckboxChanged() {
	                this.saveCheckboxes();
	            }
	        },
	        saveCheckboxes: {
	            value: function saveCheckboxes() {
	                this.lastSavedUserSettings = {
	                    disableUIAccess: this.userdata.disableUIAccess,
	                    profileUpdatable: this.userdata.profileUpdatable,
	                    internalPasswordDisabled: this.userdata.internalPasswordDisabled };
	            }
	        },
	        onChangeGroups: {
	            value: function onChangeGroups() {
	                var _this = this;
	
	                this._getGroupsPermissions();
	                if (this.mode === "edit") this._getUserPermissions();
	                this.$timeout(function () {
	                    _this.isInAdminGroup = _this.userIsInAdminGroup();
	                    // Save last user settings before making changes
	                    if (_this.isInAdminGroup || _this.userdata.admin) {
	                        _this.userdata.disableUIAccess = false;
	                        _this.userdata.profileUpdatable = true;
	                        _this.userdata.internalPasswordDisabled = false;
	                    } else {
	                        _this.userdata.disableUIAccess = _this.lastSavedUserSettings.disableUIAccess;
	                        _this.userdata.profileUpdatable = _this.lastSavedUserSettings.profileUpdatable;
	                        _this.userdata.internalPasswordDisabled = _this.lastSavedUserSettings.internalPasswordDisabled;
	                    }
	                });
	            }
	        },
	        onClickAdmin: {
	            value: function onClickAdmin() {
	                if (this.userdata.admin) {
	                    this.userdata.profileUpdatable = true;
	                    this.userdata.internalPasswordDisabled = false;
	                    this.userdata.disableUIAccess = false;
	                }
	            }
	        },
	        _getBuildPermissionCloumns: {
	            value: function _getBuildPermissionCloumns() {
	                var nameCellTemplate = "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" href ui-sref=\"admin.security.permissions.edit({permission: row.entity.permissionName})\">{{row.entity.permissionName}}</a></div>";
	
	                var permissions = [{
	                    field: "permissionName",
	                    name: "Permission Target",
	                    displayName: "Permission Target",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: nameCellTemplate,
	                    width: "35%"
	                }, {
	                    field: "effectivePermission.principal",
	                    name: "Applied To",
	                    displayName: "Applied To",
	                    width: "40%"
	                }, {
	                    field: "effectivePermission.managed",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managed"),
	                    name: "Manage",
	                    displayName: "Manage",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.delete"),
	                    name: "Delete",
	                    displayName: "Delete",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.deploy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.deploy"),
	                    name: "Deploy",
	                    displayName: "Deploy",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.annotate",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.annotate"),
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.read",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.read"),
	                    name: "Read",
	                    displayName: "Read",
	                    width: "15%" }];
	
	                // TODO: liorg
	                // if (this.xrayEnabled) {
	                //     permissions.push(
	                //             {
	                //                 field: "effectivePermission.managedXrayMeta",
	                //                 cellTemplate: this.commonGridColumns.booleanColumn(
	                //                         'row.entity.effectivePermission.managedXrayMeta'),
	                //                 name: "ManagedXrayMeta",
	                //                 displayName: "Managed Xray Meta",
	                //                 width: '15%'
	                //             },
	                //             {
	                //                 field: "effectivePermission.managedXrayWatchers",
	                //                 cellTemplate: this.commonGridColumns.booleanColumn(
	                //                         'row.entity.effectivePermission.managedXrayWatchers'),
	                //                 name: "ManagedXrayWatchers",
	                //                 displayName: "Managed Xray Watchers",
	                //                 width: '15%',
	                //             }
	                //     );
	                // }
	                return permissions;
	            }
	        },
	        _getPermissionColumns: {
	            value: function _getPermissionColumns() {
	
	                var nameCellTemplate = "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" href ui-sref=\"admin.security.permissions.edit({permission: row.entity.permissionName})\">{{row.entity.permissionName}}</a></div>";
	
	                var permissions = [{
	                    field: "permissionName",
	                    name: "Permission Target",
	                    displayName: "Permission Target",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: nameCellTemplate,
	                    width: "16%"
	                }, {
	                    field: "repoKeys",
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.repoKeys", "row.entity.permissionName", "row.entity.repoKeysList", true),
	                    width: "16%"
	
	                }, {
	                    field: "effectivePermission.managed",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.managed"),
	                    name: "Manage",
	                    displayName: "Manage",
	                    width: "9%"
	                }, {
	                    field: "effectivePermission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.delete"),
	                    name: "Delete/Overwrite",
	                    displayName: "Delete/Overwrite",
	                    width: "15%"
	                }, {
	                    field: "effectivePermission.deploy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.deploy"),
	                    name: "Deploy/Cache",
	                    displayName: "Deploy/Cache",
	                    width: "14%"
	                }, {
	                    field: "effectivePermission.annotate",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.annotate"),
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    width: "9%"
	                }, {
	                    field: "effectivePermission.read",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.effectivePermission.read"),
	                    name: "Read",
	                    displayName: "Read",
	                    width: "8%"
	                }];
	
	                // TODO: liorg
	                // if (this.xrayEnabled) {
	                //     permissions.push(
	                //             {
	                //                 field: "effectivePermission.managedXrayMeta",
	                //                 cellTemplate: this.commonGridColumns.booleanColumn(
	                //                         'row.entity.effectivePermission.managedXrayMeta'),
	                //                 name: "ManagedXrayMeta",
	                //                 displayName: "Managed Xray Meta",
	                //                 width: '15%'
	                //             },
	                //             {
	                //                 field: "effectivePermission.managedXrayWatchers",
	                //                 cellTemplate: this.commonGridColumns.booleanColumn(
	                //                         'row.entity.effectivePermission.managedXrayWatchers'),
	                //                 name: "ManagedXrayWatchers",
	                //                 displayName: "Managed Xray Watchers",
	                //                 width: '15%',
	                //             });
	                // }
	                return permissions;
	            }
	        },
	        isSaveDisabled: {
	            value: function isSaveDisabled() {
	                return this.savePending || !this.userForm || this.userForm.$invalid || (this.input.password || this.input.retypePassword) && this.input.password !== this.input.retypePassword;
	            }
	        },
	        checkPwdMatch: {
	            value: function checkPwdMatch(retypeVal) {
	                return !retypeVal || retypeVal && this.input.password === retypeVal;
	            }
	        },
	        isAnonymous: {
	            value: function isAnonymous() {
	                return this.userdata.name === "anonymous";
	            }
	        },
	        revokeApiKey: {
	            value: function revokeApiKey() {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to revoke API key for user '" + this.username + "'?").then(function () {
	                    _this.userProfileDao.revokeApiKey({}, { username: _this.username }).$promise.then(function () {
	                        _this._getApiKeyState();
	                    });
	                });
	            }
	        },
	        unlockUser: {
	            value: function unlockUser() {
	                var _this = this;
	
	                this.adminSecurityGeneralDao.unlockUsers({}, [this.username]).$promise.then(function (res) {
	                    if (res.status === 200) {
	                        _this.userdata.locked = false;
	                    }
	                });
	            }
	        },
	        expirePassword: {
	            value: function expirePassword() {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to expire this user's password?").then(function () {
	                    _this.userDao.expirePassword({}, { username: _this.username }).$promise.then(function () {
	                        _this._getUserData();
	                    });
	                });
	            }
	        },
	        unexpirePassword: {
	            value: function unexpirePassword() {
	                var _this = this;
	
	                this.userDao.unExpirePassword({}, { username: this.username }).$promise.then(function () {
	                    _this._getUserData();
	                });
	            }
	        },
	        _getPasswordExpirationState: {
	            value: function _getPasswordExpirationState() {
	                var _this = this;
	
	                this.adminSecurityGeneralDao.get().$promise.then(function (data) {
	                    _this.passwordExpirationEnabled = data.passwordSettings.expirationPolicy.enabled;
	                    _this.userLockEnabled = data.userLockPolicy.enabled;
	                });
	            }
	        },
	        clearPasswordFields: {
	            value: function clearPasswordFields() {
	                delete this.input.password;
	                delete this.input.retypePassword;
	            }
	        },
	        onChangePasswordDisabled: {
	            value: function onChangePasswordDisabled() {
	                if (this.userdata.internalPasswordDisabled) {
	                    this.changePassword = false;
	                    this.clearPasswordFields();
	                    this.passwordReEnabled = false;
	                } else {
	                    if (this.passwordOriginalyDisabled) {
	                        this.passwordReEnabled = true;
	                    }
	                }
	                this.onCheckboxChanged();
	            }
	        },
	        initActions: {
	            value: function initActions(actionsController) {
	                var _this = this;
	
	                this.actionsController = actionsController;
	                actionsController.setActionsDictionary(ACTIONS);
	                actionsController.setActions([{
	                    name: "RevokeApiKey",
	                    visibleWhen: function () {
	                        return _this.userdata && _this.apiKeyExist && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.revokeApiKey();
	                    }
	                }, {
	                    name: "UnlockUser",
	                    visibleWhen: function () {
	                        return _this.userdata && _this.userdata.locked && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.unlockUser();
	                    }
	                }, {
	                    name: "ExpirePassword",
	                    visibleWhen: function () {
	                        return _this.userdata && _this.passwordExpirationEnabled && _this.mode === "edit" && !_this.userdata.credentialsExpired && (_this.userdata.realm === "internal" || !_this.userdata.realm) && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.expirePassword();
	                    }
	                }, {
	                    name: "UnexpirePassword",
	                    visibleWhen: function () {
	                        return _this.userdata && _this.userdata.credentialsExpired && !_this.userdata.locked && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.unexpirePassword();
	                    }
	                }, {
	                    name: "DeleteUser",
	                    visibleWhen: function () {
	                        return _this.mode === "edit" && _this.userdata && _this.userdata.name !== "anonymous";
	                    },
	                    action: function () {
	                        return _this.deleteUser();
	                    }
	                }]);
	            }
	        },
	        checkUserName: {
	
	            // Validations
	
	            value: function checkUserName(value) {
	                return !/[A-Z]/.test(value);
	            }
	        }
	    });
	
	    return AdminSecurityUserFormController;
	})();

/***/ }),
/* 260 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	  RevokeApiKey: { title: "Revoke Api Key", icon: "icon-revoke-api" },
	  UnlockUser: { title: "Unlock User", icon: "icon-unlock" },
	  ExpirePassword: { title: "Expire Password", icon: "icon-expire" },
	  UnexpirePassword: { title: "Unexpire Password", icon: "icon-unexpire" },
	  DeleteUser: { title: "Delete User", icon: "icon-clear" }
	};

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as the size to enable large array optimizations. */
	"use strict";
	
	var LARGE_ARRAY_SIZE = 200;
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	
	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** `Object#toString` result references. */
	var argsTag = "[object Arguments]",
	    arrayTag = "[object Array]",
	    asyncTag = "[object AsyncFunction]",
	    boolTag = "[object Boolean]",
	    dateTag = "[object Date]",
	    errorTag = "[object Error]",
	    funcTag = "[object Function]",
	    genTag = "[object GeneratorFunction]",
	    mapTag = "[object Map]",
	    numberTag = "[object Number]",
	    nullTag = "[object Null]",
	    objectTag = "[object Object]",
	    proxyTag = "[object Proxy]",
	    regexpTag = "[object RegExp]",
	    setTag = "[object Set]",
	    stringTag = "[object String]",
	    undefinedTag = "[object Undefined]",
	    weakMapTag = "[object WeakMap]";
	
	var arrayBufferTag = "[object ArrayBuffer]",
	    dataViewTag = "[object DataView]",
	    float32Tag = "[object Float32Array]",
	    float64Tag = "[object Float64Array]",
	    int8Tag = "[object Int8Array]",
	    int16Tag = "[object Int16Array]",
	    int32Tag = "[object Int32Array]",
	    uint8Tag = "[object Uint8Array]",
	    uint8ClampedTag = "[object Uint8ClampedArray]",
	    uint16Tag = "[object Uint16Array]",
	    uint32Tag = "[object Uint32Array]";
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function("return this")();
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function () {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require("util").types;
	
	    if (types) {
	      return types;
	    }
	
	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding("util");
	  } catch (e) {}
	})();
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0:
	      return func.call(thisArg);
	    case 1:
	      return func.call(thisArg, args[0]);
	    case 2:
	      return func.call(thisArg, args[0], args[1]);
	    case 3:
	      return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function (value) {
	    return func(value);
	  };
	}
	
	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root["__core-js_shared__"];
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function () {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
	  return uid ? "Symbol(src)_1." + uid : "";
	})();
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	    getPrototype = overArg(Object.getPrototypeOf, Object),
	    objectCreate = Object.create,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	var defineProperty = (function () {
	  try {
	    var func = getNative(Object, "defineProperty");
	    func({}, "", {});
	    return func;
	  } catch (e) {}
	})();
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeMax = Math.max,
	    nativeNow = Date.now;
	
	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, "Map"),
	    nativeCreate = getNative(Object, "create");
	
	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function () {
	  function object() {}
	  return function (proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object();
	    object.prototype = undefined;
	    return result;
	  };
	})();
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}
	
	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
	  return this;
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype["delete"] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype["delete"] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    hash: new Hash(),
	    map: new (Map || ListCache)(),
	    string: new Hash()
	  };
	}
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)["delete"](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;
	
	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype["delete"] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache();
	  this.size = 0;
	}
	
	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data["delete"](key);
	
	  this.size = data.size;
	  return result;
	}
	
	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype["delete"] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
	    // Safari 9 has enumerable `arguments.length` in strict mode.
	    key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") ||
	    // Skip index properties.
	    isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
	    baseAssignValue(object, key, value);
	  }
	}
	
	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
	    baseAssignValue(object, key, value);
	  }
	}
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == "__proto__" && defineProperty) {
	    defineProperty(object, key, {
	      configurable: true,
	      enumerable: true,
	      value: value,
	      writable: true
	    });
	  } else {
	    object[key] = value;
	  }
	}
	
	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	
	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];
	
	  for (var key in object) {
	    if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function (srcValue, key) {
	    stack || (stack = new Stack());
	    if (isObject(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    } else {
	      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
	
	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}
	
	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet(object, key),
	      srcValue = safeGet(source, key),
	      stacked = stack.get(srcValue);
	
	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
	
	  var isCommon = newValue === undefined;
	
	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
	
	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      } else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      } else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      } else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      } else {
	        newValue = [];
	      }
	    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      } else if (!isObject(objValue) || isFunction(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    } else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack["delete"](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}
	
	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + "");
	}
	
	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function (func, string) {
	  return defineProperty(func, "toString", {
	    configurable: true,
	    enumerable: false,
	    value: constant(string),
	    writable: true
	  });
	};
	
	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	
	  buffer.copy(result);
	  return result;
	}
	
	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}
	
	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}
	
	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;
	
	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}
	
	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});
	
	  var index = -1,
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index];
	
	    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
	
	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}
	
	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function (object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;
	
	    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
	
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}
	
	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function (object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;
	
	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
	}
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
	}
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	
	  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
	}
	
	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
	    return eq(object[index], value);
	  }
	  return false;
	}
	
	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
	}
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && maskSrcKey in func;
	}
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
	
	  return value === proto;
	}
	
	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
	  return function () {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}
	
	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function safeGet(object, key) {
	  if (key === "constructor" && typeof object[key] === "function") {
	    return;
	  }
	
	  if (key == "__proto__") {
	    return;
	  }
	
	  return object[key];
	}
	
	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);
	
	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;
	
	  return function () {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);
	
	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return func + "";
	    } catch (e) {}
	  }
	  return "";
	}
	
	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || value !== value && other !== other;
	}
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments((function () {
	  return arguments;
	})()) ? baseIsArguments : function (value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
	};
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == "object" || type == "function");
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == "object";
	}
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
	  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}
	
	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}
	
	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function (object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});
	
	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function () {
	    return value;
	  };
	}
	
	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	module.exports = merge;
	
	// Node.js 0.10 has enumerable non-index properties on buffers.

	// PhantomJS 2 has enumerable non-index properties on typed arrays.
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(255)(module)))

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminSecuritySamlIntegrationController = __webpack_require__(263).AdminSecuritySamlIntegrationController;
	
	function samlIntegrationConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.saml_integration", {
	        params: { feature: "samlsso" },
	        url: "/saml_integration",
	        templateUrl: "states/admin/security/saml_integration/saml_integration.html",
	        controller: "AdminSecuritySamlIntegrationController as AdminSecuritySamlIntegration"
	    });
	}
	
	module.exports = angular.module("security.saml_integration", []).config(samlIntegrationConfig).controller("AdminSecuritySamlIntegrationController", AdminSecuritySamlIntegrationController);

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var API = _interopRequire(__webpack_require__(98));
	
	var AdminSecuritySamlIntegrationController = exports.AdminSecuritySamlIntegrationController = (function () {
	    function AdminSecuritySamlIntegrationController(SamlDao, ArtifactoryModelSaver, JFrogEventBus, JFrogModal, $window, RESOURCE) {
	        _classCallCheck(this, AdminSecuritySamlIntegrationController);
	
	        this.samlDao = SamlDao.getInstance();
	        this.TOOLTIP = TOOLTIP.admin.security.SAMLSSOSettings;
	        this.artifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["saml"]);
	        this.artifactoryEventBus = JFrogEventBus;
	        this.modal = JFrogModal;
	        this.$window = $window;
	        this.RESOURCE = RESOURCE;
	        this.downloadEncryptedAssertionCertLink = API.API_URL + this.RESOURCE.SAML_DOWNLOAD_ENCRYPTED_ASSERTION_CERT;
	        this._init();
	    }
	
	    _createClass(AdminSecuritySamlIntegrationController, {
	        _init: {
	            value: function _init() {
	                var _this = this;
	
	                this.samlDao.get().$promise.then(function (data) {
	                    _this.saml = data;
	                    if (!angular.isDefined(_this.saml.noAutoUserCreation)) {
	                        _this.saml.noAutoUserCreation = true;
	                    }
	                    _this.artifactoryModelSaver.save();
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                this.samlDao.update(this.saml).$promise.then(function () {
	                    _this.artifactoryModelSaver.save();
	                    _this.artifactoryEventBus.dispatch(EVENTS.FOOTER_DATA_UPDATED);
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;
	
	                this.artifactoryModelSaver.ask(true).then(function () {
	                    _this._init();
	                });
	            }
	        },
	        canSave: {
	            value: function canSave() {
	                return this.samlForm.$valid;
	            }
	        },
	        regenerateEncryptedAssertionCert: {
	            value: function regenerateEncryptedAssertionCert() {
	                var _this = this;
	
	                this.modal.confirm("A new X.509 public certificate will be generated. You will need to download the new " + "certificate and upload it to your IDP. Click Confirm to continue.").then(function () {
	                    return _this.samlDao.regenerateCertificate().$promise;
	                }).then(function (data) {
	                    console.log(data);
	                });
	            }
	        }
	    });
	
	    return AdminSecuritySamlIntegrationController;
	})();

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var CrowdIntegrationController = __webpack_require__(265).CrowdIntegrationController;
	
	function crowdIntegrationConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.crowd_integration", {
	        params: { feature: "crowd" },
	        url: "/crowd_integration",
	        templateUrl: "states/admin/security/crowd_integration/crowd_integration.html",
	        controller: "CrowdIntegrationController as Crowd"
	    });
	}
	
	module.exports = angular.module("security.crowd_integration", []).config(crowdIntegrationConfig).controller("CrowdIntegrationController", CrowdIntegrationController);

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var CrowdIntegrationController = exports.CrowdIntegrationController = (function () {
	    function CrowdIntegrationController($scope, CrowdIntegrationDao, JFrogGridFactory, commonGridColumns, uiGridConstants, ArtifactoryModelSaver) {
	        _classCallCheck(this, CrowdIntegrationController);
	
	        this.crowdIntegrationDao = CrowdIntegrationDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.$scope = $scope;
	        this.crowdGroupsOptions = null;
	        this.crowd = {};
	        this.groupsData = [];
	        this.commonGridColumns = commonGridColumns;
	        this.uiGridConstants = uiGridConstants;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["crowd"]);
	        this._createGrid();
	        this.crowdGroupsError = null;
	        this.batchActions = this._getBatchActions();
	        this.initCrowd();
	        this.usernameFilter = "";
	        this.filterType = "User Name";
	        this.TOOLTIP = TOOLTIP.admin.security.crowd_integration;
	        this.connectionMethod = "Crowd";
	    }
	
	    _createClass(CrowdIntegrationController, {
	        importCrowd: {
	            value: function importCrowd(row) {
	                var _this = this;
	
	                row.importIntoArtifactory = true;
	                this.crowdIntegrationDao["import"]({
	                    action: "import"
	                }, [row]).$promise.then(function (data) {
	                    _this.getCrowdGroups();
	                });
	            }
	        },
	        importCrowds: {
	            value: function importCrowds() {
	                var _this = this;
	
	                var selectedCrowds = this.crowdGroupsOptions.api.selection.getSelectedRows();
	                selectedCrowds.forEach(function (row) {
	                    row.importIntoArtifactory = true;
	                });
	                this.crowdIntegrationDao["import"]({
	                    action: "import"
	                }, selectedCrowds).$promise.then(function (data) {
	                    _this.getCrowdGroups();
	                });
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "import",
	                    name: "Import",
	                    callback: function () {
	                        return _this.importCrowds();
	                    }
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-import",
	                    tooltip: "Import",
	                    callback: function (row) {
	                        return _this.importCrowd(row);
	                    }
	                }];
	            }
	        },
	        initCrowd: {
	            value: function initCrowd() {
	                var _this = this;
	
	                this.loadFromServer().then(function () {
	                    if (!_this.initialized) {
	                        _this.initialized = true;
	                    } else _this.getCrowdGroups();
	                });
	            }
	        },
	        loadFromServer: {
	            value: function loadFromServer() {
	                var _this = this;
	
	                var retainEnabled = arguments[0] === undefined ? false : arguments[0];
	
	                return this.crowdIntegrationDao.get().$promise.then(function (data) {
	                    // Keep enabled
	                    if (retainEnabled && _this.crowd) data.enableIntegration = _this.crowd.enableIntegration;
	                    _this.connectionMethod = data.directAuthentication ? "JIRA" : "Crowd";
	                    _this.crowd = data;
	                    if (!retainEnabled) _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        getCrowdGroups: {
	            value: function getCrowdGroups() {
	                var _this = this;
	
	                if (this.crowd.enableIntegration && this.crowd.serverUrl && this.crowd.applicationName) {
	                    this.crowdIntegrationDao.refresh({ name: this.usernameFilter }, {
	                        serverUrl: this.crowd.serverUrl,
	                        applicationName: this.crowd.applicationName,
	                        enableIntegration: this.crowd.enableIntegration,
	                        noAutoUserCreation: this.crowd.noAutoUserCreation,
	                        useDefaultProxy: this.crowd.useDefaultProxy,
	                        directAuthentication: this.crowd.directAuthentication,
	                        sessionValidationInterval: this.crowd.sessionValidationInterval,
	                        password: this.crowd.password
	                    }).$promise.then(function (result) {
	                        _this.groupsData = result.data.crowdGroupModels;
	                        _this.crowdGroupsOptions.setGridData(_this.groupsData);
	                    })["catch"](function (result) {
	                        console.log("exception");
	                        _this.crowdGroupsError = result.data.error;
	                        _this.crowdGroupsOptions.setGridData([]);
	                    });
	                } else {
	                    this.crowdGroupsError = null;
	                    if (this.crowdGroupsOptions) this.crowdGroupsOptions.setGridData([]);
	                }
	            }
	        },
	        changeFilter: {
	            value: function changeFilter() {
	                this.usernameFilter = "";
	                this.getCrowdGroups();
	            }
	        },
	        isFilteringBy: {
	            value: function isFilteringBy(filterType) {
	                return this.filterType == filterType;
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.crowdGroupsOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setBatchActions(this._getBatchActions()).setButtons(this._getActions()).setGridData(this.groupsData);
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Group Name",
	                    displayName: "Group Name",
	                    field: "groupName",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "45%"
	                }, {
	                    name: "Description",
	                    displayName: "Description",
	                    field: "description",
	                    width: "45%"
	                }, {
	                    name: "Synced",
	                    displayName: "Synced",
	                    field: "existsInArtifactory",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.existsInArtifactory"),
	                    width: "10%"
	                } /*,
	                  {
	                     name: 'Import',
	                     field: 'importIntoArtifactory'
	                  }*/
	                ];
	            }
	        },
	        saveCrowd: {
	            value: function saveCrowd() {
	                var _this = this;
	
	                this.crowd.directAuthentication = this.connectionMethod === "JIRA";
	                this.crowdIntegrationDao.update(this.crowd).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                    _this.getCrowdGroups();
	                });
	            }
	        },
	        reset: {
	            value: function reset() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.initCrowd();
	                });
	            }
	        },
	        testCrowd: {
	            value: function testCrowd() {
	                this.crowd.directAuthentication = this.connectionMethod === "JIRA";
	                this.crowd.action = "test";
	                this.crowdIntegrationDao.test({
	                    action: "test",
	                    serverUrl: this.crowd.serverUrl,
	                    applicationName: this.crowd.applicationName,
	                    enableIntegration: this.crowd.enableIntegration,
	                    noAutoUserCreation: this.crowd.noAutoUserCreation,
	                    useDefaultProxy: this.crowd.useDefaultProxy,
	                    directAuthentication: this.directAuthentication,
	                    sessionValidationInterval: this.crowd.sessionValidationInterval,
	                    password: this.crowd.password
	
	                }).$promise.then(function (data) {});
	            }
	        },
	        onChangeNoAutoUserCreation: {
	            value: function onChangeNoAutoUserCreation() {
	                if (!this.crowd.noAutoUserCreation) this.crowd.allowUserToAccessProfile = false;
	            }
	        }
	    });
	
	    return CrowdIntegrationController;
	})();

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminSecurityOAuthController = __webpack_require__(267).AdminSecurityOAuthController;
	
	var AdminSecurityOAuthProviderFormController = __webpack_require__(268).AdminSecurityOAuthProviderFormController;
	
	function oauthConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.oauth", {
	        params: { feature: "oauthsso" },
	        url: "/oauth",
	        templateUrl: "states/admin/security/oauth/oauth.html",
	        controller: "AdminSecurityOAuthController as AdminSecurityOAuth"
	    }).state("admin.security.oauth.edit", {
	        params: { feature: "oauthsso" },
	        parent: "admin.security",
	        url: "/oauth/{providerName}/edit",
	        templateUrl: "states/admin/security/oauth/oauth_provider_form.html",
	        controller: "AdminSecurityOAuthProviderFormController as ProviderForm"
	    }).state("admin.security.oauth.new", {
	        params: { feature: "oauthsso" },
	        parent: "admin.security",
	        url: "/oauth/newprovider",
	        templateUrl: "states/admin/security/oauth/oauth_provider_form.html",
	        controller: "AdminSecurityOAuthProviderFormController as ProviderForm"
	    });
	}
	
	module.exports = angular.module("security.oauth", []).config(oauthConfig).controller("AdminSecurityOAuthController", AdminSecurityOAuthController).controller("AdminSecurityOAuthProviderFormController", AdminSecurityOAuthProviderFormController);

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminSecurityOAuthController = exports.AdminSecurityOAuthController = (function () {
	    function AdminSecurityOAuthController($scope, ArtifactoryModelSaver, JFrogModal, OAuthDao, JFrogGridFactory, commonGridColumns, uiGridConstants) {
	        _classCallCheck(this, AdminSecurityOAuthController);
	
	        this.$scope = $scope;
	        this.OAuthDao = OAuthDao;
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.commonGridColumns = commonGridColumns;
	        this.uiGridConstants = uiGridConstants;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["oauthData"]);
	        this.providersGridOptions = null;
	        this.TOOLTIP = TOOLTIP.admin.security.OAuthSSO;
	        this.selectizeConfig = {
	            sortField: "text",
	            create: false,
	            maxItems: 1
	        };
	        this._createGrid();
	        this._init();
	    }
	
	    _createClass(AdminSecurityOAuthController, {
	        _init: {
	            value: function _init() {
	                var _this = this;
	
	                this.OAuthDao.get().$promise.then(function (data) {
	                    _this.oauthData = data;
	                    _this.selectizeOptions = [{ text: " ", value: "*" }];
	                    var githubProviders = _.filter(data.providers, function (p) {
	                        return p.providerType === "github";
	                    });
	                    _this.selectizeOptions = _this.selectizeOptions.concat(_.map(githubProviders, function (p) {
	                        return Object({ text: p.name, value: p.name });
	                    }));
	                    if (!_.find(githubProviders, { name: data.defaultNpm })) {
	                        _this.selectizeOptions.push({ text: data.defaultNpm, value: data.defaultNpm });
	                    }
	                    data.providers.forEach(function (provider) {
	                        provider.typeDisplayName = _.find(data.availableTypes, { type: provider.providerType }).displayName;
	                    });
	                    _this.providersGridOptions.setGridData(data.providers);
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.providersGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setSingleSelect().setButtons(this._getActions()).setRowTemplate("default");
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" ui-sref=\"^.oauth.edit({providerName: row.entity.name})\"><a href=\"\" class=\"jf-link\">{{row.entity.name}}</a></div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "20%"
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "typeDisplayName",
	                    width: "15%"
	                }, {
	                    name: "ID",
	                    displayName: "ID",
	                    field: "id",
	                    width: "20%"
	                }, {
	                    name: "Auth Url",
	                    displayName: "Auth Url",
	                    field: "authUrl",
	                    width: "35%"
	                }, {
	                    name: "Enabled",
	                    displayName: "Enabled",
	                    field: "enabled",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.enabled"),
	                    width: "10%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteProvider(row);
	                    }
	                }];
	            }
	        },
	        deleteProvider: {
	            value: function deleteProvider(row) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete provider '" + row.name + "?'").then(function () {
	                    _this.OAuthDao.deleteProvider({}, { provider: row.name }).$promise.then(function () {
	                        _this._init();
	                    });
	                });
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                var payload = _.cloneDeep(this.oauthData);
	
	                if (payload.defaultNpm === "*") delete payload.defaultNpm;
	                delete payload.providers;
	                delete payload.availableTypes;
	
	                this.OAuthDao.update(payload).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this._init();
	                });
	            }
	        },
	        canSave: {
	            value: function canSave() {
	                return this.oauthForm.$valid;
	            }
	        }
	    });
	
	    return AdminSecurityOAuthController;
	})();

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var AdminSecurityOAuthProviderFormController = exports.AdminSecurityOAuthProviderFormController = (function () {
	    function AdminSecurityOAuthProviderFormController($state, $stateParams, ArtifactoryModelSaver, OAuthDao) {
	        _classCallCheck(this, AdminSecurityOAuthProviderFormController);
	
	        this.OAuthDao = OAuthDao;
	        this.$state = $state;
	        this.TOOLTIP = TOOLTIP.admin.security.OAuthSSO;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["providerData"]);
	
	        this.selectizeConfig = {
	            sortField: "text",
	            create: false,
	            maxItems: 1
	        };
	
	        if ($stateParams.providerName) {
	            this.mode = "edit";
	            this.providerName = $stateParams.providerName;
	            this.title = "Edit " + this.providerName + " Provider";
	        } else {
	            this.mode = "create";
	            this.providerData = {
	                enabled: true
	            };
	            this.title = "Add New Provider";
	        }
	
	        this._getData();
	    }
	
	    _createClass(AdminSecurityOAuthProviderFormController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;
	
	                this.OAuthDao.get().$promise.then(function (data) {
	                    _this._setMandatoryFieldsData(data.availableTypes);
	
	                    _this.selectizeOptions = _.map(data.availableTypes, function (t) {
	                        return Object({ text: t.displayName, value: t.type });
	                    });
	                    if (_this.mode === "create") {
	                        _this.providerData.providerType = data.availableTypes[0].type;
	                        _this._setDefaultValues();
	                    } else if (_this.mode === "edit") {
	                        _this.providerData = _.find(data.providers, { name: _this.providerName });
	                    }
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        _setMandatoryFieldsData: {
	            value: function _setMandatoryFieldsData(typesData) {
	                var _this = this;
	
	                this.mandatoryFields = {};
	                this.fieldHolders = {};
	                typesData.forEach(function (typeRec) {
	                    _this.mandatoryFields[typeRec.type] = {};
	                    _this.fieldHolders[typeRec.type] = {};
	                    typeRec.mandatoryFields.forEach(function (field) {
	                        _this.fieldHolders[typeRec.type][field] = typeRec.fieldHolders[typeRec.mandatoryFields.indexOf(field)] || "";
	                        _this.mandatoryFields[typeRec.type][field] = typeRec.fieldsValues[typeRec.mandatoryFields.indexOf(field)] || "";
	                    });
	                });
	            }
	        },
	        _setDefaultValues: {
	            value: function _setDefaultValues() {
	                this.providerData.apiUrl = this.providerData.authUrl = this.providerData.tokenUrl = this.providerData.basicUrl = this.providerData.apiUrlHolder = this.providerData.authUrlHolder = this.providerData.tokenUrlHolder = this.providerData.basicUrlHolder = "";
	                for (var key in this.mandatoryFields[this.providerData.providerType]) {
	                    this.providerData[key] = this.mandatoryFields[this.providerData.providerType][key];
	                    this.providerData[key + "Holder"] = this.fieldHolders[this.providerData.providerType][key];
	                };
	            }
	        },
	        onChangeProviderType: {
	            value: function onChangeProviderType() {
	                this._setDefaultValues();
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	
	                if (this.mode === "edit") {
	                    this.OAuthDao.updateProvider(this.providerData).$promise.then(function () {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.oauth");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                } else if (this.mode === "create") {
	                    this.OAuthDao.createProvider(this.providerData).$promise.then(function () {
	                        _this.savePending = false;
	                        _this.ArtifactoryModelSaver.save();
	                        _this.$state.go("^.oauth");
	                    })["catch"](function () {
	                        return _this.savePending = false;
	                    });
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.$state.go("^.oauth");
	            }
	        },
	        isSaveDisabled: {
	            value: function isSaveDisabled() {
	                return this.savePending || !this.providerForm.$valid;
	            }
	        }
	    });
	
	    return AdminSecurityOAuthProviderFormController;
	})();

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var LdapSettingsController = __webpack_require__(270).LdapSettingsController;
	
	var LdapSettingFormController = __webpack_require__(271).LdapSettingFormController;
	
	var LdapGroupFormController = __webpack_require__(272).LdapGroupFormController;
	
	function ldapSettingConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.ldap_settings", {
	        url: "/ldap_settings",
	        templateUrl: "states/admin/security/ldap_settings/ldap_settings.html",
	        controller: "LdapSettingsController as Ldap"
	    }).state("admin.security.ldap_settings.new", {
	        parent: "admin.security",
	        url: "/ldap_settings/new",
	        templateUrl: "states/admin/security/ldap_settings/ldap_setting_form.html",
	        controller: "LdapSettingFormController as LdapSettingForm"
	    }).state("admin.security.ldap_settings.edit", {
	        parent: "admin.security",
	        url: "/ldap_settings/:ldapSettingKey/edit",
	        templateUrl: "states/admin/security/ldap_settings/ldap_setting_form.html",
	        controller: "LdapSettingFormController as LdapSettingForm"
	    }).state("admin.security.ldap_settings.new_ldap_group", {
	        parent: "admin.security",
	        url: "/ldap_groups/new",
	        templateUrl: "states/admin/security/ldap_settings/ldap_group_form.html",
	        controller: "LdapGroupFormController as LdapGroupForm"
	    }).state("admin.security.ldap_settings.edit_ldap_group", {
	        parent: "admin.security",
	        url: "/ldap_groups/:ldapGroupName/edit",
	        templateUrl: "states/admin/security/ldap_settings/ldap_group_form.html",
	        controller: "LdapGroupFormController as LdapGroupForm"
	    });
	}
	
	module.exports = angular.module("security.ldap_settings", []).config(ldapSettingConfig).controller("LdapSettingsController", LdapSettingsController).controller("LdapSettingFormController", LdapSettingFormController).controller("LdapGroupFormController", LdapGroupFormController);

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var LdapSettingsController = exports.LdapSettingsController = (function () {
	    /*
	     z-index: 999;
	     background-color: red;
	     height: 100%;
	     width: 97%;
	     opacity: tr;
	     position: absolute;
	     */
	
	    function LdapSettingsController(JFrogModal, ArtifactoryFeatures, LdapDao, LdapGroupsDao, $timeout, $scope, JFrogGridFactory, uiGridConstants) {
	        _classCallCheck(this, LdapSettingsController);
	
	        this.ldapDao = LdapDao;
	        this.ldapGroupsDao = LdapGroupsDao;
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.settingsGridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.groupsGridOption = {};
	        this.ldapSettingsData = {};
	        this.ldapGroupsData = {};
	        this.$timeout = $timeout;
	        this.artifactoryFeatures = ArtifactoryFeatures;
	        this.$scope = $scope;
	        this.noLdapConfigurationMessage = CONFIG_MESSAGES.admin.security.ldap.noLdapConfigurationMessage;
	        this._initLdap();
	    }
	
	    _createClass(LdapSettingsController, {
	        resetLdapSettings: {
	            value: function resetLdapSettings() {
	                this._getLdapSettingsView();
	            }
	        },
	        deleteLdapSetting: {
	
	            //Call REST API for deletion of ldap settings
	
	            value: function deleteLdapSetting(key) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete LDAP: '" + key + "'?").then(function () {
	                    return _this._doDeleteLdapSetting(key);
	                });
	            }
	        },
	        _doDeleteLdapSetting: {
	            value: function _doDeleteLdapSetting(key) {
	                var _this = this;
	
	                this.ldapDao["delete"]({ key: key }).$promise.then(function (data) {
	                    _this._getLdapSettingsView();
	                });
	            }
	        },
	        deleteLdapGroup: {
	
	            /***************************
	             ** Delete
	             ****************************/
	
	            //Call REST API for deletion of ldap group
	
	            value: function deleteLdapGroup(name) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete LDAP group: '" + name + "'?").then(function () {
	                    return _this._doDeleteLdapGroup(name);
	                });
	            }
	        },
	        _doDeleteLdapGroup: {
	            value: function _doDeleteLdapGroup(name) {
	                var _this = this;
	
	                this.ldapGroupsDao["delete"]({ name: name }).$promise.then(function (data) {
	                    _this._getLdapGroupsView();
	                });
	            }
	        },
	        deleteSelectedLdapSettings: {
	            value: function deleteSelectedLdapSettings() {
	                var _this = this;
	
	                var selectedRows = this.settingsGridOption.api.selection.getSelectedGridRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " LDAP settings?").then(function () {
	                    selectedRows.forEach(function (row) {
	                        return _this._doDeleteLdapSetting(row.entity.key);
	                    });
	                });
	            }
	        },
	        deleteSelectedLdapGroups: {
	            value: function deleteSelectedLdapGroups() {
	                var _this = this;
	
	                var selectedRows = this.groupsGridOption.api.selection.getSelectedGridRows();
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " LDAP groups?").then(function () {
	                    selectedRows.forEach(function (row) {
	                        return _this._doDeleteLdapGroup(row.entity.name);
	                    });
	                });
	            }
	        },
	        canMove: {
	
	            /***************************
	             ** Move up / down
	             ****************************/
	            //check if a row (in the settings grid) can move up or down
	
	            value: function canMove(key, dir) {
	                var data = this.ldapSettingsData;
	                var index = this._indexOf(key);
	                return dir === "up" && index > 0 || dir === "down" && index < data.length - 1;
	            }
	        },
	        moveLdapSetting: {
	
	            //move a row (in the settings grid) up or down
	
	            value: function moveLdapSetting(key, dir) {
	                var data = this.ldapSettingsData;
	                var index = this._indexOf(key);
	                if (dir === "up" && index > 0) {
	                    this._swapSettings(index, index - 1);
	                } else if (dir === "down" && index < data.length - 1) {
	                    this._swapSettings(index, index + 1);
	                }
	            }
	        },
	        _initLdap: {
	
	            /***************************
	             ** Initialization
	             ****************************/
	
	            //initialize everything...
	
	            value: function _initLdap() {
	                var _this = this;
	
	                this._createGrids();
	                this._getLdapSettingsView();
	                this._getLdapGroupsView().then(function () {
	                    return _this._disableAsOss();
	                });
	            }
	        },
	        _getLdapSettingsView: {
	
	            //get settings ('view') data from the REST API
	
	            value: function _getLdapSettingsView() {
	                var _this = this;
	
	                this.ldapDao.query().$promise.then(function (data) {
	                    _this.ldapSettingsData = data;
	                    _this.settingsGridOption.setGridData(_this.ldapSettingsData);
	                });
	            }
	        },
	        _getLdapGroupsView: {
	
	            //get ldap groups ('view') data from the REST API
	
	            value: function _getLdapGroupsView() {
	                var _this = this;
	
	                return this.ldapGroupsDao.query().$promise.then(function (data) {
	                    _this.ldapGroupsData = data;
	                    _this.groupsGridOption.setGridData(_this.ldapGroupsData);
	                });
	            }
	        },
	        _disableAsOss: {
	            value: function _disableAsOss() {}
	        },
	        _createGrids: {
	
	            //create both ldap settings grid and ldap groups grid
	
	            value: function _createGrids() {
	                this.settingsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getSettingsColumns()).setSingleSelect().setDraggable(this.reorderLdap.bind(this)).setButtons(this._getSettingsActions());
	                //.setBatchActions(this._getSettingsBatchActions());
	
	                this.groupsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getGroupsColumns()).setSingleSelect().setRowTemplate("default").setButtons(this._getGroupsActions());
	                //.setBatchActions(this._getGroupsBatchActions());
	            }
	        },
	        reorderLdap: {
	            value: function reorderLdap() {
	                return this.ldapDao.reorder(this.getLdapOrder()).$promise;
	            }
	        },
	        getLdapOrder: {
	            value: function getLdapOrder() {
	                var ldapOrderList = [];
	                this.settingsGridOption.data.forEach(function (data) {
	                    ldapOrderList.push(data.key);
	                });
	                return ldapOrderList;
	            }
	        },
	        noData: {
	            value: function noData() {
	                return (!this.ldapSettingsData || this.ldapSettingsData.length === 0) && (!this.ldapGroupsData || this.ldapGroupsData.length === 0);
	            }
	        },
	        _getSettingsColumns: {
	
	            /***************************
	             ** Settings Grid
	             ****************************/
	            //get the columns for the settings grid
	
	            value: function _getSettingsColumns() {
	
	                return [{
	                    name: "Settings Name",
	                    displayName: "Settings Name",
	                    field: "key",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.ldap_settings.edit({ldapSettingKey: row.entity.key})\" class=\"jf-link\" >{{ COL_FIELD }}</a></div>",
	                    enableSorting: false
	                }, {
	                    name: "LDAP URL",
	                    displayName: "LDAP URL",
	                    field: "ldapUrl",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ng-href=\"{{ COL_FIELD }}\" class=\"jf-link\">{{ COL_FIELD }}</a></div>",
	                    enableSorting: false
	                }];
	            }
	        },
	        _getSettingsActions: {
	
	            //get the actions for the settings grid
	
	            value: function _getSettingsActions() {
	                var _this = this;
	
	                return [
	                /*{
	                 icon: 'icon icon-angle-double-up',
	                 tooltip: 'Move Up',
	                 visibleWhen: row => this.canMove(row.key,'up'),
	                 callback: row => this.moveLdapSetting(row.key,'up')
	                 },
	                 {
	                 icon: 'icon icon-angle-double-down',
	                 tooltip: 'Move Down',
	                 visibleWhen: row => this.canMove(row.key,'down'),
	                 callback: row => this.moveLdapSetting(row.key,'down')
	                 },*/
	                {
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteLdapSetting(row.key);
	                    }
	                }];
	            }
	        },
	        _getGroupsColumns: {
	
	            //
	            //_getSettingsBatchActions() {
	            //    return [
	            //        {
	            //            icon: 'clear',
	            //            name: 'Delete',
	            //            callback: () => this.deleteSelectedLdapSettings()
	            //        },
	            //    ]
	            //}
	            /***************************
	             ** Groups Grid
	             ****************************/
	
	            value: function _getGroupsColumns() {
	                return [{
	                    name: "Settings Name",
	                    displayName: "Settings Name",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.ldap_settings.edit_ldap_group({ldapGroupName: row.entity.name})\" class=\"jf-link\">{{ COL_FIELD }}</a></div>"
	                }, {
	                    name: "LDAP Settings",
	                    displayName: "LDAP Settings",
	                    field: "enabledLdap"
	                }, {
	                    name: "Strategy",
	                    displayName: "Strategy",
	                    field: "strategy"
	                }];
	            }
	        },
	        _getGroupsActions: {
	            value: function _getGroupsActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteLdapGroup(row.name);
	                    }
	                }];
	            }
	        },
	        _getGroupsBatchActions: {
	            value: function _getGroupsBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedLdapGroups();
	                    }
	                }];
	            }
	        },
	        _indexOf: {
	
	            //get the index of the ldap settings (key) in this.ldapSettingsData
	
	            value: function _indexOf(key) {
	                var data = this.ldapSettingsData;
	
	                var index = -1;
	
	                for (var i = 0; i < data.length; i++) {
	                    if (data[i].key === key) {
	                        index = i;
	                        break;
	                    }
	                }
	
	                return index;
	            }
	        },
	        _swapSettings: {
	
	            //swap the order of two ldap settings
	
	            value: function _swapSettings(index1, index2) {
	                var data = this.ldapSettingsData;
	
	                var temp = data[index2];
	                data[index2] = data[index1];
	                data[index1] = temp;
	            }
	        }
	    });
	
	    return LdapSettingsController;
	})();

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var $stateParams = undefined,
	    LdapDao = undefined,
	    $state = undefined,
	    JFrogGridFactory = undefined;
	
	var LdapSettingFormController = exports.LdapSettingFormController = (function () {
	    function LdapSettingFormController(_$stateParams_, _$state_, _LdapDao_, _JFrogGridFactory_, JFrogNotifications, ArtifactoryModelSaver, ArtifactoryFeatures) {
	        _classCallCheck(this, LdapSettingFormController);
	
	        $state = _$state_;
	        $stateParams = _$stateParams_;
	        LdapDao = _LdapDao_;
	        JFrogGridFactory = _JFrogGridFactory_;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.testConnection = {};
	        this.isNew = !$stateParams.ldapSettingKey;
	        this.TOOLTIP = TOOLTIP.admin.security.LDAPSettingsForm;
	        this.features = ArtifactoryFeatures;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["ldap"]);
	        this._initLdapSetting();
	    }
	
	    _createClass(LdapSettingFormController, {
	        _initLdapSetting: {
	            value: function _initLdapSetting() {
	                var _this = this;
	
	                if (this.isNew) {
	                    this.ldap = {
	                        enabled: true,
	                        autoCreateUser: true,
	                        search: { searchSubTree: true },
	                        emailAttribute: "mail",
	                        ldapPoisoningProtection: true,
	                        pagingSupportEnabled: true
	                    };
	                } else {
	                    LdapDao.get({ key: $stateParams.ldapSettingKey }).$promise.then(function (ldapSetting) {
	                        _this.ldap = ldapSetting;
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	
	                if (this.ldapEditForm.$valid) {
	                    if (!this.ldap.userDnPattern && !this.ldap.search.searchFilter) {
	                        this.messageUserOrSearch();
	                    } else {
	                        if (this.ldap.search && this._isSearchFieldsNull(this.ldap.search)) {
	                            this.ldap.search = undefined;
	                        }
	                        var whenSaved = this.isNew ? LdapDao.save(this.ldap) : LdapDao.update(this.ldap);
	                        whenSaved.$promise.then(function () {
	                            _this.savePending = false;
	                            _this.ArtifactoryModelSaver.save();
	                            _this._end();
	                        })["catch"](function () {
	                            return _this.savePending = false;
	                        });
	                    }
	                }
	            }
	        },
	        _isSearchFieldsNull: {
	            value: function _isSearchFieldsNull(search) {
	                return !search.managerDn && !search.managerPassword && !search.searchBase && !search.searchFilter;
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.ldap_settings");
	            }
	        },
	        doTestConnection: {
	            value: function doTestConnection() {
	                if (this.ldapEditForm.$valid) {
	                    if (!this.ldap.userDnPattern && !this.ldap.search.searchFilter) {
	                        this.messageUserOrSearch();
	                    } else {
	                        var testData = {};
	                        _.extend(testData, this.ldap);
	                        _.extend(testData, this.testConnection);
	
	                        LdapDao.test(testData);
	                    }
	                }
	            }
	        },
	        messageUserOrSearch: {
	            value: function messageUserOrSearch() {
	                this.artifactoryNotifications.create({ error: "LDAP settings should provide a userDnPattern or a searchFilter (or both)" });
	                this.savePending = undefined;
	            }
	        },
	        testConnectionOnEnterPress: {
	            value: function testConnectionOnEnterPress($event) {
	                $event.preventDefault();
	                if (!!this.testConnection.testUsername && !!this.testConnection.testPassword) {
	                    this.doTestConnection();
	                }
	            }
	        }
	    });
	
	    return LdapSettingFormController;
	})();

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	// Injectables:
	var $q = undefined,
	    $scope = undefined,
	    $state = undefined,
	    $stateParams = undefined,
	    JFrogGridFactory = undefined,
	    LdapGroupsDao = undefined,
	    LdapDao = undefined,
	    ArtifactoryModelSaver = undefined;
	
	var LdapGroupFormController = exports.LdapGroupFormController = (function () {
	    function LdapGroupFormController(_$q_, _$scope_, _$state_, _$stateParams_, _JFrogGridFactory_, _LdapGroupsDao_, _LdapDao_, _ArtifactoryModelSaver_) {
	        _classCallCheck(this, LdapGroupFormController);
	
	        $q = _$q_;
	        $scope = _$scope_;
	        $state = _$state_;
	        $stateParams = _$stateParams_;
	        JFrogGridFactory = _JFrogGridFactory_;
	        ArtifactoryModelSaver = _ArtifactoryModelSaver_.createInstance(this, ["ldapGroup"]);
	        LdapGroupsDao = _LdapGroupsDao_;
	        LdapDao = _LdapDao_;
	
	        this.isNew = !$stateParams.ldapGroupName;
	        this._initLdapSetting();
	        this._initGroupLabels();
	        this._initSelectizeConfig();
	        this._initGroupSyncGrid();
	        this._initStrategyOptions();
	        this.isImportDisabled = true;
	        this.TOOLTIP = TOOLTIP.admin.security.LDAPGroupsForm;
	    }
	
	    _createClass(LdapGroupFormController, {
	        _initLdapSetting: {
	
	            /***************************
	            ** Initialization
	            ****************************/
	
	            value: function _initLdapSetting() {
	                var _this = this;
	
	                if (this.isNew) {
	                    this.ldapGroup = {
	                        enabledLdap: " ",
	                        strategy: "STATIC",
	                        subTree: true
	                    };
	                    this.ldapGroupPromise = $q.when(this.ldapGroup);
	                } else {
	                    this.ldapGroupPromise = LdapGroupsDao.get({ name: $stateParams.ldapGroupName }).$promise.then(function (ldapGroup) {
	                        _this.ldapGroup = ldapGroup;
	                        ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        _initGroupLabels: {
	            value: function _initGroupLabels() {
	                var _this = this;
	
	                if (this.isNew) this.onStrategyChange();else {
	                    this.ldapGroupPromise.then(function () {
	                        _this._setGroupLabels(_this.ldapGroup.strategy);
	                    });
	                }
	            }
	        },
	        _initSelectizeConfig: {
	            value: function _initSelectizeConfig() {
	                var _this = this;
	
	                LdapDao.query().$promise.then(function (ldapSettingsData) {
	                    _this.selectizeConfig = {
	                        sortField: "text",
	                        create: true,
	                        maxItems: 1
	                    };
	
	                    _this.selectizeOptions = ldapSettingsData.map(function (ldapSetting) {
	                        return ldapSetting.key;
	                    });
	                    _this.selectizeOptions.push(" ");
	                });
	            }
	        },
	        _initGroupSyncGrid: {
	            value: function _initGroupSyncGrid() {
	                var _this = this;
	
	                this.syncGroupsGridOptions = JFrogGridFactory.getGridInstance($scope).setColumns(this._getSyncGroupsGridColumns()).setRowTemplate("default").setBatchActions(this._getBatchActions()).setMultiSelect().setGridData([]);
	
	                this.syncGroupsGridOptions.onSelectionChange = this.syncGroupsGridOptions.onSelectionChangeBatch = function () {
	                    var selectedRows = _this.syncGroupsGridOptions.api.selection.getSelectedRows();
	                    _this.isImportDisabled = !selectedRows.length;
	                };
	            }
	        },
	        _initStrategyOptions: {
	            value: function _initStrategyOptions() {
	                this.strategyOptions = [{ value: "STATIC", text: "Static" }, { value: "DYNAMIC", text: "Dynamic" }, { value: "HIERARCHICAL", text: "Hierarchy" }];
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                var whenSaved = this.isNew ? LdapGroupsDao.save(this.ldapGroup) : LdapGroupsDao.update(this.ldapGroup);
	                whenSaved.$promise.then(function () {
	                    ArtifactoryModelSaver.save();
	                    _this._end();
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.ldap_settings");
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "import",
	                    name: "Import",
	                    callback: function () {
	                        return _this.importSyncGroups();
	                    }
	                }];
	            }
	        },
	        importSyncGroups: {
	            value: function importSyncGroups() {
	                var _this = this;
	
	                if (this.isImportDisabled) {
	                    return;
	                }var importData = {};
	                var selectedRows = this.syncGroupsGridOptions.api.selection.getSelectedRows();
	                _.extend(importData, { importGroups: selectedRows, ldapGroupSettings: this.ldapGroup });
	                _.extend(importData, { name: this.ldapGroup.name });
	
	                LdapGroupsDao["import"](importData).$promise.then(function (data) {
	                    _this.refreshSyncGroups(_this.ldapGroup.usernameFilter);
	                });
	            }
	        },
	        importSyncGroup: {
	            value: function importSyncGroup(row) {
	                var _this = this;
	
	                var importData = {};
	                _.extend(importData, { importGroups: [row], ldapGroupSettings: this.ldapGroup });
	                _.extend(importData, { name: this.ldapGroup.name });
	
	                LdapGroupsDao["import"](importData).$promise.then(function (data) {
	                    _this.refreshSyncGroups(_this.ldapGroup.usernameFilter);
	                });
	            }
	        },
	        refreshSyncGroups: {
	            value: function refreshSyncGroups(username) {
	                var _this = this;
	
	                if (!this.ldapGroupsEditForm.$valid) {
	                    return;
	                }var refreshData = {};
	                _.extend(refreshData, this.ldapGroup);
	                _.extend(refreshData, { name: refreshData.name, username: username });
	
	                LdapGroupsDao.refresh(refreshData).$promise.then(function (result) {
	                    result.data.forEach(function (group) {
	                        group.syncState = group.requiredUpdate === "IN_ARTIFACTORY";
	                    });
	                    _this.syncGroupsGridOptions.setGridData(result.data);
	                })["catch"](function () {
	                    _this.syncGroupsGridOptions.setGridData([]);
	                })["finally"](function () {
	                    if (_this) _this.isImportDisabled = true;
	                });
	            }
	        },
	        _setGroupLabels: {
	
	            /***************************
	            ** Strategy
	            ****************************/
	
	            value: function _setGroupLabels(strategy) {
	                switch (strategy.toLowerCase()) {
	                    case "static":
	                    case "dynamic":
	                        this.labels = { groupKeyMember: "Group Member Attribute" };
	                        break;
	                    case "hierarchical":
	                        this.labels = { groupKeyMember: "User DN Group Key" };
	                        break;
	                }
	            }
	        },
	        onStrategyChange: {
	            value: function onStrategyChange() {
	                var _this = this;
	
	                var strategy = this.ldapGroup.strategy;
	                this._getStrategy(strategy).then(function (data) {
	                    _this.ldapGroup.groupMemberAttribute = data.groupKeyMember;
	                    _this.ldapGroup.groupNameAttribute = data.groupNameAttribute;
	                    _this.ldapGroup.descriptionAttribute = data.description;
	                    _this.ldapGroup.filter = data.filter;
	                });
	
	                this._setGroupLabels(strategy);
	            }
	        },
	        _getStrategy: {
	            value: function _getStrategy(strategy) {
	                return LdapGroupsDao.getstrategy({ name: "dummy", strategy: strategy.toLowerCase() }).$promise;
	            }
	        },
	        _getSyncGroupsGridColumns: {
	
	            /***************************
	            ** Grid
	            ****************************/
	            //get the columns for the synchronize groups grid (inside the ldap groups' modal)
	
	            value: function _getSyncGroupsGridColumns() {
	                var _this = this;
	
	                return [{
	                    name: "Group Name",
	                    displayName: "Group Name",
	                    field: "groupName",
	                    width: "30%"
	                }, {
	                    name: "Description",
	                    displayName: "Description",
	                    field: "description",
	                    width: "60%"
	                }, {
	                    name: "Sync State",
	                    displayName: "Sync State",
	                    field: "syncState",
	                    cellTemplate: "<div ng-if=\"row.entity.syncState\" class=\"grid-checkbox\"><input class=\"text-center\" " + "ng-model=\"row.entity.syncState\" type=\"checkbox\" disabled/><span class=\"icon icon-v\"></span></div>",
	                    width: "10%",
	                    customActions: [{
	                        icon: "icon icon-import",
	                        tooltip: "Import",
	                        name: "Import",
	                        callback: function (row) {
	                            return _this.importSyncGroup(row);
	                        }
	                    }]
	                }];
	            }
	        }
	    });
	
	    return LdapGroupFormController;
	})();

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var SigningKeysController = __webpack_require__(274).SigningKeysController;
	
	function signingKeysConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.signing_keys", {
	        params: { feature: "signingkeys" },
	        url: "/signing_keys",
	        templateUrl: "states/admin/security/signing_keys/signing_keys.html",
	        controller: "SigningKeysController as SigningKeys"
	    });
	}
	
	module.exports = angular.module("security.signing_keys", []).config(signingKeysConfig).controller("SigningKeysController", SigningKeysController);

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var API = _interopRequire(__webpack_require__(98));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var SigningKeysController = exports.SigningKeysController = (function () {
	    function SigningKeysController($timeout, FileUploader, JFrogEventBus, SigningKeysDao, KeystoreDao, JFrogNotifications) {
	        _classCallCheck(this, SigningKeysController);
	
	        this.$timeout = $timeout;
	        this.signingKeysDao = SigningKeysDao;
	        this.keystoreDao = KeystoreDao;
	        this.keyStore = {};
	        this.FileUploader = FileUploader;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	
	        this.TOOLTIP = TOOLTIP.admin.security.signingKeys;
	        this.publicKeyValue = "No public key installed";
	        this.privateKeyValue = "No private key installed";
	        this.initSigningKeys();
	    }
	
	    _createClass(SigningKeysController, {
	        initSigningKeys: {
	            value: function initSigningKeys() {
	
	                this.getSigningKeysData();
	                this.keyPairNames = [];
	                this.keystoreFileUploaded = false;
	                this.getKeyStoreData();
	                //-----public key-----//
	                this.uploaderPublicKey = new this.FileUploader();
	                this.uploaderPublicKey.onSuccessItem = this.onUploadPublicKeySuccess.bind(this);
	                this.uploaderPublicKey.onErrorItem = this.onUploadPublicKeyFail.bind(this);
	                this.uploaderPublicKey.url = "" + API.API_URL + "/signingkeys/install?public=true";
	                this.uploaderPublicKey.headers = { "X-Requested-With": "artUI" };
	                this.uploaderPublicKey.removeAfterUpload = true;
	                //-----private key-----//
	                this.uploaderPrivateKey = new this.FileUploader();
	                this.uploaderPrivateKey.url = "" + API.API_URL + "/signingkeys/install?public=false";
	                this.uploaderPrivateKey.headers = { "X-Requested-With": "artUI" };
	                this.uploaderPrivateKey.onSuccessItem = this.onUploadPrivateKeySuccess.bind(this);
	                this.uploaderPrivateKey.onErrorItem = this.onUploadPrivateKeyFail.bind(this);
	                this.uploaderPrivateKey.removeAfterUpload = true;
	                //------key pair-----//
	                this.uploaderKeyStore = new this.FileUploader();
	                this.uploaderKeyStore.onSuccessItem = this.onUploadKeyStoreSuccess.bind(this);
	                this.uploaderKeyStore.onErrorItem = this.onUploadKeyStoreFail.bind(this);
	                this.uploaderKeyStore.onAfterAddingAll = this.onUploadKeyFileAdded.bind(this);
	                this.uploaderKeyStore.url = "" + API.API_URL + "/keystore/upload";
	                this.uploaderKeyStore.headers = { "X-Requested-With": "artUI" };
	                this.uploaderKeyStore.removeAfterUpload = true;
	            }
	        },
	        getSigningKeysData: {
	            value: function getSigningKeysData() {
	                var _this = this;
	
	                this.signingKeysDao.get().$promise.then(function (result) {
	                    _this.publicKeyInstalled = result.publicKeyInstalled;
	                    _this.privateKeyInstalled = result.privateKeyInstalled;
	                    _this.publicKeyValue = result.publicKeyInstalled ? "Public key is installed" : "No public key installed";
	                    _this.privateKeyValue = result.privateKeyInstalled ? "Private key is installed" : "No private key installed";
	                    _this.publicKeyLink = result.publicKeyLink;
	                    _this.passPhrase = result.passPhrase;
	                });
	            }
	        },
	        getKeyStoreData: {
	            value: function getKeyStoreData() {
	                var _this = this;
	
	                this.keystoreDao.get().$promise.then(function (keyStore) {
	                    _this.keyStoreExist = keyStore.keyStoreExist;
	                    _.map(keyStore.keyStorePairNames, function (keypairName) {
	                        _this.keyPairNames.push(keypairName);
	                    });
	                });
	            }
	        },
	        onUploadPublicKeySuccess: {
	            value: function onUploadPublicKeySuccess(fileDetails, response) {
	                this.getSigningKeysData();
	                this.artifactoryNotifications.create(response.feedbackMsg);
	            }
	        },
	        onUploadPrivateKeySuccess: {
	            value: function onUploadPrivateKeySuccess(fileDetails, response) {
	                this.getSigningKeysData();
	                this.artifactoryNotifications.create(response.feedbackMsg);
	            }
	        },
	        onUploadPublicKeyFail: {
	            value: function onUploadPublicKeyFail(fileDetails, response) {
	                this.artifactoryNotifications.create(response);
	            }
	        },
	        onUploadPrivateKeyFail: {
	            value: function onUploadPrivateKeyFail(fileDetails, response) {
	                this.artifactoryNotifications.create(response);
	            }
	        },
	        upload: {
	            value: function upload(type) {
	                if (type === "public") {
	                    this.uploaderPublicKey.queue[0].upload();
	                }
	                if (type === "private") {
	                    this.uploaderPrivateKey.queue[0].upload();
	                }
	                if (type === "keyStore") {
	                    this.uploaderKeyStore.queue[0].formData[0] = {
	                        password: this.keyPair.keyStorePassword
	                    };
	                    this.uploaderKeyStore.queue[0].url = "" + API.API_URL + "/keystore/upload";
	                    this.uploaderKeyStore.queue[0].upload();
	                }
	            }
	        },
	        removeKey: {
	            value: function removeKey(isPublic) {
	                var _this = this;
	
	                this.signingKeysDao["delete"]({ "public": isPublic }).$promise.then(function (result) {
	                    return _this.getSigningKeysData();
	                });
	            }
	        },
	        verifyPhrase: {
	            value: function verifyPhrase() {
	                var shouldNotify = arguments[0] === undefined ? true : arguments[0];
	
	                //this.signingKeysDao.setNotification('post', shouldNotify);
	                var method = shouldNotify ? "post" : "postWithoutNotifications";
	                if (this.signingKeysDao[method]) {
	                    return this.signingKeysDao[method]({ action: "verify", passPhrase: this.passPhrase }).$promise;
	                }
	            }
	        },
	        updatePhrase: {
	            value: function updatePhrase() {
	                var _this = this;
	
	                var verifyPromise = this.verifyPhrase(false);
	                if (verifyPromise) {
	                    verifyPromise.then(function () {
	                        _this.signingKeysDao.put({ action: "update", passPhrase: _this.passPhrase });
	                    })["catch"](function (response) {
	                        return _this.artifactoryNotifications.create(response.data);
	                    });
	                    ;
	                }
	            }
	        },
	        checkMatchingPasswords: {
	            value: function checkMatchingPasswords() {
	                var _this = this;
	
	                this.$timeout(function () {
	                    if (_this.signingKeysForm.password.$valid && _this.signingKeysForm.repeatPassword.$valid) {
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION);
	                    }
	                });
	            }
	        },
	        updatePassword: {
	            value: function updatePassword() {
	                var _this = this;
	
	                this.keystoreDao.updatePassword({ action: "updatePass" }, { password: this.user.password }).$promise.then(function () {
	                    _this.keyStoreExist = true;
	                });
	            }
	        },
	        removeKeyStore: {
	            value: function removeKeyStore() {
	                var _this = this;
	
	                this.keystoreDao.removeKeystore({ action: "password" }).$promise.then(function () {
	                    //_.forEach(this.keyPairNames, this.removeKeypair, this);
	                    _this.keyStoreExist = false;
	                    _this.keyPairNames = [];
	                    _this.keyPairName = "";
	                    _this.user.password = "";
	                    _this.repeatPassword = "";
	                });
	            }
	        },
	        onUploadKeyFileAdded: {
	            value: function onUploadKeyFileAdded() {
	                this.keyStorePassRequired = true;
	            }
	        },
	        onUploadKeyStoreSuccess: {
	            value: function onUploadKeyStoreSuccess(fileDetails, keyStore) {
	                this.keyStorePassRequired = false;
	                this.keystoreFileUploaded = true;
	                this.keyStore = keyStore;
	                this.aliases = keyStore.availableAliases;
	                this.alias = this.aliases[0];
	                this.keyPair.keyStorePassword = "";
	                this.artifactoryNotifications.create(keyStore.feedbackMsg);
	            }
	        },
	        onUploadKeyStoreFail: {
	            value: function onUploadKeyStoreFail(fileDetails, response) {
	                this.keyStorePassRequired = false;
	                this.artifactoryNotifications.create(response);
	            }
	        },
	        saveKeypair: {
	            value: function saveKeypair() {
	                var _this = this;
	
	                var payload = _.cloneDeep(this.keyStore);
	                delete payload.feedbackMsg;
	                delete payload.availableAliases;
	                payload.alias = this.alias;
	
	                this.keystoreDao.save({ action: "add" }, payload).$promise.then(function (response) {
	                    _this.keyPairNames.push(_this.keyStore.keyPairName);
	                    _this.keyStore.keyPairName = "";
	                    _this.keyStore.privateKeyPassword = "";
	                    _this.alias = "";
	                    _this.aliases = [];
	                });
	                //.finally(() => this.keystoreFileUploaded = false);
	            }
	        },
	        removeKeypair: {
	            value: function removeKeypair() {
	                var _this = this;
	
	                this.keystoreDao.removeKeypair({ name: this.keyPairName }).$promise.then(function (response) {
	                    _.pull(_this.keyPairNames, _this.keyPairName);
	                    _this.keyPairName = "";
	                })["catch"](function (response) {
	                    if (response.error) {
	                        var keyPairNames = _.words(response.error);
	                        _.pull(_this.keyPairNames, keyPairNames.pop());
	                    }
	                });
	            }
	        },
	        cancelKeypairUpload: {
	            value: function cancelKeypairUpload() {
	                //this.keystoreFileUploaded = false;
	                this.keyStore.keyPairName = "";
	                this.keyStore.privateKeyPassword = "";
	            }
	        },
	        canUpdatePassword: {
	            value: function canUpdatePassword() {
	                return this.signingKeysForm.password.$valid && this.signingKeysForm.repeatPassword.$valid;
	            }
	        },
	        canUploadKeystore: {
	            value: function canUploadKeystore() {
	                return this.keyStoreExist && this.signingKeysForm.keyStorePassword.$valid && this.uploaderKeyStore.queue.length;
	            }
	        },
	        canUploadDebianKey: {
	            value: function canUploadDebianKey(uploader) {
	                return this[uploader].queue.length;
	            }
	        },
	        canRemoveKeyPairs: {
	            value: function canRemoveKeyPairs() {
	                return this.keyStoreExist && this.keyPairNames.length && this.keyPairName;
	            }
	        },
	        canUpdatePhrase: {
	            value: function canUpdatePhrase() {
	                return this.publicKeyInstalled && this.privateKeyInstalled && this.passPhrase;
	            }
	        }
	    });
	
	    return SigningKeysController;
	})();

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var TrustedKeysController = __webpack_require__(276).TrustedKeysController;
	
	function trustedKeysConfig($stateProvider) {
	
	  $stateProvider.state("admin.security.trusted_keys", {
	    params: { feature: "trustedkeys" },
	    url: "/trusted_keys",
	    templateUrl: "states/admin/security/trusted_keys/trusted_keys.html",
	    controller: "TrustedKeysController as TrustedKeys"
	  });
	}
	
	module.exports = angular.module("security.trusted_keys", []).config(trustedKeysConfig).controller("TrustedKeysController", TrustedKeysController);

/***/ }),
/* 276 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TrustedKeysController = exports.TrustedKeysController = (function () {
		function TrustedKeysController($scope, $rootScope, TrustedKeysDao, JFrogTableViewOptions, JFrogModal, JFrogNotifications) {
			_classCallCheck(this, TrustedKeysController);
	
			this.$scope = $scope;
			this.$rootScope = $rootScope;
			this.TrustedKeysDao = TrustedKeysDao;
			this.JFrogTableViewOptions = JFrogTableViewOptions;
			this.artifactoryNotifications = JFrogNotifications;
			this.modal = JFrogModal;
	
			this.modalScope = null;
	
			this._createGrid();
			this._getTrustedKeysData();
		}
	
		_createClass(TrustedKeysController, {
			_getTrustedKeysData: {
				value: function _getTrustedKeysData() {
					var _this = this;
	
					this.TrustedKeysDao.getTrustedKeys().$promise.then(function (response) {
						_this.trustedKeys = response;
						_this.tableViewOptions.setData(_this.trustedKeys);
					});
				}
			},
			_createGrid: {
				value: function _createGrid() {
					var _this = this;
	
					this.tableViewOptions = new this.JFrogTableViewOptions(this.$scope);
					this.tableViewOptions.setColumns(this._getColumns()).setRowsPerPage(20).setObjectName("Key/Keys").setEmptyTableText("No Trusted Keys").setActions(this.getActions()).setBatchActions(this.getBatchActions()).setNewEntityAction(function () {
						_this._addNewLicense();
					});
				}
			},
			_addNewLicense: {
				value: function _addNewLicense() {
					var _this = this;
	
					this.modalScope = this.$rootScope.$new();
					this.modalScope.modalTitle = "Add new trusted key";
					this.modalScope.ctrl = {
						aliasName: "",
						cretificateKey: ""
					};
					this.modalScope.dndStyle = { width: "100%", height: "200px" }; // the primitive should be wrapped with some object
					this.modalScope.dndOnError = function (errorMessage) {
						_this.artifactoryNotifications.create({
							error: errorMessage
						});
					};
	
					this.modalScope.saveKey = function () {
						var certificateJson = {
							alias: _this.modalScope.ctrl.aliasName,
							public_key: _this.modalScope.ctrl.cretificateKey.replace(/(?:\r\n|\r)/g, "\n")
						};
	
						_this.TrustedKeysDao.AddTrustedKey(certificateJson).$promise.then(function (response) {
							if (response.status === 201) {
								_this._getTrustedKeysData();
								_this.modalInstance.close();
							}
						});
					};
	
					this.modalScope.canSave = function () {
						return !_this.modalScope.ctrl.aliasName && !_this.modalScope.ctrl.aliasName.length || !_this.modalScope.ctrl.cretificateKey && !_this.modalScope.ctrl.cretificateKey.length;
					};
	
					this.modalScope.closeModal = function () {
						return _this.modalInstance.close();
					};
	
					this.modalInstance = this.modal.launchModal("ssh_key_modal", this.modalScope);
				}
			},
			_getColumns: {
				value: function _getColumns() {
					return [{
						header: "Alias",
						field: "alias",
						cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.alias}}</div>",
						width: "20%"
					}, {
						header: "Key ID",
						field: "kid",
						cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.kid}}</div>",
						width: "20%"
					}, {
						header: "Issued By",
						cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.issuedBy}}</div>",
						field: "issuedBy",
						width: "20%"
					}, {
						header: "Issued On",
						cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.issued | date: \"yyyy-MM-dd HH:mm:ss Z\"}}</div>",
						field: "issued",
						width: "20%"
					}, {
						header: "Valid Until",
						cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.expiry || \"\"}}</div>",
						field: "expiry",
						width: "20%"
					}, {
						header: "Fingerprint",
						cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.fingerprint}}</div>",
						field: "fingerprint",
						width: "20%"
					}];
				}
			},
			getBatchActions: {
				value: function getBatchActions() {
					var _this = this;
	
					return [{
						icon: "clear",
						name: "Delete",
						callback: function (selected) {
							var keysToRemove = _.map(selected, function (val) {
								return { kid: val.kid };
							});
							var message = "Are you sure you want to delete ";
							message += keysToRemove.length > 1 ? keysToRemove.length + " trusted keys?" : selected[0].alias + " trusted key?";
	
							_this.modal.confirm(message).then(function () {
								_this.TrustedKeysDao.deleteTrustedKey(keysToRemove).$promise.then(function (response) {
									if (response.status === 200) {
										_this.trustedKeys = _.difference(_this.trustedKeys, selected);
										_this.tableViewOptions.clearSelection();
										_this.tableViewOptions.setData(_this.trustedKeys);
									}
								});
							});
						}
					}];
				}
			},
			getActions: {
				value: function getActions() {
					var _this = this;
	
					return [{
						icon: "icon icon-clear",
						tooltip: "Delete",
						callback: function (row) {
							var message = "Are you sure you want to delete " + row.alias + " trusted key?";
	
							_this.modal.confirm(message).then(function () {
								_this.TrustedKeysDao.deleteTrustedKey([{ kid: row.kid }]).$promise.then(function (response) {
									if (response.status === 200) {
										_this.trustedKeys = _.difference(_this.trustedKeys, [row]);
										_this.tableViewOptions.setData(_this.trustedKeys);
									}
								});
							});
						}
					}];
				}
			}
		});
	
		return TrustedKeysController;
	})();

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AccessTokensController = __webpack_require__(278).AccessTokensController;
	
	function accessTokensConfig($stateProvider) {
	
	    $stateProvider.state("admin.security.access_tokens", {
	        params: { feature: "accesstokens" },
	        url: "/access_tokens",
	        templateUrl: "states/admin/security/access_tokens/access_tokens.html",
	        controller: "AccessTokensController as AccessTokens"
	    });
	}
	
	module.exports = angular.module("security.access_tokens", []).config(accessTokensConfig).controller("AccessTokensController", AccessTokensController);

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var AccessTokensController = exports.AccessTokensController = (function () {
	    function AccessTokensController($scope, $timeout, AccessTokensDao, uiGridConstants, commonGridColumns, JFrogGridFactory, JFrogModal) {
	        _classCallCheck(this, AccessTokensController);
	
	        this.gridOption = {};
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.AccessTokensDao = AccessTokensDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.modal = JFrogModal;
	        this.noTokensMessage = CONFIG_MESSAGES.admin.security.accessTokens.noTokensMessage;
	
	        this.showExpirable = false;
	
	        this._createGrid();
	        this._getData();
	
	        this.$timeout(function () {
	            return $(".counter-and-filter").after($("#expireableTokens"));
	        }, 100);
	    }
	
	    _createClass(AccessTokensController, {
	        filterGrid: {
	            value: function filterGrid() {
	                var _this = this;
	
	                var filteredData = undefined;
	
	                if (this.showExpirable) {
	                    filteredData = this.allTokens;
	                } else {
	                    filteredData = _.filter(this.allTokens, function (token) {
	                        return !_this.isRowExpirable(token);
	                    });
	                }
	
	                this.gridOption.setGridData(filteredData);
	            }
	        },
	        _getData: {
	            value: function _getData() {
	                var _this = this;
	
	                // get all tokens
	                this.AccessTokensDao.getTokens().$promise.then(function (tokens) {
	                    _this.allTokens = [].concat(tokens); //shallow copy
	                    _this.filterGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;
	
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getColumns()).setButtons(this._getActions()).setMultiSelect().setRowTemplate("default").setBatchActions(this._getBatchActions());
	
	                this.gridOption.isRowSelectable = function (row) {
	                    return !_this.isRowExpirable(row.entity);
	                };
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	
	                return [{
	                    field: "subject",
	                    name: "Subject",
	                    displayName: "Subject",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.subject}}</div>",
	                    width: "28%"
	                }, {
	                    field: "tokenId",
	                    name: "Token ID",
	                    displayName: "Token ID",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.tokenId}}</div>",
	                    width: "24%"
	                }, {
	                    field: "issuedAt",
	                    name: "Issued At",
	                    displayName: "Issued At",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.issuedAt}}</div>",
	                    sort: {
	                        direction: this.uiGridConstants.DESC
	                    },
	                    width: "18%"
	                }, {
	                    field: "expiryDate",
	                    name: "Expiry Date",
	                    displayName: "Expiry Date",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.expiry}}</div>",
	                    width: "18%"
	                }, {
	                    field: "refreshable",
	                    name: "Refreshable",
	                    displayName: "Refreshable",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.refreshable"),
	                    width: "12%"
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Revoke",
	                    visibleWhen: function (row) {
	                        return !_this.isRowExpirable(row);
	                    },
	                    callback: function (row) {
	                        return _this.revokeToken(row);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Revoke",
	                    callback: function () {
	                        return _this.bulkRevoke();
	                    }
	                }];
	            }
	        },
	        revokeToken: {
	            value: function revokeToken(token) {
	                var _this = this;
	
	                // Create array with single token ID to revoke
	                var json = [token.tokenId];
	                this.modal.confirm("Are you sure you want to revoke this access token? Once revoked,\n                            it can not be used again.", "Revoke access token", { confirm: "Revoke" }).then(function () {
	                    return _this.AccessTokensDao.revokeTokens(json).$promise.then(function () {
	                        return _this._getData();
	                    });
	                });
	            }
	        },
	        bulkRevoke: {
	            value: function bulkRevoke() {
	                var _this = this;
	
	                // Get All selected users
	                var selectedRows = this.gridOption.api.selection.getSelectedRows();
	                // Create an array of the selected tokens
	                var tokenIds = _.map(selectedRows, function (token) {
	                    return token.tokenId;
	                });
	
	                //Ask for confirmation before revoke and if confirmed then revoke bulk of tokens
	                this.modal.confirm("Are you sure you want to revoke these access tokens? Once revoked, \n                            they can not be used again.", "Revoke access tokens", { confirm: "Revoke" }).then(function () {
	                    return _this.AccessTokensDao.revokeTokens(tokenIds).$promise.then(function () {
	                        return _this._getData();
	                    });
	                });
	            }
	        },
	        isRowExpirable: {
	            value: function isRowExpirable(row) {
	                return row.expiry && !row.refreshable;
	            }
	        }
	    });
	
	    return AccessTokensController;
	})();

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by tomere on 07/06/2017.
	 */
	"use strict";
	
	var SslCertificatesController = __webpack_require__(280).SslCertificatesController;
	
	function sslCertificatesConfig($stateProvider) {
	
	  $stateProvider.state("admin.security.ssl_certificates", {
	    params: { feature: "sslcertificates" },
	    url: "/ssl_certificates",
	    templateUrl: "states/admin/security/ssl_certificates/ssl_certificates.html",
	    controller: "SslCertificatesController as SslCertificates"
	  });
	}
	
	module.exports = angular.module("security.ssl_certificates", []).config(sslCertificatesConfig).controller("SslCertificatesController", SslCertificatesController);

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by tomere on 07/06/2017.
	 */
	
	var DICTIONARY = _interopRequire(__webpack_require__(135));
	
	var SslCertificatesController = exports.SslCertificatesController = (function () {
	    function SslCertificatesController(JFrogNotifications, JFrogGridFactory, uiGridConstants, $timeout, $state, $scope, $rootScope, JFrogModal, SslCertificateDao) {
	        _classCallCheck(this, SslCertificatesController);
	
	        this.artifactoryNotifications = JFrogNotifications;
	
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$rootScope = $rootScope;
	        this.modal = JFrogModal;
	        this.sslCertificateDao = SslCertificateDao;
	        this.DICTIONARY = DICTIONARY.sslCertificate;
	
	        this.gridOption = {};
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.uiGridConstants = uiGridConstants;
	
	        this.createSslCertificatesGrid();
	        this.initSiginingKeysGrid();
	    }
	
	    _createClass(SslCertificatesController, {
	        initSiginingKeysGrid: {
	            value: function initSiginingKeysGrid() {
	                var _this = this;
	
	                this.sslCertificateDao.getAllCertificates().$promise.then(function (results) {
	                    _this.sslCertificates = results.data;
	                    _this.gridOption.setGridData(_this.sslCertificates);
	                });
	            }
	        },
	        createSslCertificatesGrid: {
	            value: function createSslCertificatesGrid() {
	                this.gridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getCloumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        _getActions: {
	
	            /**
	            * Data grid actions
	            * */
	
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (certificate) {
	                        _this.deleteCertificate(certificate);
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        _this.deleteSelectedCertificates();
	                    }
	                }];
	            }
	        },
	        deleteCertificate: {
	            value: function deleteCertificate(certificate) {
	                var _this = this;
	
	                var alias = certificate.alias;
	                this.modal.confirm("Are you sure you want to delete '" + alias + "' certificate?").then(function () {
	                    var certificatesJson = {
	                        certificates: [alias]
	                    };
	                    _this.sslCertificateDao["delete"](certificatesJson).$promise.then(function () {
	                        return _this.updateListTable();
	                    });
	                });
	            }
	        },
	        deleteSelectedCertificates: {
	            value: function deleteSelectedCertificates() {
	                var _this = this;
	
	                //Get All selected licenses
	                var selectedRows = this.gridOption.api.selection.getSelectedGridRows();
	                //Create an array of the selected licenses keys
	                var certificates = _.map(selectedRows, function (row) {
	                    return row.entity.alias;
	                });
	
	                //Create Json for the bulk request
	                var certificatesJson = {
	                    certificates: certificates
	                };
	
	                //Ask for confirmation before delete and if confirmed then delete bulk of licenses
	                this.modal.confirm("Are you sure you want to delete " + selectedRows.length + " certificates?").then(function () {
	                    _this.sslCertificateDao["delete"](certificatesJson).$promise.then(function () {
	                        _this.refreshTable();
	                    });
	                });
	            }
	        },
	        refreshTable: {
	            value: function refreshTable() {
	                var _this = this;
	
	                this.updateListTable()["finally"](function () {
	                    _this.clearSelectAllButton();
	                });
	            }
	        },
	        clearSelectAllButton: {
	            value: function clearSelectAllButton() {
	                this.$timeout(function () {
	                    var selectAllButton = $(".ui-grid-header-cell-row .ui-grid-selection-row-header-buttons");
	                    var selectAllButtonIsOn = selectAllButton.is(".ui-grid-all-selected");
	                    if (selectAllButtonIsOn) {
	                        selectAllButton.trigger("click");
	                    }
	                });
	            }
	        },
	        updateListTable: {
	            value: function updateListTable() {
	                var _this = this;
	
	                return this.sslCertificateDao.getAllCertificates().$promise.then(function (certificates) {
	                    _this.sslCertificates = certificates.data;
	                    _this.gridOption.setGridData(_this.sslCertificates);
	                });
	            }
	        },
	        showCertificateDetails: {
	
	            /**
	             * Data grid columns template
	             * */
	
	            value: function showCertificateDetails(entity) {
	                this.getCertificateData(entity.alias);
	            }
	        },
	        getCloumns: {
	            value: function getCloumns() {
	                return [{
	                    name: "Certificate Alias",
	                    displayName: "Certificate Alias",
	                    field: "alias",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                            <a href \n                               ng-click=\"grid.appScope.SslCertificates.showCertificateDetails(row.entity)\">\n                               {{row.entity.alias}}\n                            </a>\n                      </div>",
	                    width: "15%"
	                }, {
	                    name: "Issued By",
	                    displayName: "Issued By",
	                    field: "issued_by",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                    {{row.entity.issued_by}}\n                               </div>",
	                    width: "15%"
	                }, {
	                    name: "Issued To",
	                    displayName: "Issued To",
	                    field: "issued_to",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                    {{row.entity.issued_to}}\n                               </div>",
	                    width: "15%"
	                }, {
	                    name: "Valid Until",
	                    displayName: "Valid Until",
	                    field: "valid_until",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                    {{row.entity.valid_until}}\n                               </div>",
	                    width: "15%"
	                }, {
	                    name: "Fingerprint",
	                    displayName: "Fingerprint",
	                    field: "fingerprint",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                    {{row.entity.fingerprint}}\n                               </div>",
	                    width: "40%"
	                }];
	            }
	        },
	        launchCertificateKeyModal: {
	
	            /**
	             * Add certificate modal
	             * */
	
	            value: function launchCertificateKeyModal() {
	                var _this = this;
	
	                this.modalScope = this.$rootScope.$new();
	                this.modalScope.modalTitle = "Add New Certificate";
	                this.modalScope.newCertificate = { text: "" }; // Whenever two-way binding a primitive (i.e. string) on a scope
	                this.modalScope.aliasName = { text: "" };
	                this.modalScope.dndStyle = { width: "100%", height: "200px" }; // the primitive should be wrapped with some object
	                this.modalScope.dndOnError = function (errorMessage) {
	                    _this.artifactoryNotifications.create({
	                        error: errorMessage
	                    });
	                };
	
	                this.modalScope.saveCertificate = function () {
	
	                    var certificateJson = {
	                        certificateName: _this.modalScope.aliasName.text,
	                        certificatePEM: _this.modalScope.newCertificate.text.replace(/(?:\r\n|\r)/g, "\n")
	                    };
	                    _this.sslCertificateDao.add({ $suppress_toaster: false }, certificateJson).$promise.then(function (data) {
	                        if (data.status === 200) {
	                            _this.updateListTable()["finally"](function () {
	                                return _this.closeModalIfOpen();
	                            });
	                        }
	                    });
	                };
	
	                this.modalScope.canSave = function () {
	                    return !_this.modalScope.aliasName.text || !_this.modalScope.newCertificate.text || !_this.modalScope.aliasName.text.length || !_this.modalScope.newCertificate.text.length;
	                };
	
	                this.modalScope.closeModal = function () {
	                    return _this.modalInstance.close();
	                };
	
	                this.modalInstance = this.modal.launchModal("add_ssl_certificate_modal", this.modalScope, "lg");
	            }
	        },
	        getCertificateData: {
	
	            /**
	             * View certificate details modal
	             * */
	
	            value: function getCertificateData(certificateAlias) {
	                var _this = this;
	
	                this.sslCertificateDao.getDetails({ certificate_alias: certificateAlias }).$promise.then(function (data) {
	                    if (data.status === 200) {
	                        console.log(data);
	                        _this.launchViewCertificateDetailsModal(data.data, certificateAlias);
	                    }
	                });
	            }
	        },
	        launchViewCertificateDetailsModal: {
	            value: function launchViewCertificateDetailsModal(certificate, certificateAlias) {
	                var _this = this;
	
	                this.modalScope = this.$rootScope.$new();
	                this.modalScope.modalTitle = certificateAlias + " Certificate Details ";
	                this.modalScope.certificateDetails = certificate;
	                this.modalScope.DICTIONARY = this.DICTIONARY;
	
	                this.modalScope.closeModal = function () {
	                    return _this.modalInstance.close();
	                };
	
	                this.modalInstance = this.modal.launchModal("ssl_certificate_details_modal", this.modalScope, "lg");
	            }
	        },
	        closeModalIfOpen: {
	            value: function closeModalIfOpen() {
	                if (this.modalInstance) {
	                    this.modalScope.closeModal();
	                }
	            }
	        }
	    });
	
	    return SslCertificatesController;
	})();

/***/ }),
/* 281 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminSecurityController = exports.AdminSecurityController = (function () {
	    function AdminSecurityController($modal) {
	        _classCallCheck(this, AdminSecurityController);
	
	        this.userData = this.getUserGridData();
	        this.modal = $modal;
	    }
	
	    _createClass(AdminSecurityController, {
	        getUserGridData: {
	            value: function getUserGridData() {
	
	                return [{ "User Name": "System Info", Realm: "admin.advanced.system_info", Admin: true, "Last Login": "12/12/2015", "Extrenal Realm Status": "bla bla" }, { "User Name": "System Info", Realm: "admin.advanced.system_info", Admin: true, "Last Login": "12/12/2015", "Extrenal Realm Status": "bla bla" }, { "User Name": "System Info", Realm: "admin.advanced.system_info", Admin: true, "Last Login": "12/12/2015", "Extrenal Realm Status": "bla bla" }, { "User Name": "System Info", Realm: "admin.advanced.system_info", Admin: true, "Last Login": "12/12/2015", "Extrenal Realm Status": "bla bla" }];
	            }
	        },
	        addUser: {
	            value: function addUser() {
	                this.modal.open({ template: "<div>test test</div>" });
	                this.userData.push({});
	            }
	        }
	    });
	
	    return AdminSecurityController;
	})();

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var Backups = _interopRequire(__webpack_require__(283));
	
	var Indexer = _interopRequire(__webpack_require__(286));
	
	var AdminServicesController = __webpack_require__(288).AdminServicesController;
	
	function adminServicesConfig($stateProvider) {
	    $stateProvider.state("admin.services", {
	        url: "/services",
	        template: "<ui-view></ui-view>",
	        controller: "AdminServicesController as AdminServices"
	    });
	}
	
	module.exports = angular.module("admin.services", [Backups.name, Indexer.name]).config(adminServicesConfig).controller("AdminServicesController", AdminServicesController);

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminServicesBackupsController = __webpack_require__(284).AdminServicesBackupsController;
	
	var AdminServicesBackupFormController = __webpack_require__(285).AdminServicesBackupFormController;
	
	function backupsConfig($stateProvider) {
	
	    $stateProvider.state("admin.services.backups", {
	        params: { feature: "backups" },
	        url: "/backups",
	        templateUrl: "states/admin/services/backups/backups.html",
	        controller: "AdminServicesBackupsController as AdminServicesBackups"
	    }).state("admin.services.backups.new", {
	        params: { feature: "backups" },
	        parent: "admin.services",
	        url: "/backups/new",
	        templateUrl: "states/admin/services/backups/backup_form.html",
	        controller: "AdminServicesBackupFormController as BackupForm"
	    }).state("admin.services.backups.edit", {
	        params: { feature: "backups" },
	        parent: "admin.services",
	        url: "/backups/:backupKey/edit",
	        templateUrl: "states/admin/services/backups/backup_form.html",
	        controller: "AdminServicesBackupFormController as BackupForm"
	    });
	}
	
	module.exports = angular.module("backups", []).config(backupsConfig).controller("AdminServicesBackupsController", AdminServicesBackupsController).controller("AdminServicesBackupFormController", AdminServicesBackupFormController);

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var AdminServicesBackupsController = exports.AdminServicesBackupsController = (function () {
	    function AdminServicesBackupsController($scope, BackupDao, JFrogGridFactory, JFrogModal, RepoDataDao, $q, commonGridColumns) {
	        _classCallCheck(this, AdminServicesBackupsController);
	
	        this.backupDao = BackupDao;
	        this.repoDataDao = RepoDataDao;
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.$scope = $scope;
	        this.commonGridColumns = commonGridColumns;
	        this.noBackupsMessage = CONFIG_MESSAGES.admin.services.backups.noBackupsMessage;
	        this._createGrid();
	        this._initBackups();
	        this.$q = $q;
	    }
	
	    _createClass(AdminServicesBackupsController, {
	        _initBackups: {
	            value: function _initBackups() {
	                var _this = this;
	
	                this.backupDao.query().$promise.then(function (backups) {
	                    _this.gridBackupsOptions.setGridData(backups);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.gridBackupsOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setSingleSelect().setButtons(this._getActions()).setRowTemplate("default");
	                //.setMultiSelect()
	                //.setBatchActions(this._getBatchActions());
	            }
	        },
	        _doDeleteBackup: {
	            value: function _doDeleteBackup(key) {
	                return this.backupDao["delete"]({ key: key }).$promise;
	            }
	        },
	        deleteBackup: {
	
	            /* deleteSelectedBackups() {
	                 let selectedRows = this.gridBackupsOptions.api.selection.getSelectedGridRows();
	                 this.modal.confirm(`Are you sure you want to delete ${selectedRows.length} backups?`)
	                     .then(() => {
	                         return this.$q.all(selectedRows.map((row) => this._doDeleteBackup(row.entity.key)))
	                     })
	                     .then(() => this._initBackups())
	             }*/
	
	            value: function deleteBackup(key) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete the backup '" + key + "'?").then(function () {
	                    return _this._doDeleteBackup(key);
	                }).then(function () {
	                    return _this._initBackups();
	                });
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "key",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a ui-sref=\"^.backups.edit({backupKey: row.entity.key})\" class=\"jf-link\" >{{ COL_FIELD }}</a></div>",
	                    width: "15%"
	                }, {
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    field: "includeRepos",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.includeRepos", "row.entity.key"),
	                    width: "30%"
	                }, {
	                    name: "Cron Expression",
	                    displayName: "Cron Expression",
	                    field: "cronExp",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ COL_FIELD }}</div>",
	                    width: "15%"
	                }, {
	                    name: "Next Schedule Backup",
	                    displayName: "Next Schedule Backup",
	                    field: "cronExp",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><input class=\"not-like-input\" type=\"text\" jf-cron-formatter ng-model=\"row.entity.cronExp\" disabled></div>",
	                    width: "20%"
	                }, {
	                    field: "enabled",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.enabled"),
	                    width: "10%"
	                }, {
	                    name: "Run Now",
	                    displayName: "Run Now",
	                    field: "runnow",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents text-center\"><a class=\"grid-column-button icon icon-run\" ng-click=\"grid.appScope.AdminServicesBackups.runNow(row.entity)\" ng-disabled=\"!row.entity.enabled\"></a></div>",
	                    width: "10%",
	                    enableSorting: false
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (entity) {
	                        return _this.deleteBackup(entity.key);
	                    }
	                }];
	            }
	        },
	        runNow: {
	            value: function runNow(row) {
	                var _this = this;
	
	                if (row.enabled) {
	                    this.backupDao.get({ key: row.key }).$promise.then(function (backup) {
	                        _this.backupDao.runNow({}, backup).$promise.then(function (res) {});
	                    });
	                }
	            }
	            /*    _getBatchActions() {
	                    return [
	                        {
	                            icon: 'clear',
	                            name: 'Delete',
	                            callback: () => this.deleteSelectedBackups()
	                        },
	                    ]
	                }*/
	
	        }
	    });
	
	    return AdminServicesBackupsController;
	})();

	//console.log(res);

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var $state = undefined,
	    $stateParams = undefined,
	    RepoDataDao = undefined,
	    BackupDao = undefined;
	
	var AdminServicesBackupFormController = exports.AdminServicesBackupFormController = (function () {
	    function AdminServicesBackupFormController($scope, _$state_, _$stateParams_, _RepoDataDao_, _BackupDao_, BrowseFilesDao, ArtifactoryModelSaver, JFrogEventBus) {
	        var _this = this;
	
	        _classCallCheck(this, AdminServicesBackupFormController);
	
	        $state = _$state_;
	        this.$scope = $scope;
	        $stateParams = _$stateParams_;
	        RepoDataDao = _RepoDataDao_;
	        BackupDao = _BackupDao_;
	        this.JFrogEventBus = JFrogEventBus;
	        this.browseFilesDao = BrowseFilesDao.getInstance();
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["backup"]);
	
	        this.isNew = !$stateParams.backupKey;
	        this.TOOLTIP = TOOLTIP.admin.services.backupsForm;
	        this.formTitle = "" + (this.isNew ? "New" : "Edit " + $stateParams.backupKey) + " Backup";
	        this._initBackup();
	
	        this.fileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Export Backup",
	            pathLabel: "Path to Export Backup",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: true
	        };
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            RepoDataDao.getForBackup().$promise.then(function (repoData) {
	                _this.addRepos(repoData.repoList);
	            });
	        });
	    }
	
	    _createClass(AdminServicesBackupFormController, {
	        addRepos: {
	            value: function addRepos(repoList) {
	                var _this = this;
	
	                repoList.forEach(function (repo) {
	                    if (_this.backup.excludeRepos.indexOf(repo) == -1 && _this.backup.includeRepos.indexOf(repo) == -1) {
	                        _this.backup.includeRepos.push(repo);
	                    }
	                });
	
	                this.ArtifactoryModelSaver.save();
	            }
	        },
	        _initBackup: {
	            value: function _initBackup() {
	                var _this = this;
	
	                if (this.isNew) {
	                    RepoDataDao.getForBackup().$promise.then(function (repoData) {
	                        _this.backup = {
	                            enabled: true,
	                            sendMailOnError: true,
	                            retentionPeriodHours: 168,
	                            includeRepos: repoData.repoList,
	                            excludeRepos: [],
	                            precalculate: false
	                        };
	
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                } else {
	                    BackupDao.get({ key: $stateParams.backupKey }).$promise.then(function (backup) {
	                        _this.backup = backup;
	                        _this.ArtifactoryModelSaver.save();
	                    });
	                }
	            }
	        },
	        changeIncremental: {
	            value: function changeIncremental() {
	                if (this.backup.precalculate) {
	                    this.backup.precalculate = !this.backup.precalculate;
	                }
	            }
	        },
	        updateFolderPath: {
	            value: function updateFolderPath(directory) {
	                this.backup.dir = directory;
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.savePending) {
	                    return;
	                }this.savePending = true;
	
	                var whenSaved = this.isNew ? BackupDao.save(this.backup) : BackupDao.update(this.backup);
	                whenSaved.$promise.then(function () {
	                    _this.savePending = false;
	                    _this.ArtifactoryModelSaver.save();
	                    _this._end();
	                })["catch"](function () {
	                    return _this.savePending = false;
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this._end();
	            }
	        },
	        _end: {
	            value: function _end() {
	                $state.go("^.backups");
	            }
	        },
	        onClickIncremental: {
	            value: function onClickIncremental() {
	                if (this.backup.incremental) {
	                    this.backup.retentionPeriodHours = 0;
	                    this.backup.createArchive = false;
	                }
	            }
	        },
	        onClickZip: {
	            value: function onClickZip() {
	                if (this.backup.createArchive) {
	                    this.backup.incremental = false;
	                }
	            }
	            /*
	                MOVED TO MAIN BACKUPS GRID
	                runNow() {
	                    BackupDao.runNow({},this.backup).$promise.then((res)=>{
	                       //console.log(res);
	                    });
	                }
	            */
	
	        }
	    });
	
	    return AdminServicesBackupFormController;
	})();

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var AdminServicesIndexerController = __webpack_require__(287).AdminServicesIndexerController;
	
	function indexerConfig($stateProvider) {
	    $stateProvider.state("admin.services.indexer", {
	        params: { feature: "indexer" },
	        url: "/indexer",
	        templateUrl: "states/admin/services/indexer/indexer.html",
	        controller: "AdminServicesIndexerController as AdminServicesIndexer"
	    });
	}
	
	module.exports = angular.module("indexer", []).config(indexerConfig).controller("AdminServicesIndexerController", AdminServicesIndexerController);

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var AdminServicesIndexerController = exports.AdminServicesIndexerController = (function () {
	    function AdminServicesIndexerController($scope, IndexerDao, RepositoriesDao, ArtifactoryModelSaver, JFrogEventBus) {
	        var _this = this;
	
	        _classCallCheck(this, AdminServicesIndexerController);
	
	        this.$scope = $scope;
	        this.indexerDao = IndexerDao.getInstance();
	        this.repositoriesDao = RepositoriesDao;
	        this.indexer = {};
	        this.TOOLTIP = TOOLTIP.admin.services.mavenIndexer;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["indexer"]);
	        this.JFrogEventBus = JFrogEventBus;
	        this.getIndexerObject();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.repositoriesDao.indexerAvailableRepositories({ type: "Maven", layout: "maven-2-default" }).$promise.then(function (repoData) {
	                var repoList = repoData.availableLocalRepos.concat(repoData.availableRemoteRepos).concat(repoData.availableVirtualRepos);
	                _this.addRepos(repoList);
	            });
	        });
	    }
	
	    _createClass(AdminServicesIndexerController, {
	        getIndexerObject: {
	            value: function getIndexerObject() {
	                var _this = this;
	
	                this.indexerDao.get().$promise.then(function (result) {
	                    _this.indexer = result;
	                    _this.ArtifactoryModelSaver.save();
	                    _this.getRepoData();
	                });
	            }
	        },
	        addRepos: {
	            value: function addRepos(repoList) {
	                var _this = this;
	
	                repoList.forEach(function (repo) {
	                    if (_this.indexer.excludedRepos.indexOf(repo) == -1 && _this.indexer.includedRepos.indexOf(repo) == -1) {
	                        _this.indexer.includedRepos.push(repo);
	                    }
	                });
	
	                this.ArtifactoryModelSaver.save();
	            }
	        },
	        getRepoData: {
	            value: function getRepoData() {
	                var _this = this;
	
	                if (!this.indexer.includedRepos) {
	                    this.repositoriesDao.indexerAvailableRepositories({ type: "Maven", layout: "maven-2-default" }).$promise.then(function (repos) {
	                        _this.indexer.includedRepos = [];
	                        _this.indexer.excludedRepos = [];
	                        _this.indexer.includedRepos = repos.availableLocalRepos.concat(repos.availableRemoteRepos).concat(repos.availableVirtualRepos);
	                    });
	                }
	            }
	        },
	        runIndexer: {
	            value: function runIndexer() {
	                this.indexerDao.run(this.indexer);
	            }
	        },
	        save: {
	            value: function save(indexer) {
	                var _this = this;
	
	                this.indexerDao.save(indexer).$promise.then(function () {
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                var _this = this;
	
	                this.ArtifactoryModelSaver.ask(true).then(function () {
	                    _this.getIndexerObject();
	                });
	            }
	        }
	    });
	
	    return AdminServicesIndexerController;
	})();

/***/ }),
/* 288 */
/***/ (function(module, exports) {

	"use strict";
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminServicesController = exports.AdminServicesController = function AdminServicesController() {
	  _classCallCheck(this, AdminServicesController);
	
	  var AdminServices = this;
	  AdminServices.stateUrl = "/services";
	  AdminServices.controllerName = "AdminServicesController";
	};

/***/ }),
/* 289 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AdminController = exports.AdminController = (function () {
	    function AdminController($state, AdminMenuItems, ArtifactoryState, User, ArtifactoryFeatures) {
	        _classCallCheck(this, AdminController);
	
	        this.items = AdminMenuItems;
	        this.state = $state;
	        this.user = User.getCurrent();
	        this.artifactoryState = ArtifactoryState;
	        this.features = ArtifactoryFeatures;
	        this._goToSpecificAdminState();
	    }
	
	    _createClass(AdminController, {
	        _goToSpecificAdminState: {
	            value: function _goToSpecificAdminState() {
	                if (this.state.current.name !== "admin") {
	                    if (!this.state.current.name.match(/(?:.new|.edit)\b/)) {
	                        this.artifactoryState.setState("lastAdminState", this.state.current);
	                        this.artifactoryState.setState("lastAdminStateParams", this.state.params);
	                    }
	                    return;
	                }
	
	                var state = this.artifactoryState.getState("lastAdminState");
	                var stateParams = this.artifactoryState.getState("lastAdminStateParams");
	                var feature = state && state.params && state.params.feature;
	                if (!state || !this.user.canView(state.name) || this.features.isDisabled(feature) || this.features.isHidden(feature)) {
	                    state = this.user.isAdmin() ? "admin.repositories.list" : "admin.security.permissions";
	                    stateParams = this.user.isAdmin() ? { repoType: "local" } : {};
	                }
	                this.state.go(state, stateParams);
	            }
	        },
	        isDashboard: {
	            value: function isDashboard() {
	                return this.state.$current.includes["admin.dashboard"];
	            }
	        }
	    });
	
	    return AdminController;
	})();

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var ArtifactsController = __webpack_require__(291).ArtifactsController;
	
	var BrowsersController = __webpack_require__(293).BrowsersController;
	
	var jfTreeSearch = __webpack_require__(294).jfTreeSearch;
	
	var jfTreeBrowser = __webpack_require__(296).jfTreeBrowser;
	
	var jfTrashPin = __webpack_require__(298).jfTrashPin;
	
	var jfStashBrowser = __webpack_require__(299).jfStashBrowser;
	
	var selectTargetPathFactory = __webpack_require__(300).selectTargetPathFactory;
	
	var commonGridColumns = __webpack_require__(301).commonGridColumns;
	
	var selectDeleteVersionsFactory = __webpack_require__(302).selectDeleteVersionsFactory;
	
	var jfArtifactInfo = __webpack_require__(303).jfArtifactInfo;
	
	var infoTabs = _interopRequire(__webpack_require__(305));
	
	function artifactsConfig($stateProvider, $urlMatcherFactoryProvider) {
	
	    $urlMatcherFactoryProvider.type("pathParam", {
	        encode: function encode(item) {
	            return item;
	        },
	        decode: function decode(item) {
	            return item;
	        },
	        is: function is(item) {
	            return true;
	        }
	    });
	    $stateProvider.state("artifacts", {
	        url: "/artifacts",
	        parent: "app-layout",
	        abstract: true,
	        templateUrl: "states/artifacts/artifacts.html",
	        controller: "ArtifactsController as Artifact",
	        onExit: function (ArtifactoryState, TreeBrowserDao) {
	            // Stop saving last state of tree
	            ArtifactoryState.removeState("lastTreeState");
	            // Invalidate the tree node cache
	            //                    TreeBrowserDao.invalidateRoots();
	        },
	        onEnter: function (ArtifactoryState) {
	            // This should be true only when going from tree to simple before selecting any node in the tree
	            ArtifactoryState.setState("tree_touched", false);
	        }
	    }).state("artifacts.browsers", {
	        url: "/browse/{browser}",
	        templateUrl: "states/artifacts/browsers/browsers.html",
	        controller: "BrowsersController as Browsers",
	        onEnter: function (ArtifactoryStorage, $stateParams) {
	            if ($stateParams.browser !== "stash") ArtifactoryStorage.setItem("BROWSER", $stateParams.browser);
	        }
	    }).state("artifacts.browsers.path", {
	        url: "/{tab}/{artifact:pathParam}",
	        onEnter: function (JFrogEventBus, $stateParams, ArtifactoryState) {
	            // Save state of tree
	            ArtifactoryState.setState("lastTreeState", { name: "artifacts.browsers.path", params: $stateParams });
	            JFrogEventBus.dispatch(JFrogEventBus.getEventsDefinition().TABS_URL_CHANGED, $stateParams);
	        },
	        params: {}
	    });
	}
	
	module.exports = angular.module("artifacts", ["infoTabs"]).config(artifactsConfig).controller("ArtifactsController", ArtifactsController).controller("BrowsersController", BrowsersController).directive("jfTreeSearch", jfTreeSearch).directive("jfTreeBrowser", jfTreeBrowser).directive("jfTrashPin", jfTrashPin).directive("jfStashBrowser", jfStashBrowser).directive("jfArtifactInfo", jfArtifactInfo).factory("selectTargetPath", selectTargetPathFactory).factory("commonGridColumns", commonGridColumns).factory("selectDeleteVersions", selectDeleteVersionsFactory);
	
	//                    forceLoad: false // used to force reload of state even if it's the same artifact

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var TOOLTIPS = _interopRequire(__webpack_require__(107));
	
	var ICONS = _interopRequire(__webpack_require__(292));
	
	var ACTIONS = _interopRequire(__webpack_require__(169));
	
	var ArtifactsController = exports.ArtifactsController = (function () {
	    function ArtifactsController($rootScope, $scope, $state, JFrogEventBus, ArtifactoryState, SetMeUpModal, ArtifactoryDeployModal, User, ArtifactActions, JFrogModal, GoogleAnalytics, ArtifactoryFeatures) {
	        _classCallCheck(this, ArtifactsController);
	
	        this.JFrogEventBus = JFrogEventBus;
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$rootScope = $rootScope;
	        this.node = null;
	        this.ArtifactoryFeatures = ArtifactoryFeatures;
	        this.deployModal = ArtifactoryDeployModal;
	        this.setMeUpModal = SetMeUpModal;
	        this.artifactoryState = ArtifactoryState;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.tooltips = TOOLTIPS;
	        this.icons = ICONS;
	        this.artifactActions = ArtifactActions;
	
	        this.user = User.getCurrent();
	
	        this.initEvents();
	        this.modal = JFrogModal;
	        this.initNoPermissionsModalScope();
	    }
	
	    _createClass(ArtifactsController, {
	        initNoPermissionsModalScope: {
	            value: function initNoPermissionsModalScope() {
	                this.noPermissionsModalScope = this.$rootScope.$new();
	                this.noPermissionsModalScope.modalTitle = "No Access Privileges";
	                this.noPermissionsModalScope.modalText = "You do not have permissions defined for any repository.<br/>" + "To gain access, make sure you are logged in, or contact your Artifactory administrator.";
	            }
	        },
	        launchNoPermissionsModal: {
	            value: function launchNoPermissionsModal() {
	                var _this = this;
	
	                this.modalInstance = this.modal.launchModal("no_permissions_modal", this.noPermissionsModalScope);
	                this.modalInstance.result["finally"](function () {
	                    _this.modalInstance.close();
	                    _this.$state.go("home");
	                });
	            }
	        },
	        getNodeIcon: {
	            value: function getNodeIcon() {
	                if (this.node && this.node.data) {
	                    var type = this.icons[this.node.data.iconType];
	                    if (!type) type = this.icons["default"];
	                    return type && type.icon;
	                }
	            }
	        },
	        isFavorite: {
	            value: function isFavorite() {
	                if (this.node && this.node.data) {
	                    return this.node.data.isFavorite();
	                };
	            }
	        },
	        openSetMeUp: {
	            value: function openSetMeUp() {
	                this.GoogleAnalytics.trackEvent("Artifacts", "Set me up - Open", this.node.data.repoPkgType, null, this.node.data.repoType);
	                this.setMeUpModal.launch(this.node);
	            }
	        },
	        openDeploy: {
	            value: function openDeploy() {
	                if (this.node && this.node.data) this.GoogleAnalytics.trackEvent("Artifacts", "Open deploy", this.node.data.repoPkgType, null, this.node.data.repoType);
	                this.deployModal.launch(this.node);
	            }
	        },
	        initEvents: {
	            value: function initEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TREE_NODE_SELECT, function (node) {
	                    _this.selectNode(node);
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, [EVENTS.ACTION_WATCH, EVENTS.ACTION_UNWATCH], function () {
	                    _this.actionsController.setActions(_this.node.data.actions);
	                    _this.JFrogEventBus.dispatch(EVENTS.TREE_NODE_CM_REFRESH, _this.node);
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.ACTION_FAVORITES, function () {
	                    if (!localStorage.favoritesRepos) return;
	                    var favoritesRepos = JSON.parse(localStorage.favoritesRepos);
	                    var isMarked = _.includes(favoritesRepos.favoritesRepos, _this.node.data.repoKey);
	
	                    var item = _.find(_this.node.data.actions, { name: "Favorites" });
	                    if (!item) return;
	                    ACTIONS.Favorites.icon = item.icon = isMarked ? "icon-star-full" : "icon-star";
	                    ACTIONS.Favorites.title = item.title = isMarked ? "Remove from Favorites" : "Add to Favorites";
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TREE_DATA_IS_SET, function (treeHasData) {
	                    _this.treeDataIsSet = true;
	                    if (!treeHasData) {
	                        _this.launchNoPermissionsModal();
	                    }
	                });
	            }
	        },
	        selectNode: {
	            value: function selectNode(node) {
	                var _this = this;
	
	                var previousNode = this.node;
	                this.node = node;
	
	                if (node && node.data) {
	                    this.artifactoryState.setState("repoKey", this.node.data.repoKey);
	
	                    if (this.$state.params.artifact !== node.data.fullpath) {
	                        var _location = true;
	                        if (this.$state.current.name === "artifacts.browsers.path" && (!previousNode || !this.$state.params.artifact)) {
	                            // If no artifact and selecting artifact - replace the location (fix back button bug)
	                            _location = "replace";
	                        }
	                        this.$state.go(this.$state.current, { artifact: node.data.fullpath }, { location: _location, notify: false, reload: this.$state.current });
	                    }
	
	                    this.actionsController.setCurrentEntity(node);
	                    this.node.data.getDownloadPath().then(function () {
	                        var downloadAction = _.find(node.data.actions, { name: "Download" });
	                        if (downloadAction) {
	                            downloadAction.href = node.data.actualDownloadPath;
	                            if (node.data.xrayShouldValidate) downloadAction.xrayShouldValidate = node.data.xrayShouldValidate;
	                        }
	                        _this.actionsController.setActions(node.data.actions);
	                    });
	
	                    this.JFrogEventBus.dispatch(EVENTS.ACTION_FAVORITES);
	                } else {
	                    this.artifactoryState.removeState("repoKey");
	                    this.$state.go(this.$state.current, { artifact: "" });
	                    this.actionsController.setActions([]);
	                }
	            }
	        },
	        exitStashState: {
	            value: function exitStashState() {
	                this.JFrogEventBus.dispatch(EVENTS.ACTION_EXIT_STASH);
	            }
	        },
	        hasData: {
	            value: function hasData() {
	                return this.artifactoryState.getState("hasArtifactsData") !== false;
	            }
	        },
	        initActions: {
	            value: function initActions(actionsController) {
	                this.actionsController = actionsController;
	                actionsController.setActionsHandler(this.artifactActions);
	                actionsController.setActionsDictionary(ACTIONS);
	            }
	        },
	        deployIsDisabled: {
	            value: function deployIsDisabled() {
	                if (!this.user.getCanDeploy()) {
	                    this.disabledTooltip = this.tooltips.artifacts.deploy.noDeployPermission;
	                    return true;
	                }
	                return false;
	            }
	        },
	        deployIsAllowedOnEdge: {
	            value: function deployIsAllowedOnEdge() {
	                return this.node.data.getRoot().repoPkgType === "Generic" && this.node.data.repoType === "local" && this.node.data.repoKey === "artifactory-edge-uploads";
	            }
	        },
	        toggleFavorites: {
	            value: function toggleFavorites(node) {
	                var repoKey = node.data.text;
	
	                if (!localStorage.favoritesRepos) {
	                    localStorage.setItem("favoritesRepos", JSON.stringify({ favoritesRepos: [repoKey] }));
	                } else {
	                    var favoritesRepos = JSON.parse(localStorage.favoritesRepos);
	
	                    var isRepoInFavorites = _.includes(favoritesRepos.favoritesRepos, repoKey);
	
	                    if (isRepoInFavorites) {
	                        favoritesRepos.favoritesRepos = _.remove(favoritesRepos.favoritesRepos, function (i) {
	                            return i !== repoKey;
	                        }); // Remove from favorites
	                    } else {
	                        favoritesRepos.favoritesRepos.push(repoKey); // Add to favorites
	                    }
	                    localStorage.setItem("favoritesRepos", JSON.stringify({ favoritesRepos: favoritesRepos.favoritesRepos }));
	                }
	                this.JFrogEventBus.dispatch(EVENTS.ACTION_FAVORITES);
	
	                if (localStorage.filterFavorites) this.JFrogEventBus.dispatch(EVENTS.TREE_REFRESH_FILTER);
	
	                delete node.$cachedCMItems;
	            }
	        }
	    });
	
	    return ArtifactsController;
	})();

	// Close and go home...

/***/ }),
/* 292 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	    file: {
	        icon: "icon icon-general"
	    },
	    "default": {
	        icon: "icon icon-general"
	    },
	    virtualRemoteFile: {
	        icon: "icon icon-general"
	    },
	    go_up: {
	        icon: "icon icon-folder go-up"
	    },
	    localRepository: {
	        icon: "icon icon-local-repo"
	    },
	    buildInfoRepository: {
	        icon: "icon icon-builds-new"
	    },
	    cachedRepository: {
	        icon: "icon icon-cached-repo"
	    },
	    virtualRepository: {
	        icon: "icon icon-virtual-repo"
	    },
	    distributionRepository: {
	        icon: "icon icon-distribution-repo"
	    },
	    remoteRepository: {
	        icon: "icon icon-remote-repo"
	    },
	    stash: {
	        icon: "icon icon-search"
	    },
	    trashcan: {
	        icon: "icon icon-trash"
	    },
	    folder: {
	        icon: "icon icon-folder"
	    },
	    virtualRemoteFolder: {
	        icon: "icon icon-folder"
	    },
	    compactedFolder: {
	        icon: "icon icon-folder"
	    },
	    "application/x-maven-pom+xml": {
	        icon: "icon icon-pom"
	    },
	    "application/xml": {
	        icon: "icon icon-xml"
	    },
	    "application/pdf": {
	        icon: "icon icon-pdf"
	    },
	    "text/html": {
	        icon: "icon icon-html"
	    },
	    "text/plain": {
	        icon: "icon icon-txt"
	    },
	    "text/css": {
	        icon: "icon icon-css"
	    },
	    "application/json": {
	        icon: "icon icon-json"
	    },
	    "application/x-debian-package": {
	        icon: "icon icon-deb"
	    },
	    "application/javascript": {
	        icon: "icon icon-js"
	    },
	    "application/x-rubygems": {
	        icon: "icon icon-gems"
	    },
	    "text/x-java-source": {
	        icon: "icon icon-java"
	    },
	    "x-groovy-source": {
	        icon: "icon icon-groovy"
	    },
	    "text/x-c": {
	        icon: "icon icon-c"
	    },
	    "text/x-csharp": {
	        icon: "icon icon-c-2"
	    },
	    "application/zip": {
	        icon: "icon icon-zip"
	    },
	    "application/x-gzip": {
	        icon: "icon icon-gz"
	    },
	    "application/x-gtar": {
	        icon: "icon icon-gz"
	    },
	    "application/x-tar": {
	        icon: "icon icon-tar"
	    },
	    "application/x-nupkg": {
	        icon: "icon icon-nuget"
	    },
	    "application/x-rpm": {
	        icon: "icon icon-rpm"
	    },
	    "text/x-scala-source": {
	        icon: "icon icon-scala"
	    },
	    "application/java-archive": {
	        icon: "icon icon-jar"
	    },
	    "application/octet-stream": {
	        icon: "icon icon-general"
	    },
	    docker: {
	        icon: "icon icon-docker"
	    },
	    bower: {
	        icon: "icon icon-bower"
	    },
	    npm: {
	        icon: "icon icon-npm"
	    },
	    cocoapods: {
	        icon: "icon icon-cocoapods"
	    },
	    gitlfs: {
	        icon: "icon icon-git-lfs"
	    },
	    opkg: {
	        icon: "icon icon-opkg"
	    },
	    composer: {
	        icon: "icon icon-composer"
	    },
	    conan: {
	        icon: "icon icon-conan"
	    },
	    puppet: {
	        icon: "icon icon-puppet"
	    },
	    pypi: {
	        icon: "icon icon-pypi"
	    },
	    gradle: {
	        icon: "icon icon-gradle"
	    },
	    vagrant: {
	        icon: "icon icon-vagrant"
	    },
	    helm: {
	        icon: "icon icon-helm"
	    },
	    chef: {
	        icon: "icon icon-chef"
	    },
	    go: {
	        icon: "icon icon-golang"
	    },
	    cran: {
	        icon: "icon icon-cran"
	    },
	    conda: {
	        icon: "icon icon-conda"
	    },
	    supportBundleRepository: {
	        icon: "icon icon-support"
	    }
	};

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var FIELD_OPTIONS = _interopRequire(__webpack_require__(135));
	
	var BrowsersController = exports.BrowsersController = (function () {
	    function BrowsersController($timeout, $scope, $stateParams, $state, TreeBrowserDao, JFrogEventBus, hotkeys, ArtifactoryState, ArtifactoryStorage, ArtifactoryFeatures, FooterDao) {
	        var _this = this;
	
	        _classCallCheck(this, BrowsersController);
	
	        this.JFrogEventBus = JFrogEventBus;
	        this.stateParams = $stateParams;
	        this.state = $state;
	        this.treeBrowserDao = TreeBrowserDao;
	        this.artifactoryState = ArtifactoryState;
	        this.ArtifactoryStorage = ArtifactoryStorage;
	        this.features = ArtifactoryFeatures;
	        this.compactFolders = TreeBrowserDao.getCompactFolders();
	        this.$scope = $scope;
	        this.EVENTS = EVENTS;
	        this.$timeout = $timeout;
	        this.hotkeys = hotkeys;
	        this.activeSortingMenu = false;
	        this._setupKeyHints();
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TREE_NODE_SELECT, function (node) {
	            return _this.selectedNode = node;
	        });
	
	        var activeFilter = this.artifactoryState.getState("activeFilter");
	        this.activeFilter = activeFilter ? true : false;
	        this.searchText = activeFilter || "";
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TREE_SEARCH_RUNNING, function (running) {
	            _this.searchInAction = running;
	        });
	
	        this.sortMethod = localStorage.treeSortingMethod || "repo_type"; // sort from local storage or default if not exist
	
	        var savedFilter = localStorage.treeFiltering ? JSON.parse(localStorage.treeFiltering) : {};
	        var savedPkgFilter = savedFilter.pkg || [];
	        var savedRepoFilter = savedFilter.repo || [];
	
	        this.selectionRepoPkgList = _.map(FIELD_OPTIONS.repoPackageTypes, function (repo) {
	            return {
	                text: repo.text,
	                serverEnumName: repo.serverEnumName,
	                iconClass: "icon-" + repo.icon,
	                isSelected: savedPkgFilter.indexOf(repo.serverEnumName) !== -1
	            };
	        });
	
	        // Filter only Aritfactory Community Edition for C/C++ supported packages
	        if (this.features.isConanCE()) {
	            this.selectionRepoPkgList = _.filter(this.selectionRepoPkgList, function (pkg) {
	                return pkg.serverEnumName === "Conan" || pkg.serverEnumName === "Generic";
	            });
	        }
	        // Filter only JCR supported packages
	        else if (this.features.isJCR()) {
	            this.selectionRepoPkgList = _.filter(this.selectionRepoPkgList, function (pkg) {
	                return pkg.serverEnumName === "Docker" || pkg.serverEnumName === "Helm" || pkg.serverEnumName === "Generic";
	            });
	        }
	
	        // Filter only Aritfactory OSS supported packages
	        else if (this.features.isOss()) {
	            this.selectionRepoPkgList = _.filter(this.selectionRepoPkgList, function (pkg) {
	                return _.includes(["Maven", "Gradle", "Ivy", "SBT", "Generic", "BuildInfo"], pkg.serverEnumName);
	            });
	        }
	
	        //this.selectionTypeList = _.values(FIELD_OPTIONS.REPO_TYPE).toObject();
	
	        this.selectionRepoTypeList = _.map(_.extend({}, FIELD_OPTIONS.REPO_TYPE, { CACHE: "cache" }), function (value) {
	            var repoType = value.charAt(0).toUpperCase() + value.slice(1);
	            return {
	                text: repoType,
	                iconClass: "icon-" + value,
	                isSelected: savedRepoFilter.indexOf(repoType) !== -1
	            };
	        });
	
	        if (this.features.isConanCE()) {
	            this.selectionRepoTypeList = _.filter(this.selectionRepoTypeList, function (type) {
	                return type.text != "Remote";
	            });
	        }
	
	        if (this.features.isEdgeNode()) {
	            this.selectionRepoTypeList = _.filter(this.selectionRepoTypeList, function (type) {
	                return type.text != "Distribution" && type.text != "Remote";
	            });
	        }
	
	        this.sendWindowResizeEvent();
	
	        var footerData = FooterDao.getInfo();
	        if (footerData.treebrowserFolderCompact) this.allowCompactFolders = true;
	    }
	
	    _createClass(BrowsersController, {
	        dropDownOpened: {
	            get: function () {
	                return !!(this.repoDropDownOpened || this.packageDropDownOpened);
	            }
	        },
	        toggleCompactFolders: {
	            value: function toggleCompactFolders() {
	                this.treeBrowserDao.setCompactFolders(this.compactFolders);
	                this.JFrogEventBus.dispatch(EVENTS.TREE_COMPACT, this.compactFolders);
	            }
	        },
	        toggleSortAndFilterMenu: {
	            value: function toggleSortAndFilterMenu() {
	                if (!this.dropDownOpened) {
	                    this.activeSortingMenu = !this.activeSortingMenu;
	                }
	            }
	        },
	        changeSortingMethod: {
	            value: function changeSortingMethod() {
	                localStorage.setItem("treeSortingMethod", this.sortMethod);
	                this.JFrogEventBus.dispatch(EVENTS.TREE_REFRESH_SORTING);
	            }
	        },
	        changeFilter: {
	            value: function changeFilter() {
	                var filter = {
	                    pkg: _.map(_.filter(this.selectionRepoPkgList, { isSelected: true }), "serverEnumName"),
	                    repo: _.map(_.filter(this.selectionRepoTypeList, { isSelected: true }), "text")
	                };
	
	                if (!filter.pkg.length && !filter.repo.length) {
	                    localStorage.removeItem("treeFiltering");
	                } else {
	                    localStorage.setItem("treeFiltering", JSON.stringify(filter));
	                }
	
	                this.JFrogEventBus.dispatch(EVENTS.TREE_REFRESH_FILTER);
	            }
	        },
	        filterFavorites: {
	            value: function filterFavorites() {
	                if (localStorage.filterFavorites) {
	                    localStorage.removeItem("filterFavorites");
	                } else {
	                    localStorage.setItem("filterFavorites", true);
	                }
	                this.JFrogEventBus.dispatch(EVENTS.TREE_REFRESH_FILTER);
	            }
	        },
	        isFiltersOn: {
	            value: function isFiltersOn() {
	                return localStorage.treeFiltering ? true : false;
	            }
	        },
	        isFavoritesOn: {
	            value: function isFavoritesOn() {
	                return localStorage.filterFavorites ? true : false;
	            }
	        },
	        isFavoritesEnabled: {
	            value: function isFavoritesEnabled() {
	                var favRepos = this.ArtifactoryStorage.getItem("favoritesRepos");
	                return !!(favRepos && favRepos.favoritesRepos && favRepos.favoritesRepos.length || localStorage.filterFavorites);
	            }
	        },
	        resetFilters: {
	            value: function resetFilters() {
	                _.filter(this.selectionRepoTypeList, { isSelected: true }).forEach(function (i) {
	                    return i.isSelected = false;
	                });
	                _.filter(this.selectionRepoPkgList, { isSelected: true }).forEach(function (i) {
	                    return i.isSelected = false;
	                });
	                localStorage.removeItem("treeFiltering");
	                this.JFrogEventBus.dispatch(EVENTS.TREE_REFRESH_SORTING);
	            }
	        },
	        resetAllFilters: {
	            value: function resetAllFilters() {
	                localStorage.removeItem("filterFavorites");
	                this.resetFilters();
	                this.filterHasNoMatches = false;
	            }
	        },
	        showTreeSearch: {
	            value: function showTreeSearch() {
	                this.JFrogEventBus.dispatch(EVENTS.ACTIVATE_TREE_SEARCH);
	            }
	        },
	        switchBrowser: {
	            value: function switchBrowser(browser) {
	                this.artifactoryState.setState("activeFilter", this.activeFilter ? this.searchText : undefined);
	
	                // Reclicking simple browser when we are already in simple browser - go to root
	                if (browser === "simple" && this.state.params.browser === "simple") {} else if (browser === "tree" && this.state.params.browser === "tree") {} else if (browser != this.state.params.browser) {
	                    //            this.state.transitionTo(this.state.current.name, _.extend({}, this.state.params, {browser: browser}), {reload: true, notify: false});
	                    this.state.go(this.state.current, _.extend({}, this.state.params, { browser: browser }), { notify: false, reload: this.state.current });
	                    //            this.treeBrowserDao.invalidateRoots();
	                    // console.log(" from "+this.stateParams.browser+" to "+browser);
	                }
	            }
	        },
	        _setupKeyHints: {
	            value: function _setupKeyHints() {
	                this.hotkeys.bindTo(this.$scope).add({
	                    combo: "Enter",
	                    description: "Select node"
	                }).add({
	                    combo: "Esc",
	                    description: "Cancel search / deselect node"
	                }).add({
	                    combo: "Down",
	                    description: "Navigate down in tree / in search results"
	                }).add({
	                    combo: "Up",
	                    description: "Navigate up in tree / in search results"
	                }).add({
	                    combo: "Right",
	                    description: "Expand folder"
	                }).add({
	                    combo: "Left",
	                    description: "Collapse folder"
	                });
	            }
	        },
	        clearFilter: {
	            value: function clearFilter() {
	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CANCEL);
	            }
	        },
	        editFilter: {
	            value: function editFilter() {
	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_EDIT);
	            }
	        },
	        sendWindowResizeEvent: {
	            value: function sendWindowResizeEvent() {
	                var _this = this;
	
	                var resizeEvent = document.createEvent("Event");
	                resizeEvent.initEvent("resize", false, true);
	                var doSafeResize = function () {
	                    try {
	                        window.dispatchEvent(new Event("resize"));
	                    } catch (e) {
	                        window.dispatchEvent(resizeEvent);
	                    }
	                };
	
	                this.$timeout(function () {
	                    _this.$timeout(function () {
	                        doSafeResize();
	                    });
	                });
	            }
	        }
	    });
	
	    return BrowsersController;
	})();

	/*
	            let repo = this.selectedNode.data.getRoot();
	            // Make sure roots are visible:
	            this.artifactoryState.setState('tree_touched', false);
	            // Use forceLoad as a Date to ensure state transition even if it's the same as before
	            this.state.go(this.state.current.name, {browser: browser, artifact: repo.fullpath, forceLoad: new Date()});
	*/

	//            this.JFrogEventBus.dispatch(EVENTS.TREE_COLLAPSE_ALL);

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfTreeSearch = jfTreeSearch;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var KEYS = _interopRequire(__webpack_require__(295));
	
	function jfTreeSearch() {
	    return {
	        restrict: "E",
	        controller: TreeSearchController,
	        controllerAs: "TreeSearch",
	        templateUrl: "states/artifacts/jf_tree_search/jf_tree_search.html",
	        replace: true,
	        bindToController: true
	    };
	}
	
	var TreeSearchController = (function () {
	    function TreeSearchController(JFrogEventBus, $element, hotkeys, $scope, $timeout) {
	        var _this = this;
	
	        _classCallCheck(this, TreeSearchController);
	
	        this.$scope = $scope;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$element = $element;
	        this.$timeout = $timeout;
	        this.term = "";
	        this.showSearch = false;
	        this.hotkeys = hotkeys;
	        this._setupHotkeys();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.ACTIVATE_TREE_SEARCH, function (key) {
	            $timeout(function () {
	                _this._activateSearch(key);
	            });
	        });
	    }
	
	    _createClass(TreeSearchController, {
	        onChange: {
	            value: function onChange() {
	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CHANGE, this.term);
	            }
	        },
	        onKeydown: {
	            value: function onKeydown($event) {
	                // Send events to tree on key down / up / enter
	                if (_.includes([KEYS.ENTER, KEYS.DOWN_ARROW, KEYS.UP_ARROW, KEYS.ESC], $event.keyCode)) {
	                    $event.preventDefault();
	                    // Deactivate on enter press
	                    if (_.includes([KEYS.ENTER, KEYS.ESC], $event.keyCode)) {
	                        this._deactivateSearch();
	                    }
	                }
	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_KEYDOWN, $event);
	            }
	        },
	        _deactivateSearch: {
	            value: function _deactivateSearch() {
	                this.term = "";
	                this.showSearch = false;
	                this.$searchInput().blur();
	                $("body").off("click.outsideTreeSearch");
	            }
	        },
	        _activateSearch: {
	            value: function _activateSearch(key) {
	                var _this = this;
	
	                this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CANCEL);
	                this.showSearch = true;
	                this.$timeout(function () {
	                    if (!_this.term) {
	                        //fix for firefox not showing the first key
	                        _this.term = key;
	                        _this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CHANGE, _this.term);
	                    }
	                });
	                this.$searchInput().focus();
	                $("body").on("click.outsideTreeSearch", function (e) {
	                    if (!$(_this.$element).has(e.target).length) {
	                        _this.JFrogEventBus.dispatch(EVENTS.TREE_SEARCH_CANCEL);
	                        _this._deactivateSearch();
	                        if (!_this.$scope.$$phase) _this.$scope.$digest();
	                    }
	                });
	            }
	        },
	        $searchInput: {
	            value: function $searchInput() {
	                return this.$element.find("input")[0];
	            }
	        },
	        _setupHotkeys: {
	            value: function _setupHotkeys() {
	                var _this = this;
	
	                this.hotkeys.bindTo(this.$scope).add({
	                    combo: KEYS.HOTKEYS.ALPHANUMERIC.split(""),
	                    description: "Any alphanumeric key to search the tree",
	                    callback: function (event, hotkey) {
	                        if (_.includes(event.target.classList, "jstree-anchor")) {
	                            //                    var key = hotkey.format()[0];
	                            var key = String.fromCharCode(event.which);
	                            _this._activateSearch(key);
	                        }
	                    }
	                });
	            }
	        }
	    });
	
	    return TreeSearchController;
	})();

/***/ }),
/* 295 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	    ENTER: 13,
	    ESC: 27,
	    SPACE: 32,
	    UP_ARROW: 38,
	    DOWN_ARROW: 40,
	    HOTKEYS: {
	        ALPHANUMERIC: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-_"
	    },
	    PROPERTY_TYPE: {
	        MULTI_SELECT: null,
	        SINGLE_SELECT: 1,
	        ANY_VALUE: 0
	    }
	};

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfTreeBrowser = jfTreeBrowser;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var JFCommonBrowser = _interopRequire(__webpack_require__(297));
	
	var types = _interopRequire(__webpack_require__(292));
	
	var ArtifactoryFeatures = __webpack_require__(165).ArtifactoryFeatures;
	
	function jfTreeBrowser() {
	    return {
	        scope: {
	            browserController: "=",
	            simpleMode: "=?"
	        },
	        restrict: "E",
	        controller: JFTreeBrowserController,
	        controllerAs: "jfTreeBrowser",
	        templateUrl: "states/artifacts/jf_tree_browser/jf_tree_browser.html",
	        bindToController: true
	    };
	}
	
	var LOAD_MORE_TOKEN = "$$$LOAD_MORE";
	
	var JFTreeBrowserController = (function (_JFCommonBrowser) {
	    function JFTreeBrowserController($state, $timeout, JFrogEventBus, $scope, TreeBrowserDao, $stateParams, $q, ArtifactoryState, ArtifactActions, JFrogNotifications, NativeBrowser, User, JFrogUIUtils, JFTreeApi, TreeNode, ArtifactoryFeatures) {
	        _classCallCheck(this, JFTreeBrowserController);
	
	        _get(Object.getPrototypeOf(JFTreeBrowserController.prototype), "constructor", this).call(this, JFTreeApi, $scope, ArtifactActions, ArtifactoryState, JFrogUIUtils, ArtifactoryFeatures);
	
	        this.$state = $state;
	        this.$scope = $scope;
	        this.TreeNode = TreeNode;
	        this.$timeout = $timeout;
	        this.$stateParams = $stateParams;
	        this.$q = $q;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.JFrogUIUtils = JFrogUIUtils;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        this.treeBrowserDao = TreeBrowserDao;
	        this.artifactoryState = ArtifactoryState;
	        this.user = User.currentUser;
	        this.nativeBrowser = NativeBrowser;
	        this.types = types;
	        this.artifactoryFeatures = ArtifactoryFeatures;
	    }
	
	    _inherits(JFTreeBrowserController, _JFCommonBrowser);
	
	    _createClass(JFTreeBrowserController, {
	        $onInit: {
	            value: function $onInit() {
	
	                this._registerEvents();
	
	                this._setUpTree();
	
	                this._watchModeChange();
	            }
	        },
	        _setUpTree: {
	            value: function _setUpTree() {
	                var _this = this;
	
	                var driver = {
	                    uniqueId: function (node) {
	                        if (!node.data) console.log(node);
	                        return node.data.fullpath;
	                    },
	                    nodeById: this.nodeByPathGetter.bind(this),
	                    text: function (node) {
	                        return node.text;
	                    },
	                    childrenChecker: this.childrenChecker.bind(this),
	                    children: this.childrenGetter.bind(this),
	                    parent: this.parentGetter.bind(this),
	                    classes: function (node) {
	                        var classes = [];
	                        if (node.data.isTrashcan()) classes.push("trashcan");else if (node.data.isInTrashcan()) classes.push("in-trashcan");
	                        if (node.data.isFavorite()) classes.push("favorite");
	
	                        if (node.type === LOAD_MORE_TOKEN) classes.push("load-more");
	
	                        return classes;
	                    },
	                    pane: function (node) {
	                        if (!_this.simpleMode && _this.user.isAdmin() && _this.isTrashPinned() && node.data.isTrashcan()) return "trash";else return "default";
	                    },
	                    contextMenuItems: this._getContextMenuItems.bind(this)
	                };
	
	                this.treeApi.setNodeTemplate(function (node) {
	                    return _this.getNodeTemplate(node);
	                })
	                //                .setFilterCallback(node => this.filterCallback(node))
	                .setDataDriver(driver).on("item.selected", function (node) {
	                    if (node.type === LOAD_MORE_TOKEN) {
	                        (function () {
	                            var parentNode = _this.treeApi.getParentNode(node);
	                            node.loading = true;
	                            _this.childrenGetter(parentNode, node.data.continueState).then(function (response) {
	                                _this.treeApi.replaceNode(node, response);
	                                if (response.length) _this.treeApi.selectNode(response[0]);else _this.treeApi.selectNode(parentNode.$childrenCache[parentNode.$childrenCache.length - 1]);
	                                node.loading = false;
	                            });
	                        })();
	                    } else {
	                        node.data.load().then(function () {
	                            _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_NODE_SELECT, node);
	                        });
	                    }
	                }).on("keydown", function (e) {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.ACTIVATE_TREE_SEARCH, e.key);
	                }).on("ready", function () {
	                    return _this.onTreeReady();
	                }).on("bottom-reached", function () {
	                    if (_this.continueState && !_this.continueState.$$$noMore && !(_this.type === "simple" && !!_this.treeApi.getCurrentParent())) {
	                        _this.childrenGetter(null, _this.continueState).then(function (response) {
	                            var _treeApi$$rootCache;
	
	                            (_treeApi$$rootCache = _this.treeApi.$rootCache).splice.apply(_treeApi$$rootCache, [_this.treeApi.$rootCache.length, 0].concat(_toConsumableArray(response)));
	                            _this.mainViewPane._addChildren(response, 0, null, true);
	                        });
	                    }
	                });
	
	                this.mainViewPane = this.treeApi.createViewPane().setItemHeight("30px").setItemsPerPage("auto");
	
	                this.trashViewPane = this.treeApi.createViewPane("trash").setItemHeight("30px").setItemsPerPage(5);
	
	                this.treeApi.freeze();
	            }
	        },
	        _watchModeChange: {
	            value: function _watchModeChange() {
	                var _this = this;
	
	                var firstTimeSwitch = true;
	                this.$scope.$watch("jfTreeBrowser.simpleMode", function (simpleMode) {
	                    _this.type = simpleMode ? "simple" : "tree";
	                    _this.treeApi.freeze();
	                    _this.treeApi.refreshPaneSelection();
	                    _this.treeApi.refreshFilter();
	                    _this.treeApi.setDrillDownMode(simpleMode).then(function () {
	                        if (!firstTimeSwitch) _this.treeApi.unFreeze();
	                        firstTimeSwitch = false;
	                    });
	                });
	            }
	        },
	        getNodeTemplate: {
	            value: function getNodeTemplate(node) {
	                return "<div>\n                    <i class=\"tree-node-icon " + (this.types[node.type] ? this.types[node.type].icon : this.types["default"].icon) + "\"></i>\n                    <span class=\"node-text\" style=\"margin-left: 5px\">" + node.text + "</span> <span ng-if=\"node.type === '" + LOAD_MORE_TOKEN + "' && node.loading\"><div style=\"display: inline-block\"><div style=\"position: absolute; top: 4px\" class=\"icon-hourglass-local\"></div></div></span>\n                </div>";
	            }
	        },
	        onTreeReady: {
	            value: function onTreeReady() {
	                var _this = this;
	
	                this._checkIfFilterHasNoMatches();
	
	                if (!this.$state.params.artifact) {
	                    this.treeApi.unFreeze();
	                    this.treeApi.selectFirst();
	                } else {
	                    this.spinnerTimeout = this.$timeout(function () {
	                        if (_this.$state.current.name === "artifacts.browsers.path") {
	                            _this.JFrogEventBus.dispatch(_this.EVENTS.SHOW_SPINNER);
	                        }
	                    }, 600);
	                    this.treeBrowserDao.findNodeByFullPath(this.$state.params.artifact).then(function (node) {
	                        if (node === _this.treeBrowserDao) {
	                            _this.$timeout.cancel(_this.spinnerTimeout);
	                            _this.JFrogEventBus.dispatch(_this.EVENTS.HIDE_SPINNER);
	                            _this.treeApi.unFreeze();
	                            _this.treeApi.selectFirst();
	                        } else {
	                            (function () {
	                                node = _this._transformData([node])[0];
	                                var repo = _this.treeApi.findNodeByUniqueId(node.data.repoKey);
	                                var openDeepNode = function () {
	                                    _this.treeApi.openDeepNode(node).then(function () {
	                                        _this.treeApi.centerOnSelected();
	                                        _this.treeApi.unFreeze();
	                                        _this.$timeout.cancel(_this.spinnerTimeout);
	                                        _this.JFrogEventBus.dispatch(_this.EVENTS.HIDE_SPINNER);
	                                    });
	                                };
	                                if (!_this.treeApi.isNodeFiltered(repo)) {
	                                    _this.afterNextFilterRefresh = function () {
	                                        return openDeepNode();
	                                    };
	                                    _this.browserController.resetAllFilters();
	                                } else openDeepNode();
	                            })();
	                        }
	                    });
	                }
	                this.mainViewPane.focus();
	            }
	        },
	        childrenGetter: {
	            value: function childrenGetter(parent, continueState) {
	                var _this = this;
	
	                var defer = this.$q.defer();
	                if (!parent) {
	                    (function () {
	                        var filter = JSON.parse(localStorage.getItem("treeFiltering") || "{}");
	                        var sorting = localStorage.treeSortingMethod || "repo_type";
	
	                        filter = {
	                            packageTypes: filter.pkg || [],
	                            repositoryTypes: (filter.repo || []).map(function (v) {
	                                return v === "Cache" ? "CACHED" : v.toUpperCase();
	                            })
	                        };
	
	                        sorting = sorting.toUpperCase();
	                        if (sorting === "PKG_TYPE") sorting = "PACKAGE_TYPE";
	
	                        var favourites = JSON.parse(localStorage.favoritesRepos || "{}").favoritesRepos;
	                        if (localStorage.filterFavorites !== "true" || favourites && !favourites.length) favourites = undefined;
	
	                        var mustInclude = !continueState && _this.$state.params.artifact ? _this.$state.params.artifact.split("/")[0] : null;
	                        _this.treeBrowserDao.getRoots(true, continueState, filter, { sortBy: sorting }, mustInclude, favourites).then(function (roots) {
	                            _this.continueState = roots.continueState || { $$$noMore: true };
	                            roots = roots.data;
	                            if (_this.artifactoryFeatures.isAol() || _this.artifactoryFeatures.isOss()) {
	                                _.remove(roots, function (root) {
	                                    return root.repoType === "supportBundles";
	                                });
	                            }
	                            var hasArtifactsData = !!continueState || roots.length > 0;
	                            _this.browserController.filterHasNoMatches = false;
	                            if (!hasArtifactsData && (filter.packageTypes.length || filter.repositoryTypes.length)) {
	                                _this.treeBrowserDao.getRoots(true, continueState, {}, { sortBy: sorting, limit: 1 }, mustInclude, favourites).then(function (roots) {
	                                    hasArtifactsData = roots.data.length > 0;
	                                    _this.artifactoryState.setState("hasArtifactsData", hasArtifactsData);
	                                    _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_DATA_IS_SET, hasArtifactsData);
	                                    if (hasArtifactsData) {
	                                        _this.browserController.filterHasNoMatches = true;
	                                    }
	                                });
	                            } else {
	                                _this.artifactoryState.setState("hasArtifactsData", hasArtifactsData);
	                                _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_DATA_IS_SET, hasArtifactsData);
	                            }
	
	                            defer.resolve(_this._transformData(roots));
	                        })["catch"](function () {
	                            return defer.resolve([]);
	                        });
	                    })();
	                } else {
	                    parent.data.getChildren(!!continueState, continueState).then(function (children) {
	                        var transformed = _this._transformData(children.data || children);
	                        if (children.continueState) {
	                            transformed.push({
	                                text: "Load More...",
	                                data: new _this.TreeNode({ text: "Load More...", continueState: children.continueState }),
	                                type: LOAD_MORE_TOKEN
	                            });
	                        }
	                        defer.resolve(transformed);
	                    })["catch"](function () {
	                        return defer.resolve([]);
	                    });
	                }
	                return defer.promise;
	            }
	        },
	        childrenChecker: {
	            value: function childrenChecker(parent) {
	                return parent.children;
	            }
	        },
	        parentGetter: {
	            value: function parentGetter(node) {
	                return node.data.parent ? this._transformData([node.data.parent])[0] : undefined;
	            }
	        },
	        nodeByPathGetter: {
	            value: function nodeByPathGetter(path) {
	                var _this = this;
	
	                var defer = this.$q.defer();
	                this.treeBrowserDao.findNodeByFullPath(path).then(function (node) {
	                    if (node !== _this.treeBrowserDao) {
	                        defer.resolve(_this._transformData([node])[0]);
	                    } else defer.reject();
	                });
	
	                return defer.promise;
	            }
	        },
	        _transformData: {
	            value: function _transformData(data) {
	                var _this = this;
	
	                data = data || [];
	                return data.map(function (node) {
	                    var item = {};
	                    item.children = node.hasChild;
	                    item.text = node.isTrashcan() ? "<span class=\"trashcan-node\">Trash Can</span>" : _this.JFrogUIUtils.getSafeHtml(node.text);
	                    item.data = node;
	                    item.type = node.iconType;
	                    if (node.isTrashcan()) item.li_attr = { "class": "-the-trashcan" };
	                    var type = typeof node.fileType != "undefined" ? node.fileType : node.type;
	                    // replace the node icon type to the package type if necessary
	                    if (_this._iconsShouldBeReplacedWithRepoPkgTypeIcon(type, node.repoPkgType, node.fullpath)) {
	                        item.type = node.iconType = node.repoPkgType.toLocaleLowerCase();
	                    }
	
	                    return item;
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, [this.EVENTS.ACTION_WATCH, this.EVENTS.ACTION_UNWATCH], function (node) {
	                    return _this._refreshContextMenu(node);
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_FAVORITES, function () {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_REFRESH_FAVORITES);
	                });
	
	                this.treeApi.registerEventOnNode(this.EVENTS.TREE_REFRESH_FAVORITES, function (node, params) {
	                    if (node.data) node.data.updateFavoriteState();
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CHANGE, function (text) {
	                    return _this._searchTree(text);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CANCEL, function (text) {
	                    return _this._clear_search();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_KEYDOWN, function (e) {
	                    _this.treeApi.handleKeyEvent(e);
	                    _this._searchTreeKeyDown(e.keyCode);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DEPLOY, function (eventArgs) {
	                    _this._refreshAfterDeploy(eventArgs);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_REFRESH, function (node) {
	                    return _this._refreshFolder(node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_NODE_CM_REFRESH, function (node) {
	                    return _this._refreshContextMenu(node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_REFRESH, function (node) {
	                    return node ? _this._refreshFolder(node) : _this._refreshTree();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DELETE, function (node) {
	                    if (_this.simpleMode) {
	                        _this._refreshParentFolder(node).then(function () {
	                            var parentNode = node.data.parent ? _this.treeApi.findNodeByUniqueId(node.data.parent.fullpath) : null;
	                            if (parentNode && !parentNode.$childrenCache.length) {
	                                _this.treeApi.selectNode(parentNode);
	                                _this.treeApi.drillUp();
	                            }
	                        });
	                    } else {
	                        _this._refreshParentFolder(node).then(function () {
	                            var selected = _this.treeApi.getSelectedNode();
	                            if (selected === node) {
	                                var _parent = _this.treeApi.findNodeByUniqueId(node.data.parent.fullpath);
	                                _this.treeApi.selectNode(_parent);
	                            } else {
	                                var updated = _this.treeApi.findNodeByUniqueId(selected.data.fullpath);
	                                _this.treeApi.selectNode(updated);
	                            }
	                        });
	                        if (!node.data || !node.data.isInTrashcan || !node.data.isTrashcan || !node.data.isInTrashcan() && !node.data.isTrashcan()) {
	                            _this.refreshTrashCan();
	                        }
	                    }
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DELETE_CONTENT, function (node) {
	                    node.data.invalidateParent();
	                    _this._refreshFolder(node);
	                    _this.refreshTrashCan();
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_MOVE, function (options) {
	                    if (!_this.simpleMode) {
	                        _this._refreshParentFolder(options.node).then(function () {
	                            _this._refreshFolderPath(options);
	                        });
	                    } else {
	                        _this._refreshFolderPath(options);
	                    }
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_COPY, function (options) {
	                    _this._refreshFolderPath(options);
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_NODE_OPEN, function (path) {
	                    _this._openTreeNode(path);
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_COLLAPSE_ALL, function () {
	                    _this._collapseAll();
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_COMPACT, function () {
	                    _this._toggleCompactFolders();
	                });
	
	                // URL changed (like back button / forward button / someone input a URL)
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TABS_URL_CHANGED, function (stateParams) {
	                    // Check if it's already the current selected node (to prevent opening the same tree node twice)
	                    var selectedNode = _this.treeApi.getSelectedNode();
	                    selectedNode = selectedNode ? selectedNode.data : null;
	                    if (selectedNode && selectedNode.fullpath === stateParams.artifact) return;
	                    _this.treeBrowserDao.findNodeByFullPath(stateParams.artifact).then(function (node) {
	                        if (node && node !== _this.treeBrowserDao) {
	                            node = _this._transformData([node])[0];
	                            _this.treeApi.openDeepNode(node);
	                        }
	                    });
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.REFRESH_PAGE_CONTENT, function () {
	                    _this._refreshTree();
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_REFRESH_SORTING, function () {
	                    return _this._refreshTreeSorting();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_REFRESH_FILTER, function () {
	                    return _this._refreshTreeSorting();
	                });
	            }
	        },
	        _refreshAfterDeploy: {
	            value: function _refreshAfterDeploy(eventArgs) {
	                var _this = this;
	
	                if (this.refreshingAfterDeploy) {
	                    this.$timeout(function () {
	                        return _this._refreshAfterDeploy(eventArgs);
	                    }, 100);
	                    return;
	                }
	                var repoKey = eventArgs[0];
	                var repoNode = this.treeApi.findNodeByUniqueId(repoKey);
	                this.refreshingAfterDeploy = true;
	                this._refreshFolder(repoNode).then(function () {
	                    _this.refreshingAfterDeploy = false;
	                    _this.treeApi.openNode(repoNode);
	                });
	            }
	        },
	        _toggleCompactFolders: {
	            value: function _toggleCompactFolders() {
	                var _this = this;
	
	                this.treeBrowserDao.invalidateRoots();
	
	                this.spinnerTimeout = this.$timeout(function () {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.SHOW_SPINNER);
	                }, 600);
	
	                this.treeApi.refreshTree(true, false).then(function () {
	                    _this.$timeout.cancel(_this.spinnerTimeout);
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.HIDE_SPINNER);
	                });
	            }
	        },
	        _refreshTreeSorting: {
	            value: function _refreshTreeSorting() {
	                /*
	                        this.treeApi.freeze();
	                        this.treeApi.refreshFilter();
	                */
	                this.treeApi.refreshTree(true, false).then(function () {});
	            }
	        },
	        _checkIfFilterHasNoMatches: {
	            value: function _checkIfFilterHasNoMatches() {
	                var _this = this;
	
	                var defer = this.$q.defer();
	
	                if (this.mainViewPane.getFilteredNodesCount() === 0 && this.mainViewPane.getNodesCount() !== 0) {
	                    if (this.simpleMode && this.treeApi.getCurrentParent()) {
	                        this.treeApi.drillUpToRoot();
	                        this.$timeout(function () {
	                            _this._checkIfFilterHasNoMatches().then(function () {
	                                defer.resolve();
	                            });
	                        });
	                    } else {
	                        this.browserController.filterHasNoMatches = true;
	                        defer.resolve();
	                    }
	                } else {
	                    this.browserController.filterHasNoMatches = false;
	                    defer.resolve();
	                }
	
	                return defer.promise;
	            }
	        },
	        toggleTrashPin: {
	            value: function toggleTrashPin(e) {
	                e.stopImmediatePropagation();
	                e.preventDefault();
	
	                if (this.isTrashPinned()) {
	                    this.unpinTrash();
	                } else {
	                    this.pinTrash();
	                }
	            }
	        },
	        pinTrash: {
	            value: function pinTrash() {
	                localStorage.pinnedTrash = true;
	                this.treeApi.refreshPaneSelection();
	                this._checkIfFilterHasNoMatches();
	            }
	        },
	        unpinTrash: {
	            value: function unpinTrash() {
	                var _this = this;
	
	                localStorage.pinnedTrash = false;
	                this.treeApi.refreshPaneSelection();
	                var trashCanNode = this.treeApi.findNode(function (n) {
	                    return n.data.isTrashcan();
	                });
	                this.$timeout(function () {
	                    return _this.treeApi.bringNodeToView(trashCanNode);
	                });
	                this._checkIfFilterHasNoMatches();
	            }
	        },
	        isTrashPinned: {
	            value: function isTrashPinned() {
	                // RTFACT-20115
	                return true;
	            }
	        },
	        _refreshFolder: {
	            value: function _refreshFolder(node) {
	                if (node.data) {
	                    node.data.invalidateChildren();
	                    if (node.data.isRepo()) {
	                        this.treeBrowserDao.invalidateRoots();
	                    }
	                } else this.treeBrowserDao.invalidateRoots();
	                return this.treeApi.refreshNode(node);
	            }
	        },
	        _refreshTree: {
	            value: function _refreshTree(node) {
	                this.treeBrowserDao.invalidateRoots();
	                return this.treeApi.refreshTree();
	            }
	        },
	        _refreshContextMenu: {
	            value: function _refreshContextMenu(node) {
	                this.treeApi.refreshNodeContextMenu(node);
	            }
	        },
	        _refreshParentFolder: {
	            value: function _refreshParentFolder(node) {
	                node.data.invalidateParent();
	                var parentNode = this.treeApi.getParentNode(node);
	                if (parentNode) {
	                    return this._refreshFolder(parentNode);
	                } else {
	                    if (node.data && node.data.isRepo()) {
	                        return this._refreshFolder(node);
	                    } else {
	                        return this.$q.when();
	                    }
	                }
	            }
	        },
	        refreshTrashCan: {
	            value: function refreshTrashCan() {
	                var trashNode = this.treeApi.findNode(function (node) {
	                    return node.data.repoType === "trash" && node.data.repoKey === "auto-trashcan";
	                });
	                if (trashNode) this.JFrogEventBus.dispatch(this.EVENTS.TREE_REFRESH, trashNode);
	            }
	        },
	        _refreshFolderPath: {
	            value: function _refreshFolderPath(option) {
	                var _this = this;
	
	                var targetPath = _.compact(option.target.targetPath.split("/"));
	                var path = [option.target.targetRepoKey].concat(targetPath).join("/");
	                this.treeApi.freeze();
	                if (this.simpleMode) this.treeApi.drillUpToRoot();
	                var repo = this.treeApi.findNodeByUniqueId(option.target.targetRepoKey);
	                this._refreshFolder(repo).then(function () {
	                    _this.treeApi.openDeepNodeByUniqueId(path).then(function () {
	                        _this.treeApi.centerOnSelected();
	                        _this.treeApi.unFreeze();
	                    });
	                });
	            }
	        }
	    });
	
	    return JFTreeBrowserController;
	})(JFCommonBrowser);
	
	/*
	            this._checkIfFilterHasNoMatches().then(() => {
	                let selected = this.treeApi.getSelectedNode();
	                if (selected) {
	                    if (!this.treeApi.isNodeFiltered(selected)) {
	                        this.$timeout(() => this.treeApi.selectFirst());
	                    }
	                }
	                else {
	                    this.treeApi.selectFirst();
	                }
	                this.treeApi.centerOnSelected();
	                this.treeApi.unFreeze();
	                if (this.afterNextFilterRefresh) {
	                    this.afterNextFilterRefresh();
	                    delete this.afterNextFilterRefresh;
	                }
	            })
	*/

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var KEYS = _interopRequire(__webpack_require__(295));
	
	var ACTIONS = _interopRequire(__webpack_require__(169));
	
	var REPO_FORM_CONSTANTS = __webpack_require__(212).REPO_FORM_CONSTANTS;
	
	var REGEXP = /(pkg|repo)\:\ *([^;]+)(?:;|$)\ */g;
	
	var JFCommonBrowser = (function () {
	    function JFCommonBrowser(JFTreeApi, $scope, ArtifactActions, ArtifactoryState, JFrogUIUtils) {
	        var _this = this;
	
	        _classCallCheck(this, JFCommonBrowser);
	
	        this.ArtifactoryState = ArtifactoryState;
	        this.artifactActions = ArtifactActions;
	        this.activeFilter = false;
	
	        this.utils = JFrogUIUtils;
	        this.treeApi = new JFTreeApi($scope);
	        this.treeApi.showLines();
	        this.treeApi.on("item.dblClicked", function (node) {
	            _this.treeApi.toggleExpansion(node);
	        });
	
	        if (this.browserController) {
	            this.activeFilter = this.browserController.activeFilter || false;
	            this.searchText = this.browserController.searchText || "";
	            if (this.searchText.endsWith("*")) this.searchText = this.searchText.substr(0, this.searchText.length - 1);
	        }
	
	        if (!localStorage.favoritesRepos) localStorage.setItem("favoritesRepos", "{\"favoritesRepos\" : []}");
	
	        //        this._initTreeSorting();
	
	        this.packageTypesReplacingArchives = ["bower", "npm", "cocoapods", "gitlfs", "opkg", "composer", "pypi", "vagrant", "helm", "chef", "go", "cran", "conda"];
	    }
	
	    _createClass(JFCommonBrowser, {
	        _getContextMenuItems: {
	
	            /****************************
	             * Context menu items
	             ****************************/
	
	            value: function _getContextMenuItems(obj, cb) {
	                var _this = this;
	
	                var actionItems = {};
	                if (obj.data) {
	                    (function () {
	                        var node = obj.data;
	                        node.load().then(function () {
	                            return node.refreshWatchActions();
	                        }).then(function () {
	                            return node.getDownloadPath();
	                        }).then(function () {
	                            if (node.actions) {
	                                node.actions.forEach(function (actionObj) {
	                                    var name = actionObj.name;
	                                    var action = angular.copy(ACTIONS[name]);
	
	                                    if (name == "Favorites" && localStorage.favoritesRepos) {
	                                        var favoritesRepos = JSON.parse(localStorage.favoritesRepos);
	                                        action.icon = _.includes(favoritesRepos.favoritesRepos, node.text) ? "icon-star-full" : "icon-star";
	                                        action.title = _.includes(favoritesRepos.favoritesRepos, node.repoKey) ? "Remove from Favorites" : "Add to Favorites";
	                                    }
	
	                                    if (!action) {
	                                        console.log("Unrecognized action", name);
	                                        return true;
	                                    }
	                                    action._class = "menu-item-" + action.icon;
	                                    action.icon = "action-icon icon " + action.icon;
	                                    action.name = action.title;
	
	                                    if (actionObj.name === "Download") {
	                                        action.link = node.actualDownloadPath;
	                                    } else {
	                                        action.callback = function () {
	                                            _this.artifactActions.perform(actionObj, obj, true);
	                                        };
	                                    }
	                                    if (actionObj.name === "Distribute" && node.repoType === "distribution") {
	                                        action = angular.copy(ACTIONS.Redistribute);
	                                        ;
	                                    }
	                                    actionItems[name] = action;
	                                });
	
	                                cb(actionItems);
	                            } else {
	                                cb([]);
	                            }
	                        });
	                    })();
	                } else {
	                    cb([]);
	                }
	            }
	        },
	        _focusOnTree: {
	            value: function _focusOnTree() {
	                this.treeApi.focus();
	            }
	        },
	        _getScoreObjectFromOrderArray: {
	            value: function _getScoreObjectFromOrderArray(order) {
	                var repoScore = {};
	                var score = 100000;
	
	                order.forEach(function (repoType) {
	                    repoScore[repoType.toLowerCase()] = score;
	                    if (repoType === "REMOTE") {
	                        repoScore.cached = score;
	                        score = score / 10;
	                    }
	                    score = score / 10;
	                });
	                return repoScore;
	            }
	        },
	        _initTreeSorting: {
	            value: function _initTreeSorting() {
	                var _this = this;
	
	                var repoScore = undefined,
	                    repoOrder = undefined;
	                this.treeApi.setSortingFunction(function (a, b) {
	                    if (!repoOrder) {
	                        repoOrder = _this.ArtifactoryState.getState("repoOrder");
	                        repoScore = _this._getScoreObjectFromOrderArray(repoOrder || ["VIRTUAL", "DISTRIBUTION", "LOCAL", "REMOTE"]);
	                    }
	
	                    var aNode = a;
	                    var bNode = b;
	
	                    var aText = aNode.data ? aNode.data.text.toLowerCase() : "*";
	                    var bText = bNode.data ? bNode.data.text.toLowerCase() : "*";
	
	                    var aType = aNode.data ? aNode.data.type : "*";
	                    var bType = bNode.data ? bNode.data.type : "*";
	                    var aRepoType = aNode.data ? aNode.data.repoType : "*";
	                    var bRepoType = bNode.data ? bNode.data.repoType : "*";
	                    var aPkgType = aNode.data ? aNode.data.repoPkgType : "*";
	                    var bPkgType = bNode.data ? bNode.data.repoPkgType : "*";
	
	                    var aScore = 0,
	                        bScore = 0;
	
	                    if (aNode.data && aNode.data.isTrashcan && aNode.data.isTrashcan() && aNode.text !== "..") return 1;else if (bNode.data && bNode.data.isTrashcan && bNode.data.isTrashcan() && bNode.text !== "..") return -1;else if ((aType === "repository" || aType === "virtualRemoteRepository") && (bType === "repository" || bType === "virtualRemoteRepository")) {
	                        //both repos - top level sort
	
	                        if (localStorage.treeSortingMethod === "pkg_type") {
	                            aPkgType = aPkgType === REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES ? REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.BINTRAY : aPkgType;
	                            bPkgType = bPkgType === REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES ? REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.BINTRAY : bPkgType;
	
	                            if (aPkgType < bPkgType) aScore += 1000000;
	                            if (bPkgType < aPkgType) bScore += 1000000;
	                        }
	
	                        if (localStorage.treeSortingMethod === "repo_type" || localStorage.treeSortingMethod === "pkg_type" || !localStorage.treeSortingMethod) {
	                            if (aRepoType === "distribution" || aRepoType === "releaseBundles") aScore += repoScore.distribution;
	                            if (bRepoType === "distribution" || bRepoType === "releaseBundles") bScore += repoScore.distribution;
	
	                            if (aRepoType === "local") aScore += repoScore.local;
	                            if (bRepoType === "local") bScore += repoScore.local;
	
	                            if (aRepoType === "cached") aScore += repoScore.cached;
	                            if (bRepoType === "cached") bScore += repoScore.cached;
	
	                            if (aRepoType === "remote") aScore += repoScore.remote;
	                            if (bRepoType === "remote") bScore += repoScore.remote;
	
	                            if (aRepoType === "virtual") aScore += repoScore.virtual;
	                            if (bRepoType === "virtual") bScore += repoScore.virtual;
	                        }
	
	                        if (aText < bText) aScore++;
	                        if (aText > bText) bScore++;
	
	                        return aScore < bScore ? 1 : -1;
	                    } else if (aType !== "repository" && aType !== "virtualRemoteRepository" && (bType !== "repository" && bType !== "virtualRemoteRepository")) {
	                        //both files or folders
	
	                        if (aType === "folder") aScore += 10000;
	                        if (bType === "folder") bScore += 10000;
	
	                        if (aNode.text === "..") aScore += 100000;
	                        if (bNode.text === "..") aScore += 100000;
	
	                        var aHasNumVal = !_.isNaN(parseInt(aText));
	                        var bHasNumVal = !_.isNaN(parseInt(bText));
	
	                        if (aHasNumVal && bHasNumVal) {
	
	                            var versionCompareResult = _this.utils.compareVersions(aText, bText);
	
	                            if (versionCompareResult === -1) aScore += 100;
	                            if (versionCompareResult === 1) bScore += 100;
	                        } else {
	
	                            var aDigitIndex = aText.search(/\d/);
	                            var bDigitIndex = bText.search(/\d/);
	
	                            if (aDigitIndex === bDigitIndex && aDigitIndex !== -1) {
	                                var aBeforeNum = aText.substr(0, aDigitIndex);
	                                var bBeforeNum = bText.substr(0, bDigitIndex);
	                                if (aBeforeNum === bBeforeNum) {
	                                    var aFromNum = aText.substr(aDigitIndex);
	                                    var bFromNum = bText.substr(bDigitIndex);
	
	                                    var versionCompareResult = _this.utils.compareVersions(aFromNum, bFromNum);
	
	                                    if (versionCompareResult === -1) aScore += 100;
	                                    if (versionCompareResult === 1) bScore += 100;
	                                }
	                            }
	
	                            if (aText < bText) aScore++;
	                            if (aText > bText) bScore++;
	                        }
	                        return aScore < bScore ? 1 : -1;
	                    } else {
	                        if (!aNode.data) return -1; //special node
	                        else if (!bNode.data) return 1; //special node
	                        else if (aType === "repository" || aType === "virtualRemoteRepository") return -1;else if (bType === "repository" || bType === "virtualRemoteRepository") return 1;else return aText > bText ? 1 : -1;
	                    }
	                });
	            }
	        },
	        _getFileExtension: {
	            value: function _getFileExtension(path) {
	                return path.indexOf(".") === -1 ? "" : path.split(".").pop();
	            }
	        },
	        _iconsShouldBeReplacedWithRepoPkgTypeIcon: {
	            value: function _iconsShouldBeReplacedWithRepoPkgTypeIcon(nodeType, repoPkgType, fullPath) {
	                var repotype = repoPkgType && repoPkgType.toLocaleLowerCase();
	                return nodeType === "archive" && $.inArray(repotype, this.packageTypesReplacingArchives) !== -1 || repoPkgType === "Gradle" && this._getFileExtension(fullPath) === "gradle";
	            }
	        },
	        filterCallback: {
	            value: function filterCallback(node) {
	                var _this = this;
	
	                var treeNode = node.data;
	                var rootRepo = node && node.data && node.data.getRoot ? node.data.getRoot() : null;
	
	                var isFilterMatch = function (str, filterText) {
	                    if (filterText.indexOf(",") === -1) {
	                        return str.toLowerCase().trim().indexOf(filterText.toLowerCase().trim()) != -1;
	                    } else {
	                        var filterArray = filterText.split(",");
	                        return filterArray.reduce(function (acc, val) {
	                            return acc || val && str.toLowerCase().trim().indexOf(val.trim().toLowerCase()) != -1;
	                        }, false);
	                    }
	                };
	
	                var checkFavorites = function (treeNode) {
	                    if (!localStorage.filterFavorites || !localStorage.favoritesRepos) return true;
	                    var favoritesRepos = JSON.parse(localStorage.favoritesRepos);
	                    if ((treeNode.isTrashcan() || treeNode.isInTrashcan()) && _this.type === "tree" || _.includes(favoritesRepos.favoritesRepos, rootRepo.repoKey)) return true;else return false;
	                };
	
	                var combinedFilter = this.getCombinedFilter(this.searchText);
	                var filterRegexp = new RegExp(REGEXP);
	                var matches = filterRegexp.exec(combinedFilter);
	                if (matches) {
	                    var ret = true;
	                    while (matches) {
	                        if (matches[2].trim()) {
	                            var filterType = matches[1].trim();
	                            var filterText = matches[2].trim();
	                            switch (filterType) {
	                                case "pkg":
	                                    ret = ret && (treeNode.isRepo() && treeNode.repoPkgType && isFilterMatch(treeNode.repoPkgType, filterText) || !treeNode.isRepo() && rootRepo.isRepo() && isFilterMatch(rootRepo.repoPkgType, filterText) || (treeNode.isTrashcan && treeNode.isTrashcan() || treeNode.isInTrashcan && treeNode.isInTrashcan()) && localStorage.pinnedTrash && this.type === "tree");
	                                    break;
	                                case "repo":
	                                    ret = ret && (treeNode.isRepo() && isFilterMatch(treeNode.repoType === _.camelCase(REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES) ? "distribution" : treeNode.repoType, filterText) || !treeNode.isRepo() && rootRepo.isRepo() && isFilterMatch(treeNode.repoType === _.camelCase(REPO_FORM_CONSTANTS.DISTRIBUTION_REPO_TYPES.RELEASE_BUNDLES) ? "distribution" : treeNode.repoType, filterText) || (treeNode.isTrashcan && treeNode.isTrashcan() || treeNode.isInTrashcan && treeNode.isInTrashcan()) && localStorage.pinnedTrash && this.type === "tree");
	                                    break;
	                            }
	                        }
	                        matches = filterRegexp.exec(combinedFilter);
	                    }
	                    return ret && checkFavorites(treeNode);
	                } else {
	                    return checkFavorites(treeNode);
	                }
	            }
	        },
	        _searchTree: {
	
	            /****************************
	             * Searching the tree
	             ****************************/
	
	            value: function _searchTree(text) {
	                this.searchText = text || "";
	                this.treeApi.refreshFilter();
	                var showOnlyMatches = text ? text.match(new RegExp(REGEXP)) || false : false;
	                this._jsQuickFind(this.searchText);
	            }
	        },
	        _jsQuickFind: {
	            value: function _jsQuickFind(searchText) {
	                this.treeApi.quickFind(searchText);
	            }
	        },
	        _isInActiveFilterMode: {
	            value: function _isInActiveFilterMode() {
	                var checkIfMatchesFound = arguments[0] === undefined ? false : arguments[0];
	
	                if (this.searchText.match(new RegExp(REGEXP))) {
	                    var justSearchTerm = this.searchText.substr(this.searchText.indexOf(":") + 1).trim();
	                    if (justSearchTerm) {
	                        if (checkIfMatchesFound) {
	                            var matchesFound = !!this.treeApi.getViewPane().getFilteredNodesCount();
	                            return matchesFound ? true : "no results";
	                        } else {
	                            return true;
	                        }
	                    } else {
	                        return "empty";
	                    }
	                } else {
	                    return false;
	                }
	            }
	        },
	        _searchTreeKeyDown: {
	            value: function _searchTreeKeyDown(key) {
	                if (key == KEYS.ENTER) {
	                    //manually set the model to the input element's value (because the model is debounced...)
	                    this.searchText = $(".jf-tree-search").val();
	
	                    var isInActiveFilterMode = this._isInActiveFilterMode(true);
	
	                    if (isInActiveFilterMode === true) {
	                        this.activeFilter = true;
	                        if (this.browserController) {
	                            this.browserController.activeFilter = true;
	                            this.browserController.searchText = this.searchText + "*";
	                        }
	                        this._searchTree(this.searchText);
	                        this._focusOnTree();
	
	                        var selected = this.treeApi.getSelectedNode();
	                        if (!selected || !this.treeApi.isNodeFiltered(selected)) {
	                            this.treeApi.selectFirst();
	                        }
	                    } else if (isInActiveFilterMode === "no results") {
	                        if (this.artifactoryNotifications) this.artifactoryNotifications.create({ warn: "No repositories matches the filter expression" });
	                        this._clear_search();
	                    } else {
	                        this.activeFilter = false;
	                        if (this.browserController) this.browserController.activeFilter = false;
	                        //                this._selectCurrentSearchResult();
	                        this.treeApi.selectPreSelected();
	                        this.treeApi.openSelected();
	                        this._clear_search();
	                        this._focusOnTree();
	                        this.currentResult = null;
	                    }
	                } else if (key == KEYS.ESC) {
	                    this.activeFilter = false;
	                    if (this.browserController) this.browserController.activeFilter = false;
	                    this._clear_search();
	                    this._focusOnTree();
	                    this.currentResult = null;
	                }
	            }
	        },
	        _clear_search: {
	            value: function _clear_search() {
	                this.activeFilter = false;
	                if (this.browserController) this.browserController.activeFilter = false;
	
	                this.searchNodes = null;
	                this.searchParentNodes = null;
	                this.nomatchNodes = null;
	                this.nomatchParentNodes = null;
	                this.searchText = "";
	                this.treeApi.quickFind("");
	                this.treeApi.refreshFilter();
	            }
	        },
	        getPersistentFilter: {
	            value: function getPersistentFilter() {
	                var persistentFilter = localStorage.getItem("treeFiltering");
	                if (persistentFilter) {
	                    persistentFilter = JSON.parse(persistentFilter);
	                    var filterArray = [];
	                    if (persistentFilter.pkg.length) filterArray.push("pkg:" + persistentFilter.pkg.join(","));
	                    if (persistentFilter.repo.length) filterArray.push("repo:" + persistentFilter.repo.join(","));
	                    var filterString = filterArray.join(";");
	
	                    return filterString || (localStorage.filterFavorites && localStorage.favoritesRepos ? "*" : "");
	                }
	                return localStorage.filterFavorites && localStorage.favoritesRepos ? "*" : "";
	            }
	        },
	        getCombinedFilter: {
	            value: function getCombinedFilter(tempFilter) {
	                var _this = this;
	
	                var persistentFilter = this.getPersistentFilter();
	                if (!tempFilter) {
	                    return persistentFilter;
	                } else {
	                    var _ret = (function () {
	
	                        var persistentObj = _this._filterStringToFilterObject(persistentFilter);
	                        var tempObj = _this._filterStringToFilterObject(tempFilter);
	
	                        var pkgArray = persistentObj.pkg ? _.filter(persistentObj.pkg, function (val) {
	                            return _.find(tempObj.pkg, function (tempVal) {
	                                return val.toLowerCase().indexOf(tempVal) !== -1;
	                            });
	                        }) : tempObj.pkg || [];
	                        var repoArray = persistentObj.repo ? _.filter(persistentObj.repo, function (val) {
	                            return _.find(tempObj.repo, function (tempVal) {
	                                return val.toLowerCase().indexOf(tempVal) !== -1;
	                            });
	                        }) : tempObj.repo || [];
	
	                        if (!pkgArray.length) pkgArray = persistentObj.pkg;
	                        if (!repoArray.length) repoArray = persistentObj.repo;
	
	                        var combinedArray = [];
	                        if (pkgArray && pkgArray.length) combinedArray.push("pkg:" + pkgArray.join(","));
	                        if (repoArray && repoArray.length) combinedArray.push("repo:" + repoArray.join(","));
	                        var combinedString = combinedArray.join(";");
	
	                        return {
	                            v: combinedString
	                        };
	                    })();
	
	                    if (typeof _ret === "object") {
	                        return _ret.v;
	                    }
	                }
	            }
	        },
	        _filterStringToFilterObject: {
	            value: function _filterStringToFilterObject(filterString) {
	
	                if (!filterString) {
	                    return {};
	                }var filterRegexp = new RegExp(REGEXP);
	
	                var part1 = filterRegexp.exec((filterString.match(filterRegexp) || [])[0]) || [];
	                var part2 = filterRegexp.exec((filterString.match(filterRegexp) || [])[1]) || [];
	
	                var obj = (function () {
	                    var _obj = {};
	
	                    _defineProperty(_obj, part1[1], (part1[2] || "").split(","));
	
	                    _defineProperty(_obj, part2[1], (part2[2] || "").split(","));
	
	                    return _obj;
	                })();
	
	                delete obj.undefined;
	                return obj;
	            }
	        }
	    });
	
	    return JFCommonBrowser;
	})();
	
	module.exports = JFCommonBrowser;

/***/ }),
/* 298 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	exports.jfTrashPin = jfTrashPin;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	function jfTrashPin() {
	    return {
	        scope: {
	            treeBrowser: "="
	        },
	        restrict: "E",
	        controller: JFTrashPinController,
	        controllerAs: "jfTrashPin",
	        bindToController: true,
	        template: "<i class=\"icon icon-pin trash-pin\"\n                      ng-class=\"{'icon-pin': !jfTrashPin.treeBrowser.isTrashPinned(), 'icon-unpin': jfTrashPin.treeBrowser.isTrashPinned()}\"\n                      ng-style=\"{left: jfTrashPin.getLeftPosition()}\" \n                      ng-click=\"jfTrashPin.treeBrowser.toggleTrashPin($event); jfTrashPin.updateTooltipText()\"  \n                      jf-tooltip=\"{{jfTrashPin.tooltipText}}\"></i>"
	    };
	}
	
	var JFTrashPinController = (function () {
	    function JFTrashPinController($element) {
	        _classCallCheck(this, JFTrashPinController);
	
	        this.$element = $element;
	    }
	
	    _createClass(JFTrashPinController, {
	        $onInit: {
	            value: function $onInit() {
	                this.updateTooltipText();
	            }
	        },
	        updateTooltipText: {
	            value: function updateTooltipText() {
	                this.tooltipText = !this.treeBrowser.isTrashPinned() ? "Pin Trash Can" : "Unpin Trash Can";
	            }
	        },
	        getLeftPosition: {
	            value: function getLeftPosition() {
	                var trashPin = $(this.$element).find(".trash-pin");
	                var hScroll = trashPin.parents(".h-scroll-wrapper");
	                return hScroll.scrollLeft() + hScroll.parent().width() - 50 + "px";
	            }
	        }
	    });
	
	    return JFTrashPinController;
	})();

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfStashBrowser = jfStashBrowser;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var JFCommonBrowser = _interopRequire(__webpack_require__(297));
	
	var types = _interopRequire(__webpack_require__(292));
	
	function jfStashBrowser() {
	    return {
	        scope: {
	            startCompact: "="
	        },
	        restrict: "E",
	        controller: JFStashBrowserController,
	        controllerAs: "jfStashBrowser",
	        templateUrl: "states/artifacts/jf_stash_browser/jf_stash_browser.html",
	        bindToController: true
	    };
	}
	
	var JFStashBrowserController = (function (_JFCommonBrowser) {
	    function JFStashBrowserController(JFTreeApi, $timeout, $injector, JFrogEventBus, $element, $scope, $state, $stateParams, $q, ArtifactoryState, ArtifactActions, StashResultsDao, User, JFrogUIUtils) {
	        _classCallCheck(this, JFStashBrowserController);
	
	        _get(Object.getPrototypeOf(JFStashBrowserController.prototype), "constructor", this).call(this, JFTreeApi, $scope, ArtifactActions, ArtifactoryState, JFrogUIUtils);
	
	        this.rootID = "____root_node____";
	
	        this.type = "stash";
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.$q = $q;
	        this.user = User;
	        this.TreeNode = $injector.get("TreeNode");
	        this.JFrogEventBus = JFrogEventBus;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        this.JFrogUIUtils = JFrogUIUtils;
	        this.stashResultsDao = StashResultsDao;
	        this.types = types;
	
	        this.whenTreeDataLoaded = $q.defer();
	
	        this.$element = $element;
	
	        this.filteredActions = ["Copy", "Move", "Watch", "Unwatch", "UploadToBintray", "Distribute", "Refresh", "DeleteVersions", "DownloadFolder", "Zap", "ZapCaches", "IgnoreAlert", "UnignoreAlert"];
	
	        this.discardedCount = 0;
	    }
	
	    _inherits(JFStashBrowserController, _JFCommonBrowser);
	
	    _createClass(JFStashBrowserController, {
	        $onInit: {
	            value: function $onInit() {
	                this.compactMode = this.startCompact || false;
	                this._registerEvents();
	                this._setUpTree();
	            }
	        },
	        _setUpTree: {
	            value: function _setUpTree() {
	                var _this = this;
	
	                var driver = {
	                    uniqueId: function (node) {
	                        return node.id;
	                    },
	                    nodeById: this.nodeByPathGetter.bind(this),
	                    text: function (node) {
	                        return node.text;
	                    },
	                    childrenChecker: this.childrenChecker.bind(this),
	                    children: this.childrenGetter.bind(this),
	                    parent: this.parentGetter.bind(this),
	                    contextMenuItems: this._getContextMenuItems.bind(this)
	                };
	
	                this.treeApi.setNodeTemplate(function (node) {
	                    return _this.getNodeTemplate(node);
	                }).setDataDriver(driver).on("item.selected", function (item) {
	                    item.data.load().then(function () {
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_NODE_SELECT, item);
	                    });
	                }).on("keydown", function (e) {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.ACTIVATE_TREE_SEARCH, e.key);
	                }).on("ready", this.onReady.bind(this));
	
	                this.treeApi.createViewPane().setItemHeight("30px").setItemsPerPage("auto");
	
	                this.treeApi.freeze();
	            }
	        },
	        getNodeTemplate: {
	            value: function getNodeTemplate(node) {
	                return "<div>\n                    <i class=\"tree-node-icon " + (this.types[node.type] ? this.types[node.type].icon : this.types["default"].icon) + "\"></i>\n                    <span class=\"node-text\" style=\"margin-left: 5px\">" + node.text + "</span>\n                </div>";
	            }
	        },
	        onReady: {
	            value: function onReady() {
	                var _this = this;
	
	                var root = _.find(this.stashData, { id: this.rootID });
	                var currentPath = this.$stateParams.artifact ? this.$stateParams.artifact.substring(this.$stateParams.artifact.indexOf("/") + 1).split(" ").join("") : null;
	                var nodeToOpen = this.nodeByPathGetter(currentPath);
	
	                if (!nodeToOpen) {
	                    this.treeApi.openNode(root);
	                    this.treeApi.unFreeze();
	                    this.treeApi.selectFirst();
	                } else {
	                    this.treeApi.openDeepNode(nodeToOpen).then(function () {
	                        return _this.treeApi.unFreeze();
	                    });
	                }
	                this.treeApi.focus();
	            }
	        },
	        fetchStashData: {
	            value: function fetchStashData() {
	                var _this = this;
	
	                var defer = this.$q.defer();
	                this.stashResultsDao.get({ name: "stash" }).$promise.then(function (data) {
	                    _this.stashData = _this._transformStashDataToTree(data);
	                    if (_this.compactMode) {
	                        _this.stashData = _this._compactTree(_this.stashData);
	                    }
	                    _this.whenTreeDataLoaded.resolve();
	                    defer.resolve();
	                });
	
	                return defer.promise;
	            }
	        },
	        nodeByPathGetter: {
	            value: function nodeByPathGetter(path) {
	                var node = _.find(this.stashData, { id: path });
	                return node;
	            }
	        },
	        childrenChecker: {
	            value: function childrenChecker(parent) {
	                return !!_.filter(this.stashData, { parent: parent.id }).length;
	            }
	        },
	        childrenGetter: {
	            value: function childrenGetter(parent) {
	                var _this = this;
	
	                var defer = this.$q.defer();
	                var childrenGetterInner = function () {
	                    if (!parent) {
	                        defer.resolve(_.filter(_this.stashData, { id: _this.rootID }));
	                    } else {
	                        var children = _.filter(_this.stashData, { parent: parent.id });
	                        defer.resolve(children);
	                    }
	                };
	                if (!this.stashData) {
	                    this.fetchStashData().then(childrenGetterInner);
	                } else childrenGetterInner();
	
	                return defer.promise;
	            }
	        },
	        parentGetter: {
	            value: function parentGetter(node) {
	                var parentId = node.parent;
	                var parent = this.nodeByPathGetter(parentId);
	                return parent;
	            }
	        },
	        _transformStashDataToTree: {
	            value: function _transformStashDataToTree(stashData) {
	                var _this = this;
	
	                var treeData = [];
	
	                var pushToTree = function (treeItemData) {
	                    if (!_.find(treeData, { id: treeItemData.id })) {
	                        treeData.push(treeItemData);
	                    }
	                };
	
	                this.rootNode = this._createRootNode(stashData);
	                pushToTree(this.rootNode);
	
	                stashData.forEach(function (result, index) {
	                    result.path = result.relativePath;
	                    result.text = result.name;
	                    result.type = "file";
	
	                    var dirArray = result.relativePath.split("/");
	                    dirArray.pop();
	
	                    var resultNode = {
	                        id: result.relativePath.split(" ").join(""),
	                        text: _this.JFrogUIUtils.getSafeHtml(result.name),
	                        parent: dirArray.join("/").split(" ").join("") || _this.rootID,
	                        type: result.mimeType,
	                        data: _this._filterActions(new _this.TreeNode(result))
	                    };
	
	                    // replace the node icon type to the package type if necessary
	                    var type = typeof result.fileType != "undefined" ? result.fileType : result.type;
	                    if (_this._iconsShouldBeReplacedWithRepoPkgTypeIcon(type, result.repoPkgType, result.fullpath)) {
	                        resultNode.type = resultNode.data.iconType = result.repoPkgType.toLocaleLowerCase();
	                    }
	
	                    pushToTree(resultNode);
	
	                    for (var i = dirArray.length - 1; i >= 0; i--) {
	                        var up = _.clone(dirArray);
	                        up.pop();
	
	                        var folderNode = {
	                            id: dirArray.join("/").split(" ").join(""),
	                            text: dirArray[i],
	                            parent: up.join("/").split(" ").join("") || _this.rootID,
	                            type: "folder",
	                            data: _this._filterActions(new _this.TreeNode({
	                                repoKey: result.repoKey,
	                                path: dirArray.join("/"),
	                                text: dirArray[i],
	                                type: "folder"
	                            }))
	                        };
	
	                        pushToTree(folderNode);
	                        dirArray.pop();
	                    }
	                });
	
	                return treeData;
	            }
	        },
	        _createRootNode: {
	            value: function _createRootNode(stashData) {
	                var _this = this;
	
	                var THIS = this;
	                var node = undefined;
	                node = {
	                    id: this.rootID,
	                    parent: "#",
	                    text: "Stashed Search Results",
	                    type: "stash",
	                    data: {
	                        text: "Stashed Search Results",
	                        iconType: "stash",
	                        load: function load() {
	
	                            THIS.$stateParams.artifact = "";
	                            THIS.$stateParams.tab = "StashInfo";
	
	                            this.tabs = [{ name: "StashInfo" }];
	                            this.actions = stashData.length ? [{ title: "Copy Stash to Repository", name: "CopyStash", icon: "icon-copy" }, { title: "Move Stash to Repository", name: "MoveStash", icon: "icon-move" }, { title: "Discard Search Results", name: "DiscardStash", icon: "icon-delete-content" }] : [];
	                            if (!THIS.user.currentUser.getCanDeploy()) {
	                                this.actions.shift();
	                                this.actions.shift();
	                            }
	                            this.info = {
	                                artifactCount: Math.max(stashData.length - THIS.discardedCount, 0)
	                            };
	                            return THIS.$q.when(this);
	                        },
	                        getDownloadPath: function () {
	                            return _this.$q.when(_this);
	                        },
	                        refreshWatchActions: function () {
	                            return _this.$q.when(_this);
	                        },
	                        isRepo: function () {
	                            return false;
	                        }
	                    }
	
	                };
	                return node;
	            }
	        },
	        _filterActions: {
	            value: function _filterActions(treeNode) {
	                var _this = this;
	
	                var origLoad = treeNode.load.bind(treeNode);
	                treeNode.load = function () {
	                    return origLoad().then(function () {
	
	                        treeNode.actions = _.filter(treeNode.actions, function (action) {
	                            return _this.filteredActions.indexOf(action.name) === -1;
	                        });
	
	                        var deleteAction = _.find(treeNode.actions, { name: "Delete" });
	                        if (deleteAction) treeNode.actions.splice(treeNode.actions.indexOf(deleteAction), 1);
	
	                        if (!_.find(treeNode.actions, { name: "ShowInTree" })) {
	                            treeNode.actions.push({
	                                title: "Show In Tree",
	                                name: "ShowInTree",
	                                icon: "icon-show-in-tree"
	                            });
	                        }
	
	                        if (!_.find(treeNode.actions, { name: "DiscardFromStash" })) {
	                            treeNode.actions.push({
	                                title: "Discard from Stash",
	                                name: "DiscardFromStash",
	                                icon: "icon-delete-content"
	                            });
	                        }
	
	                        if (deleteAction) treeNode.actions.push(deleteAction);
	                    });
	                };
	
	                return treeNode;
	            }
	        },
	        _compactTree: {
	            value: function _compactTree(stashData) {
	
	                var compactedData = [].concat(stashData);
	
	                var getChildren = function (parent) {
	                    return _.filter(compactedData, { parent: parent.id });
	                };
	
	                var nodeById = function (id) {
	                    return _.find(compactedData, { id: id });
	                };
	
	                var remove = function (node) {
	                    _.remove(compactedData, function (n) {
	                        return n === node;
	                    });
	                };
	
	                var recursiveCompact = undefined;
	                recursiveCompact = function (node) {
	                    if (node.type !== "folder") {
	                        node.data = nodeById(node.id).data;
	                        return;
	                    }
	
	                    var children = getChildren(node);
	                    if (children.length === 1 && children[0].type === "folder") {
	                        node.text += "/" + children[0].text;
	                        node.data = nodeById(children[0].id).data;
	                        node.id = children[0].id;
	                        remove(children[0]);
	                        recursiveCompact(node);
	                    } else if (children.length > 1) {
	                        children.forEach(function (child) {
	                            recursiveCompact(child);
	                        });
	                    }
	                };
	
	                getChildren(nodeById(this.rootID)).forEach(function (node) {
	                    return recursiveCompact(node);
	                });
	
	                return compactedData;
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CHANGE, function (text) {
	                    return _this._searchTree(text);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_CANCEL, function (text) {
	                    return _this._clear_search();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_SEARCH_KEYDOWN, function (e) {
	                    _this.treeApi.handleKeyEvent(e);
	                    _this._searchTreeKeyDown(e.keyCode);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DELETE, function (node) {
	                    node.alreadyDeleted = true;
	                    _this.artifactActions.perform({ name: "DiscardFromStash" }, node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_MOVE_STASH, function (options) {
	                    _this.exitStashState(options);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_COPY_STASH, function (options) {
	                    _this.exitStashState(options);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DISCARD_STASH, function () {
	                    delete _this.stashData;
	                    _this.fetchStashData().then(function () {
	                        _this.treeApi.refreshTree().then(function () {
	                            var selected = _this.treeApi.getSelectedNode();
	                            selected.data.load().then(function () {
	                                _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_NODE_SELECT, selected);
	                            });
	                        });
	                    });
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_DISCARD_FROM_STASH, function (node) {
	                    _this._discardFromStash(node);
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_REFRESH_STASH, function () {
	                    delete _this.stashData;
	                    _this.fetchStashData().then(function () {
	                        _this.treeApi.refreshTree().then(function () {
	                            var root = _.find(_this.stashData, { id: _this.rootID });
	                            _this.treeApi.openNode(root);
	                        });
	                    });
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.ACTION_EXIT_STASH, function (node) {
	                    if (node) _this.treeApi.selectNode(_this.nodeByPathGetter(node.id));
	                    _this.$timeout(function () {
	                        return _this.exitStashState();
	                    });
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_NODE_OPEN, function (path) {
	                    _this._openTreeNode(path);
	                });
	
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TREE_COMPACT, function (compact) {
	                    return _this._toggleCompactFolders(compact);
	                });
	
	                // URL changed (like back button / forward button / someone input a URL)
	                this.JFrogEventBus.registerOnScope(this.$scope, this.EVENTS.TABS_URL_CHANGED, function (stateParams) {
	                    var path = stateParams.artifact ? stateParams.artifact.substring(stateParams.artifact.indexOf("/") + 1) : _this.rootID;
	                    if (stateParams.tab === "StashInfo" && _this.$state.params.tab !== "StashInfo") path = _this.rootID;
	                    _this.whenTreeDataLoaded.promise.then(function () {
	
	                        var selectedNode = _this.treeApi.getSelectedNode();
	                        if (selectedNode && selectedNode.fullpath === stateParams.artifact) return;
	
	                        var pathNode = _this.nodeByPathGetter(path);
	                        if (pathNode) _this.treeApi.openDeepNode(pathNode);
	                    });
	                });
	            }
	        },
	        _countArtifacts: {
	            value: function _countArtifacts(node) {
	                var _this = this;
	
	                var defer = this.$q.defer();
	                if (node.type !== "folder") {
	                    defer.resolve(1);
	                } else {
	                    (function () {
	                        var artifacts = 0;
	                        _this.childrenGetter(node).then(function (children) {
	                            var pendings = children.length;
	                            children.forEach(function (child) {
	                                _this._countArtifacts(child).then(function (childCount) {
	                                    artifacts += childCount;
	                                    pendings--;
	                                    if (!pendings) {
	                                        defer.resolve(artifacts);
	                                    }
	                                });
	                            });
	                        });
	                    })();
	                }
	                return defer.promise;
	            }
	        },
	        _discardFromStash: {
	            value: function _discardFromStash(node) {
	                var _this = this;
	
	                this._countArtifacts(node).then(function (artifactsDiscarded) {
	                    _this.discardedCount += artifactsDiscarded;
	                    var selected = _this.treeApi.getSelectedNode();
	                    selected.data.load().then(function () {
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_NODE_SELECT, selected);
	                    });
	                });
	
	                var deletePoint = node;
	                var parent = this.parentGetter(node);
	                while (parent.$childrenCache.length === 1 && parent.id !== this.rootID) {
	                    deletePoint = parent;
	                    parent = this.parentGetter(parent);
	                }
	
	                this.treeApi.selectNode(parent);
	                this.treeApi.deleteNode(deletePoint);
	            }
	        },
	        exitStashState: {
	            value: function exitStashState(options) {
	                var _this = this;
	
	                this.$scope.$destroy();
	                var artifact = options && options.target ? options.target.targetRepoKey || "/" : this.$stateParams.artifact || "";
	                this.$state.go("artifacts.browsers.path", { tab: "General", artifact: artifact, browser: "tree" });
	                this.$timeout(function () {
	                    _this.JFrogEventBus.dispatch(_this.EVENTS.TREE_REFRESH);
	                    if (options) {
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.ACTION_COPY, { node: options.node, target: options.target });
	                    }
	                });
	            }
	        }
	    });
	
	    return JFStashBrowserController;
	})(JFCommonBrowser);

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/**
	 * launch a modal that prompts the user to select a target repo & path to do move / copy
	 *
	 * @param action:String - either 'copy' or 'move'
	 * @returns promise - resolved with Object({targetRepoKey: String, targetPath: String}) if the user confirmed, rejected otherwise
	 */
	exports.selectTargetPathFactory = selectTargetPathFactory;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIPS = _interopRequire(__webpack_require__(107));
	
	"use strict";
	function selectTargetPathFactory(ArtifactActionsDao, $q, $rootScope, JFrogModal, RepoDataDao) {
	    return function selectTargetPath(action, node, useNodePath, customDryRun, defaultValues) {
	
	        if (useNodePath === undefined) useNodePath = true;
	
	        var deferred = $q.defer();
	        var modalInstance = undefined;
	
	        // init modal scope
	        var modalScope = $rootScope.$new();
	        modalScope.action = action;
	        modalScope.node = node;
	        modalScope.target = {
	            repoList: [],
	            repoKey: defaultValues ? defaultValues.targetRepoKey : "",
	            path: useNodePath ? angular.copy(node.data.path) : defaultValues ? defaultValues.targetPath : "/",
	            isCustomPath: false
	        };
	        modalScope.tooltips = TOOLTIPS.selectTargetPathModal;
	
	        // get local repo list that match the original's repo pkg type
	        var isMavinish = function (pkgType) {
	            return _.includes(["maven", "ivy", "gradle", "sbt"], pkgType.toLowerCase());
	        };
	        RepoDataDao.get({ user: true }).$promise.then(function (result) {
	            if (node.data.getRoot && node.data.getRoot().repoPkgType && action !== "restore") {
	                result.repoTypesList = _.filter(result.repoTypesList, function (repo) {
	                    return repo.repoType === node.data.getRoot().repoPkgType || repo.repoType === "Generic" || isMavinish(repo.repoType) && isMavinish(node.data.getRoot().repoPkgType);
	                });
	            } else {}
	            modalScope.target.repoList = result.repoTypesList.map(function (repo) {
	                return { value: repo.repoKey, text: repo.repoKey };
	            });
	        });
	
	        if (action === "restore") modalScope.noDryRun = true;
	
	        // scope functions for modal
	        modalScope.cancel = function () {
	            modalInstance.close();
	            deferred.reject();
	        };
	
	        modalScope.changeTargetRepository = function () {
	            if (modalScope.target.repoKey === "artifactory-build-info") {
	                modalScope.target.isCustomPath = false;
	                modalScope.target.path = "/";
	            }
	        };
	
	        modalScope.confirm = function () {
	            deferred.resolve({
	                target: {
	                    targetRepoKey: modalScope.target.repoKey,
	                    targetPath: modalScope.getTargetPath()
	                },
	                onSuccess: function () {
	                    modalInstance.close();
	                    deferred = $q.defer();
	                    deferred.resolve();
	                    return deferred.promise;
	                },
	                onFail: function (msg) {
	                    modalScope.resultError = true;
	                    modalScope.dryRunResults = msg;
	                    deferred = $q.defer();
	                    return deferred.promise;
	                }
	            });
	        };
	        modalScope.getTargetPath = function () {
	            return modalScope.target.isCustomPath && modalScope.target.path || modalScope.target.path;
	        };
	        modalScope.dryRun = customDryRun || function () {
	            var data = {
	                repoKey: node.data.repoKey,
	                path: node.data.path,
	                targetRepoKey: modalScope.target.repoKey,
	                targetPath: modalScope.getTargetPath(),
	                dryRun: true
	            };
	            var params = { action: action };
	            ArtifactActionsDao.dryRun(params, data).$promise.then(function (response) {
	                modalScope.resultError = false;
	                modalScope.dryRunResults = [response.info];
	            })["catch"](function (response) {
	                modalScope.resultError = true;
	                modalScope.dryRunResults = response.data.errors;
	            });
	        };
	
	        if (customDryRun) customDryRun.scope = modalScope;
	
	        // Launch modal
	        modalInstance = JFrogModal.launchModal("select_target_path", modalScope, "sm");
	        return deferred.promise;
	    };
	}

/***/ }),
/* 301 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	exports.commonGridColumns = commonGridColumns;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	function commonGridColumns() {
	    var nextId = 0;
	    return {
	        repoPathColumn: function repoPathColumn(specialClass) {
	            return "<div ng-if=\"row.entity.repoKey\" class=\"ui-grid-cell-contents " + specialClass + "\">{{row.entity.repoKey}}/{{row.entity.path}}</div>" + "<div ng-if=\"!row.entity.repoKey\" class=\"ui-grid-cell-contents " + specialClass + "\">{{row.entity.path}}</div>";
	        },
	
	        downloadableColumn: function downloadableColumn(specialClass) {
	            return "<div ng-if=\"row.entity.downloadLink\" class=\"jf-link ui-grid-cell-contents " + specialClass + "\">{{row.entity.name}}</div>" + "<div ng-if=\"!row.entity.downloadLink\" class=\"ui-grid-cell-contents " + specialClass + "\">{{row.entity.name}}</div>";
	        },
	
	        booleanColumn: function booleanColumn(model) {
	            return "<div class=\"grid-checkbox\"><input ng-model=\"" + model + "\" type=\"checkbox\" disabled/><span class=\"icon icon-v\"></span></div>";
	        },
	        checkboxColumn: function checkboxColumn(model, click, disabled) {
	            return "<div ng-if=\"!row.entity._emptyRow\" class=\"grid-cell-checkbox\"><jf-checkbox><input ng-model=\"" + model + "\"" + (click && click.length ? " ng-change=\"" + click + "\"" : "") + (disabled && disabled.length ? " ng-disabled=\"" + disabled + "\"" : "") + " type=\"checkbox\"/></jf-checkbox></div>";
	        },
	        listableColumn: function listableColumn(listModel, rowNameModel, displayModel, alwaysShow, _x, showAsyncData, externalCountModel) {
	            var testIdPrefix = arguments[4] === undefined ? null : arguments[4];
	
	            testIdPrefix = testIdPrefix ? testIdPrefix + "-" : "";
	
	            displayModel = displayModel ? "{{" + listModel + ".length}} | {{" + displayModel + "}}" : "{{" + externalCountModel + " ? " + externalCountModel + " : " + listModel + ".length}} | {{" + listModel + ".join(', ')}}{{" + externalCountModel + " && " + externalCountModel + " > " + listModel + ".length ? ',...' : ''}}";
	
	            var id = "" + testIdPrefix + "{{row.uid}}_" + nextId;
	
	            var template = "<div ng-if=\"" + listModel + ".length\" \n                                   ng-class=\"{'always-show': " + showAsyncData + " || " + alwaysShow + " }\" \n                                   class=\"ui-grid-cell-contents no-tooltip\" id=\"" + id + "\">\n                                <span class=\"gridcell-content-text\">" + displayModel + "</span>\n                                 <a class=\"jf-link gridcell-showall\" ng-if=\"!(" + showAsyncData + ") && (grid.options.isOverflowing('" + testIdPrefix + "'+row.uid+'_'+" + nextId + ") || " + alwaysShow + ")\" href ng-click=\"grid.options.showAll(" + listModel + "," + rowNameModel + ",col)\"> (See All)</a>\n                                 <a class=\"jf-link gridcell-showall\" ng-if=\"" + showAsyncData + "\" href ng-click=\"grid.options.asyncShowAll(" + rowNameModel + ",col)\"> (See All)</a>\n                             </div>\n                             <div ng-if=\"!" + listModel + ".length\" class=\"ui-grid-cell-contents no-tooltip\" id=\"" + id + "\">-</div>";
	
	            nextId++;
	            return template;
	        },
	        iconColumn: function iconColumn(cellText, cellIcon, iconClass) {
	            return "<div class=\"ui-grid-cell-contents\" id=\"type\"><i class=\"icon icon-{{" + cellIcon + "}}" + (iconClass ? " " + iconClass : "") + "\"></i>{{" + cellText + "}}</div>";
	        },
	        ajaxColumn: function ajaxColumn() {
	            return "<div class=\"ui-grid-cell-contents status-grid\"><div class=\"icon-hourglass\" ng-if=\"!row.entity.status\"></div>{{row.entity.status}}</div>";
	        }
	    };
	}

/***/ }),
/* 302 */
/***/ (function(module, exports) {

	
	/**
	 * launch a modal that prompts the user to select a target repo & path to do move / copy
	 *
	 * @param action:String - either 'copy' or 'move'
	 * @returns promise - resolved with Object({targetRepoKey: String, targetPath: String}) if the user confirmed, rejected otherwise
	 */
	"use strict";
	
	exports.selectDeleteVersionsFactory = selectDeleteVersionsFactory;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	function selectDeleteVersionsFactory($q, ArtifactActionsDao, $rootScope, JFrogModal, JFrogGridFactory) {
	    return function selectDeleteVersions(node) {
	        var modalInstance = undefined;
	        var modalScope = $rootScope.$new();
	        modalScope.noData = false;
	
	        // Grid
	        modalScope.versionsGridOptions = JFrogGridFactory.getGridInstance(modalScope).setColumns([{
	            name: "Group ID",
	            displayName: "Group ID",
	            field: "groupId"
	        }, {
	            name: "Version",
	            displayName: "Version",
	            field: "version"
	        }, {
	            name: "Directories Count",
	            displayName: "Directories Count",
	            field: "directoriesCount"
	        }]).setRowTemplate("default").setMultiSelect();
	
	        // Scope functions
	        modalScope.selectedVersions = function () {
	            return modalScope.versions && modalScope.versionsGridOptions.api && modalScope.versionsGridOptions.api.selection.getSelectedRows() || [];
	        };
	
	        modalScope.close = function (version) {
	            modalInstance.close(version);
	        };
	
	        var defer = $q.defer();
	
	        ArtifactActionsDao.getDeleteVersions({ repoKey: node.data.repoKey, path: node.data.path }).$promise.then(function (versions) {
	            modalScope.versions = versions.data.versions;
	            modalScope.versionsGridOptions.setGridData(versions.data.versions);
	            if (versions.data.versions.length == 0) {
	                modalScope.noData = true;
	            }
	        })["finally"](function () {
	            // Launch modal
	            var modalSize = modalScope.noData ? "sm" : "lg";
	            modalInstance = JFrogModal.launchModal("select_delete_versions", modalScope, modalSize);
	            modalInstance.result.then(function (versions) {
	                return defer.resolve(versions);
	            });
	        });
	
	        return defer.promise;
	    };
	}

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfArtifactInfo = jfArtifactInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfArtifactInfoController = (function () {
	    function jfArtifactInfoController($element, $stateParams, $state, $scope, JFrogEventBus, $timeout, User, ArtifactoryFeatures) {
	        var _this = this;
	
	        _classCallCheck(this, jfArtifactInfoController);
	
	        this.$element = $element;
	        this.stateParams = $stateParams;
	        this.state = $state;
	        this.features = ArtifactoryFeatures;
	        this.$timeout = $timeout;
	        this.user = User;
	        this.DICTIONARY = DICTIONARY.tabs;
	        this.isDropdownOpen = false;
	        this.JFrogEventBus = JFrogEventBus;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	        JFrogEventBus.registerOnScope($scope, this.EVENTS.TREE_NODE_SELECT, function (node) {
	            return _this.selectNode(node);
	        });
	        $scope.$on("ui-layout.resize", function () {
	            return _this._refreshTabs();
	        });
	    }
	
	    _createClass(jfArtifactInfoController, {
	        selectNode: {
	            value: function selectNode(node) {
	                if (node && node.data) {
	                    // wait for the element to render and calculate how many tabs should display
	                    if (!angular.equals(this.infoTabs, node.data.tabs)) {
	                        this._refreshTabs();
	                    }
	                    this.infoTabs = node.data.tabs;
	                    this._transformInfoTabs();
	                    this.currentNode = node;
	                    // if current tab exists in the new node - dispatch an event:
	                    if (_.find(this.infoTabs, { name: this.stateParams.tab }) && this.stateParams.tab !== "StashInfo") {
	                        this.JFrogEventBus.dispatch(this.EVENTS.TAB_NODE_CHANGED, node);
	                    }
	                } else {
	                    this.currentNode = null;
	                }
	            }
	        },
	        _refreshTabs: {
	            value: function _refreshTabs() {
	                this.JFrogEventBus.dispatch(this.EVENTS.TABS_REFRESH);
	            }
	        },
	        _transformInfoTabs: {
	            value: function _transformInfoTabs() {
	                var features = {
	                    Watch: "watches",
	                    Properties: "properties",
	                    Builds: "builds"
	                };
	                if (this.infoTabs) this.infoTabs.forEach(function (tab) {
	                    tab.feature = features[tab.name];
	                });
	            }
	        }
	    });
	
	    return jfArtifactInfoController;
	})();
	
	function jfArtifactInfo() {
	    return {
	        restrict: "E",
	        controller: jfArtifactInfoController,
	        controllerAs: "jfArtifactInfo",
	        templateUrl: "states/artifacts/jf_artifact_info/jf_artifact_info.html",
	        bindToController: true
	    };
	}

/***/ }),
/* 304 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	    name: "Name",
	    description: "Description",
	    artifactsCount: "Artifact Count / Size",
	    repositoryPath: "Repository Path",
	    originPath: "Source Path",
	    bintrayOrg: "Bintray Organization",
	    bintrayProduct: "Bintray Product",
	    bintrayUrl: "Bintray Link",
	    repositoryLayout: "Repository Layout",
	    repoType: "Package Type",
	    remoteRepoUrl: "Remote Repository URL",
	    created: "Created",
	    deployedBy: "Deployed By",
	    licenses: "Licenses",
	    filtered: "Filtered",
	    downloaded: "Downloads",
	    remoteDownloaded: "Remote Downloads",
	    moduleID: "Module ID",
	    size: "Size",
	    lastModified: "Last Modified",
	    lastDownloaded: "Last Downloaded",
	    lastRemoteDownloaded: "Last Downloaded Remotely",
	    compressed: "Compressed",
	    crc: "CRC",
	    modificationTime: "Modification Time",
	    path: "Path",
	    watchingSince: "Watching Since",
	    lastDownloadedBy: "Last Downloaded By",
	    lastRemoteDownloadedBy: "Last Downloaded Remotely By",
	    lastReplicationStatus: "Last Replication Status",
	    signingKeyLink: "Signing Key",
	    externalUrl: "External URL",
	    tabs: {
	        General: "General",
	        Properties: "Properties",
	        EffectivePermission: "Effective Permissions",
	        Watch: "Watchers",
	        Builds: "Builds",
	        Xray: "Xray",
	        GeneralXml: "XML View",
	        ViewSource: "View Source",
	        NuPkgInfo: "NuPkg Info",
	        PomView: "Pom View",
	        IVYXml: "Ivy View",
	        RubyGems: "RubyGems",
	        NpmInfo: "Npm Info",
	        DebianInfo: "Debian Info",
	        OpkgInfo: "Opkg Info",
	        ChefInfo: "Chef Info",
	        ComposerInfo: "Composer Info",
	        CranInfo: "CRAN Info",
	        CondaInfo: "Conda Info",
	        PyPIInfo: "PyPI Info",
	        HelmInfo: "Chart Info",
	        GoInfo: "Go Info",
	        PuppetInfo: "Puppet Info",
	        BowerInfo: "Bower Info",
	        DockerInfo: "Docker Info",
	        DockerAncestryInfo: "Docker Ancestry",
	        DockerV2Info: "Docker Info",
	        Rpm: "Rpm Info",
	        Cocoapods: "Cocoapods Info",
	        ConanInfo: "Conan Info",
	        ConanPackageInfo: "Conan Package Info",
	        StashInfo: "Stash Info"
	    },
	    nuget: {
	        authors: "Authors",
	        owners: "Owners",
	        pkgTitle: "Title",
	        tags: "Tags",
	        version: "Version",
	        requireLicenseAcceptance: "Require License Acceptance",
	        id: "ID",
	        title: "Title",
	        languages: "Languages",
	        releaseNotes: "Release Notes",
	        summary: "Summary",
	        projectUrl: "Project URL",
	        copyright: "Copyright",
	        licenseUrl: "License URL"
	
	    },
	    composer: {
	        name: "Name",
	        version: "Version",
	        authors: "Authors",
	        licenses: "Licenses",
	        type: "Type",
	        keywords: "Keywords"
	
	    },
	    chef: {
	        name: "Name",
	        version: "Version",
	        maintainer: "Maintainer",
	        sourceUrl: "Source URL",
	        license: "License"
	    },
	    conan: {
	        name: "Name",
	        version: "Version",
	        user: "User",
	        channel: "Channel",
	        reference: "Reference",
	        author: "Author",
	        license: "License",
	        url: "URL",
	        //Conan Package Info
	        os: "OS",
	        arch: "Architecture",
	        buildType: "Build Type",
	        compiler: "Compiler",
	        compilerVersion: "Compiler Version",
	        compilerRuntime: "Compiler Runtime",
	        shared: "Shared"
	    },
	    conda: {
	        name: "Name",
	        version: "Version",
	        license: "License",
	        licenseFamily: "License Family",
	        trackFeatures: "Track Features",
	        features: "Features",
	        arch: "Architecture",
	        noarch: "No Architecture (noarch)",
	        platform: "Platform",
	        build: "Build",
	        buildNumber: "Build Number",
	        timestamp: ""
	    },
	    docker: {
	        //Info:
	        imageId: "Image Id",
	        parent: "Parent Id",
	        created: "Created",
	        container: "Container",
	        dockerVersion: "Docker Version",
	        author: "Author",
	        architecture: "Architecture",
	        os: "OS",
	
	        //Config:
	        size: "Size",
	        hostname: "Hostname",
	        domainName: "DomainName",
	        user: "User",
	        memory: "Memory",
	        memorySwap: "MemorySwap",
	        cpuShares: "CpuShares",
	        cpuSet: "CpuSet",
	        attachStdin: "AttachStdin",
	        attachStdout: "AttachStdout",
	        attachStderr: "AttachStderr",
	        portSpecs: "portSpecs",
	        exposedPorts: "exposedPorts",
	        tty: "Tty",
	        openStdin: "OpenStdin",
	        stdinOnce: "StdinOnce",
	        env: "Env",
	        cmd: "Cmd",
	        image: "Image",
	        volumes: "Volumes",
	        workingDir: "WorkingDir",
	        entryPoint: "EntryPoint",
	        networkDisabled: "NetworkDisabled",
	        onBuild: "OnBuild"
	
	    },
	    dockerAncestry: {
	        size: "Virtual Size"
	    },
	    dockerV2: {
	        title: "Title",
	        digest: "Digest",
	        ports: "Ports",
	        totalSize: "Total Size",
	        volumes: "Volumes"
	    },
	    cran: {
	        name: "Name",
	        version: "Version",
	        title: "Title",
	        author: "Author",
	        maintainer: "Maintainer",
	        priority: "Priority",
	        license: "License",
	        needsCompilation: "Need Compilation",
	        path: "Path",
	        osType: "OS type",
	        licenseRestrictsUse: "License Restricts Use",
	        licenseIsFoss: "License is Foss",
	        archs: "Architectures"
	    },
	    pyPi: {
	        name: "Name",
	        author: "Author",
	        authorEmail: "Author Email",
	        homepage: "Homepage",
	        downloadUrl: "Download URL",
	        platform: "Platform",
	        version: "Version",
	        license: "License",
	        keywords: "Keywords",
	        summary: "Summary",
	        requiresPython: "Requires Python"
	    },
	    helm: {
	        name: "Name",
	        version: "Version",
	        appVersion: "Application Version",
	        keywords: "Keywords",
	        maintainers: "Maintainers",
	        sources: "Sources",
	        deprecated: "Deprecated"
	    },
	    go: {
	        name: "Name",
	        version: "Version"
	    },
	    puppet: {
	        name: "Name",
	        version: "Version",
	        license: "License",
	        keywords: "Keywords",
	        description: "Description"
	    },
	    bower: {
	        name: "Name",
	        description: "Description",
	        version: "Version",
	        license: "License",
	        keywords: "Keywords",
	        repository: "Repository"
	    },
	    rubyGems: {
	        authors: "Authors",
	        owners: "Owners",
	        description: "Description",
	        homepage: "Homepage",
	        name: "Name",
	        platform: "Platform",
	        summary: "Summary",
	        repositoryPath: "Repository Path",
	        version: "Version"
	
	    },
	    npm: {
	        name: "Name",
	        version: "Version",
	        license: "License",
	        description: "Description",
	        keywords: "Keywords",
	        repository: "Repository"
	    },
	    debian: {
	        packageName: "Name",
	        version: "Version",
	        architecture: "Architecture",
	        description: "Description",
	        section: "Section",
	        priority: "Priority",
	        maintainer: "Maintainer",
	        website: "Website",
	        size: "Size",
	        license: "License"
	    },
	    opkg: {
	        packageName: "Name",
	        version: "Version",
	        architecture: "Architecture",
	        description: "Description",
	        section: "Section",
	        priority: "Priority",
	        maintainer: "Maintainer",
	        website: "Website",
	        size: "Size",
	        license: "License"
	
	    },
	    rpm: {
	        buildDate: "Build Date",
	        epoch: "Epoch",
	        name: "Name",
	        release: "Release",
	        size: "Size",
	        summary: "Summary",
	        version: "Version",
	        buildHost: "Build Host",
	        packager: "Packager",
	        sourceRpm: "Source Rpm",
	        url: "URL",
	        vendor: "Vendor"
	
	    },
	    cocoapods: {
	        name: "Name",
	        description: "Description",
	        version: "Version",
	        license: "License",
	        keywords: "Keywords"
	    },
	    trash: {
	        deletedTime: "Deleted Time",
	        deletedBy: "Deleted By",
	        originalRepository: "Original Repository",
	        originalRepositoryType: "Original Repository Type",
	        originalPath: "Original Path"
	    }
	};

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var jfBuilds = __webpack_require__(306).jfBuilds;
	
	var jfXray = __webpack_require__(307).jfXray;
	
	var jfEffectivePermissions = __webpack_require__(308).jfEffectivePermissions;
	
	var jfWatchers = __webpack_require__(309).jfWatchers;
	
	var jfGeneral = __webpack_require__(310).jfGeneral;
	
	var jfProperties = __webpack_require__(311).jfProperties;
	
	var jfViewSource = __webpack_require__(312).jfViewSource;
	
	var jfPomView = __webpack_require__(313).jfPomView;
	
	var jfXmlView = __webpack_require__(314).jfXmlView;
	
	var jfIvyView = __webpack_require__(315).jfIvyView;
	
	var jfNuget = __webpack_require__(316).jfNuget;
	
	var jfComposer = __webpack_require__(317).jfComposer;
	
	var jfPyPi = __webpack_require__(318).jfPyPi;
	
	var jfHelm = __webpack_require__(319).jfHelm;
	
	var jfGo = __webpack_require__(320).jfGo;
	
	var jfCran = __webpack_require__(321).jfCran;
	
	var jfConda = __webpack_require__(322).jfConda;
	
	var jfPuppet = __webpack_require__(323).jfPuppet;
	
	var jfBower = __webpack_require__(324).jfBower;
	
	var jfDocker = __webpack_require__(325).jfDocker;
	
	var jfDockerAncestry = __webpack_require__(326).jfDockerAncestry;
	
	var jfDockerV2 = __webpack_require__(327).jfDockerV2;
	
	var jfRubyGems = __webpack_require__(328).jfRubyGems;
	
	var jfNpmInfo = __webpack_require__(329).jfNpmInfo;
	
	var jfRpm = __webpack_require__(330).jfRpm;
	
	var jfCocoapods = __webpack_require__(331).jfCocoapods;
	
	var jfConan = __webpack_require__(332).jfConan;
	
	var jfConanPackage = __webpack_require__(333).jfConanPackage;
	
	var jfStashInfo = __webpack_require__(334).jfStashInfo;
	
	var jfDebianInfo = __webpack_require__(335).jfDebianInfo;
	
	var jfOpkgInfo = __webpack_require__(336).jfOpkgInfo;
	
	var jfChefInfo = __webpack_require__(337).jfChefInfo;
	
	module.exports = angular.module("infoTabs", []).directive({
	    jfBuilds: jfBuilds,
	    jfXray: jfXray,
	    jfEffectivePermissions: jfEffectivePermissions,
	    jfWatchers: jfWatchers,
	    jfGeneral: jfGeneral,
	    jfProperties: jfProperties,
	    jfViewSource: jfViewSource,
	    jfPomView: jfPomView,
	    jfXmlView: jfXmlView,
	    jfIvyView: jfIvyView,
	    jfNuget: jfNuget,
	    jfComposer: jfComposer,
	    jfPyPi: jfPyPi,
	    jfHelm: jfHelm,
	    jfGo: jfGo,
	    jfCran: jfCran,
	    jfConda: jfConda,
	    jfPuppet: jfPuppet,
	    jfBower: jfBower,
	    jfConan: jfConan,
	    jfConanPackage: jfConanPackage,
	    jfDocker: jfDocker,
	    jfDockerAncestry: jfDockerAncestry,
	    jfDockerV2: jfDockerV2,
	    jfRubyGems: jfRubyGems,
	    jfNpmInfo: jfNpmInfo,
	    jfRpm: jfRpm,
	    jfCocoapods: jfCocoapods,
	    jfStashInfo: jfStashInfo,
	    jfDebianInfo: jfDebianInfo,
	    jfChefInfo: jfChefInfo,
	    jfOpkgInfo: jfOpkgInfo
	});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfBuilds = jfBuilds;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var jfBuildsController = (function () {
	    function jfBuildsController($state, JFrogGridFactory, ArtifactBuildsDao, $scope, JFrogEventBus, JFrogModal, uiGridConstants) {
	        _classCallCheck(this, jfBuildsController);
	
	        this.uiGridConstants = uiGridConstants;
	        this.producedByGridOptions = {};
	        this.usedByGridOptions = {};
	        this.$state = $state;
	        this.buildsDao = ArtifactBuildsDao.getInstance();
	        this.$scope = $scope;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.modal = JFrogModal;
	        this.mode = "ProducedBy";
	        this.builds = {};
	    }
	
	    _createClass(jfBuildsController, {
	        $onInit: {
	            value: function $onInit() {
	                this._generateViewBySwitch();
	                this._registerEvents();
	                this._createGrids();
	                this._getBuildData();
	            }
	        },
	        downloadJson: {
	            value: function downloadJson(build) {
	                var _this = this;
	
	                this.buildsDao.getJson({
	                    buildNumber: build.number,
	                    buildName: build.name,
	                    startTime: build.started
	                }).$promise.then(function (result) {
	                    _this.modal.launchCodeModal("Build #" + build.number, result.json, { name: "javascript", json: true });
	                });
	            }
	        },
	        _getBuildData: {
	            value: function _getBuildData() {
	                var _this = this;
	
	                // if the node does not have a path the build cannot be loaded
	                // this may occur in navigation to a node that does not have a path (repo node)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.buildsDao.query({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey
	                }).$promise.then(function (builds) {
	                    _this.builds = builds;
	                    _this.producedByGridOptions.setGridData(builds.producedBy);
	                    _this.usedByGridOptions.setGridData(builds.usedBy);
	                    _this._generateViewBySwitch();
	                });
	            }
	        },
	        _generateViewBySwitch: {
	            value: function _generateViewBySwitch() {
	                this.viewBySwitch = [{
	                    text: "Produced By" + (this.producedByGridOptions.data && this.producedByGridOptions.data.length ? " (" + this.builds.producedBy.length + ")" : ""),
	                    value: "ProducedBy"
	                }, {
	                    text: "Used By" + (this.usedByGridOptions.data && this.usedByGridOptions.data.length ? " (" + this.builds.usedBy.length + ")" : ""),
	                    value: "UsedBy"
	                }];
	
	                if (this.switchControl) {
	                    this.switchControl.options = this.viewBySwitch;
	                    this.switchControl.updateOptionObjects();
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode !== node) {
	                        _this.currentNode = node;
	                        self._getBuildData();
	                    }
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.producedByGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getProducedByColumns()).setRowTemplate("default").setButtons(this._getActions());
	                this.usedByGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getUsedByColumns()).setRowTemplate("default").setButtons(this._getActions());
	            }
	        },
	        _getProducedByColumns: {
	            value: function _getProducedByColumns() {
	                var columns = this._getCommonColumns();
	                columns.splice(4, 0, {
	                    displayName: "Started At",
	                    name: "Started At",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.startedString }}</a>",
	                    field: "started",
	                    type: "number"
	                });
	                return columns;
	            }
	        },
	        _getCommonColumns: {
	            value: function _getCommonColumns() {
	                return [{
	                    displayName: "Project Name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    name: "Project Name",
	                    allowGrouping: true,
	                    grouped: true,
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\" id=\"project-name\" >{{row.entity.name}}</div>" }, {
	                    displayName: "Build ID",
	                    name: "Build ID",
	                    grouped: true,
	                    allowGrouping: true,
	                    field: "number",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" ui-sref=\"builds.build_page({buildName:row.entity.name,buildNumber:row.entity.number,tab:'general',startTime:row.entity.started})\" id=\"build-id\">{{row.entity.number}}</a></div>"
	                }, {
	                    name: "Module ID",
	                    displayName: "Module ID",
	                    allowGrouping: true,
	                    grouped: true,
	                    field: "moduleID",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" ui-sref=\"builds.build_page({buildName:row.entity.name,buildNumber:row.entity.number,tab:'published',startTime:row.entity.started,moduleID:row.entity.moduleID})\" id=\"module-id\" >{{row.entity.moduleID}}</a></div>"
	                }, {
	                    displayName: "CI Server",
	                    name: "CI Server",
	                    field: "ciUrl",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\"><a class=\"jf-link\" ng-href=\"{{row.entity.ciUrl}}\" target=\"_blank\" id=\"ci-server\">{{row.entity.ciUrl}}</a></div>"
	                }];
	            }
	        },
	        _getUsedByColumns: {
	            value: function _getUsedByColumns() {
	                var columns = this._getCommonColumns();
	                columns.splice(3, 0, {
	                    displayName: "Scope",
	                    name: "Scope",
	                    allowGrouping: true,
	                    grouped: true,
	                    field: "scope"
	                });
	                return columns;
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-view",
	                    tooltip: "View Build JSON",
	                    callback: function (row) {
	                        return _this.downloadJson(row);
	                    }
	                }];
	            }
	        }
	    });
	
	    return jfBuildsController;
	})();
	
	function jfBuilds() {
	    return {
	        restrict: "EA",
	        controller: jfBuildsController,
	        controllerAs: "jfBuilds",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_builds.html"
	    };
	}

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfXray = jfXray;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var MESSAGES = _interopRequire(__webpack_require__(170));
	
	var jfXrayController = (function () {
	    function jfXrayController($scope, JFrogEventBus, ArtifactXrayDao, ArtifactActionsDao, JFrogModal, ArtifactoryFeatures, ArtifactPropertyDao) {
	        _classCallCheck(this, jfXrayController);
	
	        this.$scope = $scope;
	        this.JFrogEventBus = JFrogEventBus;
	        this.ArtifactXrayDao = ArtifactXrayDao;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.MESSAGES = MESSAGES;
	        this.modal = JFrogModal;
	        this.features = ArtifactoryFeatures;
	        this.artifactPropertyDao = ArtifactPropertyDao.getInstance();
	    }
	
	    _createClass(jfXrayController, {
	        $onInit: {
	            value: function $onInit() {
	                this._registerEvents();
	                this._getXrayData();
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode !== node) {
	                        _this.currentNode = node;
	                        self._getXrayData();
	                    }
	                });
	            }
	        },
	        _getXrayData: {
	            value: function _getXrayData() {
	                var _this = this;
	
	                if (this.features.isJCRDemo()) {
	                    console.log("Its Show Time!! ");
	                    this.artifactPropertyDao.get({
	                        path: this.currentNode.data.path,
	                        repoKey: this.currentNode.data.repoKey
	
	                    }).$promise.then(function (_ref) {
	                        var artifactProperties = _ref.artifactProperties;
	
	                        console.log("currentProperty=", artifactProperties);
	                        _this.version = _.find(artifactProperties, { name: "docker.manifest" }).value;
	                        _this.package_id = "docker://" + _.find(artifactProperties, { name: "docker.repoName" }).value;
	                        _this.showWidget = true;
	                    });
	                } else {
	                    this.ArtifactXrayDao.getData({ repoKey: this.currentNode.data.repoKey, path: this.currentNode.data.path }).$promise.then(function (response) {
	                        _this.artifactXrayData = response.data;
	                    });
	                }
	            }
	        },
	        _doAllowDownload: {
	            value: function _doAllowDownload() {
	                var _this = this;
	
	                this.modal.confirm("Download will be allowed until Xray runs another scan that generates an alert for this artifact.", "Allow download").then(function () {
	                    _this.artifactActionsDao.perform({
	                        action: "allowDownload",
	                        params: "true",
	                        repoKey: _this.currentNode.data.repoKey,
	                        path: _this.currentNode.data.path
	                    }).$promise.then(function (data) {
	                        _this._getXrayData();
	                    });
	                });
	            }
	        },
	        xrayAlertMessage: {
	            value: function xrayAlertMessage() {
	                if (this.artifactXrayData.allowBlockedArtifacts) {
	                    return this.MESSAGES.xray_tab.blocked_artifact_ignored;
	                }
	                return this.MESSAGES.xray_tab.blocked_artifact;
	            }
	        }
	    });
	
	    return jfXrayController;
	})();
	
	function jfXray() {
	    return {
	        restrict: "EA",
	        controller: jfXrayController,
	        controllerAs: "jfXray",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_xray.html"
	    };
	}

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfEffectivePermissions = jfEffectivePermissions;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var jfEffectivePermissionsController = (function () {
	    function jfEffectivePermissionsController(JFrogGridFactory, ArtifactPermissionsDao, PermissionsDao, $state, $scope, $timeout, JFrogEventBus, uiGridConstants, commonGridColumns, User, $q) {
	        _classCallCheck(this, jfEffectivePermissionsController);
	
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.$scope = $scope;
	        this.$state = $state;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.User = User;
	        this.currentTab = "Users";
	        this.userEffectivePermissionsGridOption = {};
	        this.groupEffectivePermissionsGridOption = {};
	        this.permissionTargetsGridOption = {};
	        this.permissionsDao = ArtifactPermissionsDao.getInstance();
	        this.entityPermissionsDao = PermissionsDao.getInstance();
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.currentUser = this.User.getCurrent();
	    }
	
	    _createClass(jfEffectivePermissionsController, {
	        $onInit: {
	            value: function $onInit() {
	                this._registerEvents();
	                this._createGrids();
	                this._getPermissionsData();
	            }
	        },
	        _getPermissionsData: {
	            value: function _getPermissionsData() {
	                var _this = this;
	
	                return this.permissionsDao.query({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey,
	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "principal"
	                }).$promise.then(function (data) {
	                    _this.userEffectivePermissionsGridOption.setGridData(data.userEffectivePermissions);
	                    _this.groupEffectivePermissionsGridOption.setGridData(data.groupEffectivePermissions);
	                    _this.permissionTargetsGridOption.setGridData(data.permissionTargets);
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.userEffectivePermissionsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getUserGroupGridColumns("users")).setRowTemplate("default");
	                this.groupEffectivePermissionsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getUserGroupGridColumns("groups")).setRowTemplate("default");
	                this.permissionTargetsGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this.getPermissionTargetGridColumns()).setRowTemplate("default");
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.userEffectivePermissionsGridOption.resetPagination();
	                    _this.userEffectivePermissionsGridOption.getPage();
	                    _this.groupEffectivePermissionsGridOption.resetPagination();
	                    _this.groupEffectivePermissionsGridOption.getPage();
	                    _this.permissionTargetsGridOption.resetPagination();
	                    _this.permissionTargetsGridOption.getPage();
	                    _this.$timeout(function () {
	                        _this._getPermissionsData();
	                    });
	                });
	            }
	        },
	        goToEditPrincipal: {
	            value: function goToEditPrincipal(tableType, row) {
	                var _this = this;
	
	                // Make sure the session has not timed out yet
	                this.User.loadUser(true).then(function () {
	                    // If session is expired  => go to login state
	                    if (!_this.User.getCurrent().isAdmin()) {
	                        _this.$state.go("login");
	                    }
	
	                    // If admin - go to edit page of selected principal
	                    var principal = {};
	                    var state = "admin.security." + tableType + ".edit";
	                    var principalName = tableType === "users" ? "username" : "groupname";
	                    principal[principalName] = row.principal;
	                    _this.$state.go(state, principal);
	                });
	            }
	        },
	        isCurrentUserAdmin: {
	            value: function isCurrentUserAdmin() {
	                return this.currentUser.isAdmin();
	            }
	        },
	        getUserGroupGridColumns: {
	            value: function getUserGroupGridColumns(tableType) {
	                var _this = this;
	
	                return [{
	                    name: "Principal",
	                    displayName: "Principal",
	                    field: "principal",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                        <i jf-tooltip=\"Admin Privileges\"\n                           class=\"icon pull-left\"\n                           ng-class=\"row.entity.admin ? 'icon-admin-new' : 'icon-blank'\"></i>\n                        <a href \n                           ng-if=\"grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()\"\n                           class=\"jf-link\"\n                           ng-click=\"grid.appScope.jfEffectivePermissions.goToEditPrincipal('" + tableType + "',row.entity)\">\n                            {{COL_FIELD CUSTOM_FILTERS}}\n                        </a>\n                        <span ng-if=\"!grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()\">\n                            {{COL_FIELD CUSTOM_FILTERS}}\n                        </span>\n                    </div>",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "25%"
	                }, {
	                    name: "Permission Targets",
	                    displayName: "Permission Targets",
	                    field: "permissionTargets",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.permissionTargets", "row.entity.principal", "", false, null, "row.entity.permissionTargetsCap", "row.entity.permissionTargetsCount"),
	                    asyncDataCallback: function (name) {
	                        var queryParams = {
	                            path: _this.currentNode.data.path,
	                            repoKey: _this.currentNode.data.repoKey };
	                        var pathParams = {
	                            name: name,
	                            entity_type: tableType
	                        };
	                        return _this.entityPermissionsDao.getEntityPermissions(queryParams, pathParams).$promise;
	                    },
	                    width: "33%"
	                }, {
	                    name: "Delete/Overwrite",
	                    displayName: "Delete/Overwrite",
	                    field: "permission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    width: "14%"
	                }, {
	                    name: "Deploy/Cache",
	                    displayName: "Deploy/Cache",
	                    field: "permission.deploy",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    width: "12%"
	                }, {
	                    name: "Annotate",
	                    displayName: "Annotate",
	                    field: "permission.annotate",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    width: "9%"
	                }, {
	                    name: "Read",
	                    displayName: "Read",
	                    field: "permission.read",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    width: "7%"
	                }];
	            }
	        },
	        triggerTimoutBeforeSwitch: {
	            value: function triggerTimoutBeforeSwitch() {
	                this.$timeout(function () {
	                    try {
	                        window.dispatchEvent(new Event("resize"));
	                    } catch (e) {
	                        var resizeEvent = document.createEvent("Event");
	                        window.dispatchEvent(resizeEvent);
	                    }
	                });
	            }
	        },
	        goToEditPermission: {
	            value: function goToEditPermission(row) {
	                this.$state.go("admin.security.permissions.edit", { permission: row.permissionName });
	            }
	        },
	        getPermissionTargetGridColumns: {
	            value: function getPermissionTargetGridColumns() {
	                return [{
	                    name: "Permission Target Name",
	                    displayName: "Permission Target Name",
	                    field: "permissionName",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                    <a href \n                                       class=\"jf-link\" \n                                       ng-if=\"grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()\"\n                                       ng-click=\"grid.appScope.jfEffectivePermissions.goToEditPermission(row.entity)\">\n                                        {{COL_FIELD CUSTOM_FILTERS}}\n                                    </a>\n                                    <span ng-if=\"!grid.appScope.jfEffectivePermissions.isCurrentUserAdmin()\">\n                                        {{COL_FIELD CUSTOM_FILTERS}}\n                                    </span>\n                             </div>",
	                    width: "25%"
	                }, {
	                    name: "Repositories",
	                    displayName: "Repositories",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.repoKeys", "row.entity.permissionName"),
	                    field: "repoKeysView",
	                    width: "25%"
	                }, {
	                    name: "Groups",
	                    displayName: "Groups",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.groups", "row.entity.permissionName"),
	                    field: "groupsList",
	                    width: "25%"
	
	                }, {
	                    name: "Users",
	                    displayName: "Users",
	                    cellTemplate: this.commonGridColumns.listableColumn("row.entity.users", "row.entity.permissionName"),
	                    field: "usersList",
	                    width: "25%"
	                }];
	            }
	        }
	    });
	
	    return jfEffectivePermissionsController;
	})();
	
	function jfEffectivePermissions() {
	    return {
	        restrict: "EA",
	        controller: jfEffectivePermissionsController,
	        controllerAs: "jfEffectivePermissions",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_effective_permissions.html"
	    };
	}

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfWatchers = jfWatchers;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var jfWatchersController = (function () {
	    function jfWatchersController($scope, $state, ArtifactWatchesDao, JFrogGridFactory, JFrogEventBus, $q, ArtifactoryStorage) {
	        _classCallCheck(this, jfWatchersController);
	
	        this.$scope = $scope;
	        this.$state = $state;
	        this.watchersGridOption = {};
	        this.artifactWatchesDao = ArtifactWatchesDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.$q = $q;
	    }
	
	    _createClass(jfWatchersController, {
	        $onInit: {
	            value: function $onInit() {
	                this._createGrid();
	                this._getWatchesData();
	                this._registerEvents();
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getWatchesData();
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, [EVENTS.ACTION_WATCH, EVENTS.ACTION_UNWATCH], function () {
	                    _this._getWatchesData();
	                });
	            }
	        },
	        _deleteWatches: {
	            value: function _deleteWatches(watches) {
	                var _this = this;
	
	                var data = watches.map(function (watch) {
	                    var selectedWachers = {
	                        name: watch.watcherName,
	                        repoKey: watch.watchConfigureOn.split(":")[0],
	                        path: watch.watchConfigureOn.split(":")[1]
	                    };
	                    return selectedWachers;
	                });
	                var json = { watches: data };
	
	                return this.artifactWatchesDao["delete"](json).$promise.then(function () {
	                    _this.JFrogEventBus.dispatch(EVENTS.ACTION_UNWATCH, _this.currentNode);
	                    _this._getWatchesData();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;
	
	                var batchActions = [{
	                    callback: function (watches) {
	                        return _this._deleteWatches(watches);
	                    },
	                    visibleWhen: function () {
	                        return _this.currentNode && _this.currentNode.data && _this.currentNode.data.getRoot().repoType !== "virtual";
	                    },
	                    name: "Delete",
	                    icon: "clear"
	                }];
	
	                this.watchersGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setBatchActions(batchActions).setButtons(this._getActions());
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Watcher Name",
	                    displayName: "Watcher Name",
	                    field: "watcherName",
	                    width: "20%"
	                }, {
	                    name: "Watching Since",
	                    displayName: "Watching Since",
	                    field: "watchingSince",
	                    width: "30%"
	                }, {
	                    name: "Watch Configured On",
	                    displayName: "Watch Configured On",
	                    field: "watchConfigureOn",
	                    width: "50%"
	                }];
	            }
	        },
	        showInTree: {
	            value: function showInTree(row) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                var repoKey = row.watchConfigureOn.split(":")[0];
	                var path = row.watchConfigureOn.split(":")[1];
	                var artifactPath = repoKey + "/" + path;
	                var archivePath = "";
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    browser: browser,
	                    artifact: artifactPath
	                });
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-show-in-tree",
	                    tooltip: "Show In Tree",
	                    callback: function (row) {
	                        return _this.showInTree(row);
	                    }
	                }, {
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (watch) {
	                        return _this._deleteWatches([watch]);
	                    },
	                    visibleWhen: function () {
	                        return _this.currentNode && _this.currentNode.data && _this.currentNode.data.getRoot().repoType !== "virtual";
	                    } }];
	            }
	        },
	        _getWatchesData: {
	            value: function _getWatchesData() {
	                var _this = this;
	
	                var self = this;
	                this.artifactWatchesDao.query({
	                    path: self.currentNode.data.path,
	                    repoKey: self.currentNode.data.repoKey
	                }).$promise.then(function (watchers) {
	                    _this.watchers = watchers;
	                    _this.watchersGridOption.setGridData(watchers);
	                });
	            }
	        }
	    });
	
	    return jfWatchersController;
	})();
	
	function jfWatchers() {
	    return {
	        restrict: "EA",
	        scope: {
	            currentNode: "="
	        },
	        controller: jfWatchersController,
	        controllerAs: "jfWatchers",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_watchers.html"
	    };
	}

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfGeneral = jfGeneral;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var jfGeneralController = (function () {
	    function jfGeneralController($state, $scope, ArtifactGeneralDao, JFrogNotifications, ArtifactLicensesDao, ChecksumsDao, ArtifactActionsDao, ArtifactoryFeatures, FilteredResourceDao, JFrogEventBus, JFrogModal, DependencyDeclarationDao, $compile, User, FooterDao, ArtifactoryStorage) {
	        _classCallCheck(this, jfGeneralController);
	
	        this.generalData = {
	            dependencyDeclaration: []
	        };
	        this.$state = $state;
	        this.$scope = $scope;
	        this.artifactLicensesDao = ArtifactLicensesDao;
	        this.DICTIONARY = DICTIONARY;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.TOOLTIP = TOOLTIP.artifacts.browse;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.artifactGeneralDao = ArtifactGeneralDao;
	        this.filteredResourceDao = FilteredResourceDao;
	        this.dependencyDeclarationDao = DependencyDeclarationDao;
	        this.modal = JFrogModal;
	        this.footerDao = FooterDao;
	        this.currentDeclaration = "Maven";
	        this.JFrogEventBus = JFrogEventBus;
	        this.features = ArtifactoryFeatures;
	        this.$compile = $compile;
	        this.userService = User;
	        this.SearchForArchiveLicense = "Search Archive License File";
	        this.ChecksumsDao = ChecksumsDao;
	        this.editorOptions = {
	            lineNumbers: true,
	            readOnly: "nocursor",
	            lineWrapping: true,
	            height: "auto",
	            mode: "links",
	            mimeType: "text/xml"
	        };
	        this.artifactoryStorage = ArtifactoryStorage;
	    }
	
	    _createClass(jfGeneralController, {
	        $onInit: {
	            value: function $onInit() {
	                this._getGeneralData();
	                this._registerEvents();
	                this._initModalScope();
	                this.isInVirtual();
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.showArtifactsCount = false;
	                        _this.calculatingArtifactsCount = false;
	                        _this.finishedArtifactCount = false;
	                        _this.currentNode = node;
	                        _this._getGeneralData();
	                    }
	                });
	                this.JFrogEventBus.registerOnScope(this.$scope, [EVENTS.ACTION_WATCH, EVENTS.ACTION_UNWATCH], function () {
	                    _this._getGeneralData();
	                });
	            }
	        },
	        _initModalScope: {
	            value: function _initModalScope() {
	                var _this = this;
	
	                this.generalScope = this.$scope.$new();
	                this.generalScope.closeModal = function () {
	                    return _this.modalInstance.close();
	                };
	                this.generalScope.saveLicenses = function (licenses) {
	                    return _this.saveLicenses(licenses);
	                };
	                this.generalScope.attachLicenses = function () {
	                    return _this.attachLicenses();
	                };
	            }
	        },
	        getGeneralTab: {
	            value: function getGeneralTab() {
	                return _.find(this.currentNode.data.tabs, { name: "General" });
	            }
	        },
	        _getGeneralData: {
	            value: function _getGeneralData() {
	                var _this = this;
	
	                this.sha256Calculated = false;
	
	                var repoData = this.currentNode.data;
	                var generalTab = this.getGeneralTab();
	                if (generalTab && generalTab.info) {
	                    // If general data already exists on the node (for archive children)
	                    this.generalData = generalTab;
	                } else if (repoData.className === "TreeNode") {
	                    this.getGeneralTabPromise().then(function (response) {
	
	                        if (response.type == "file" && repoData && repoData.fileType == "archive") {
	                            response.fileType = "archive";
	                        }
	                        if (response.type && response.type === "virtualRemoteFile" && repoData && repoData.getRoot().repoType === "virtual") {
	                            response.info = _this.sortedInsertionToOject(response.info, response.originPath, "originPath", "repositoryPath");
	                        }
	
	                        if (response.info.repoType === "YUM") {
	                            response.info.repoType = "RPM";
	                        } else if (response.info.repoType === "Go") {
	                            response.info.repoType = "golang";
	                        }
	
	                        _this.showArtifactsCount = _this.artifactsCountEnabled();
	                        if (response.info.externalUrl) {
	                            response.info = _this._moveObjectElement(response.info, "externalUrl", "repositoryPath");
	                        }
	                        _this.generalData = response;
	                        if (_this.generalData.dependencyDeclaration) {
	                            _this.selectDeclaration(_this.currentDeclaration);
	                        }
	                        if (_this.generalData.bintrayInfoEnabled) {
	                            _this.loadPackageDescription();
	                        }
	
	                        _this.trimVirtualAssociations();
	
	                        _this.userService.canAnnotate(_this.currentNode.data.repoKey, _this.currentNode.data.path).then(function (response) {
	                            _this.canAnnotate = response.data;
	                        });
	                    });
	                }
	            }
	        },
	        sortedInsertionToOject: {
	            value: function sortedInsertionToOject(unsortedObject, newFieldValue, newFieldName, fieldBefore) {
	                if (!newFieldValue) {
	                    return unsortedObject;
	                }
	                var sortedObject = {};
	                for (var field in unsortedObject) {
	                    sortedObject[field] = unsortedObject[field];
	                    if (field === fieldBefore) {
	                        sortedObject[newFieldName] = newFieldValue;
	                    }
	                }
	                return sortedObject;
	            }
	        },
	        shouldDisplayInfoEntry: {
	            value: function shouldDisplayInfoEntry(key) {
	                return key != "licenses" && key != "filtered" && key != "smartRepo" && key != "showFilteredResourceCheckBox" && key != "artifactsCount" && key != "artifactsCount" && key != "currentlyDownloadable" && key != "bintrayUrl" && key != "originPath";
	            }
	        },
	        goToOriginPath: {
	            value: function goToOriginPath(value) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") browser = "tree";
	                var path = value;
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    artifact: path,
	                    browser: browser
	                });
	            }
	        },
	        getGeneralTabPromise: {
	            value: function getGeneralTabPromise() {
	                var newPath = this.currentNode.data.type === "folder" && this.currentNode.data.path.substr(-1) != "/" ? this.currentNode.data.path + "/" : this.currentNode.data.path;
	                return this.artifactGeneralDao.fetch({
	                    type: this.currentNode.data.type,
	                    repoKey: this.currentNode.data.repoKey,
	                    path: newPath
	                }).$promise;
	            }
	        },
	        trimVirtualAssociations: {
	            value: function trimVirtualAssociations() {
	                var _this = this;
	
	                var LIMIT = 5;
	                var fields = ["virtualRepositories", "includedRepositories"];
	                fields.forEach(function (f) {
	                    if (_this.generalData[f] && _this.generalData[f].length > LIMIT) {
	                        (function () {
	                            var more = _this.generalData[f].length - (LIMIT - 1);
	                            _this.generalData["all" + _.capitalize(f)] = _.cloneDeep(_this.generalData[f]);
	                            _this.generalData[f] = _this.generalData["all" + _.capitalize(f)].slice(0, LIMIT - 1);
	                            var THIS = _this;
	                            _this.generalData[f].push({
	                                showAll: true,
	                                text: "(Show " + more + " more)",
	                                action: "show",
	                                toggle: function toggle() {
	                                    if (this.action === "show") {
	                                        this.action = "hide";
	                                        this.text = "(Show Less)";
	                                        THIS.generalData[f] = _.cloneDeep(THIS.generalData["all" + _.capitalize(f)]);
	                                        THIS.generalData[f].push(this);
	                                    } else {
	                                        this.action = "show";
	                                        this.text = "(Show " + more + " more)";
	                                        THIS.generalData[f] = THIS.generalData["all" + _.capitalize(f)].slice(0, LIMIT - 1);
	                                        THIS.generalData[f].push(this);
	                                    }
	                                }
	                            });
	                        })();
	                    }
	                });
	            }
	        },
	        calculateArtifactsCount: {
	            value: function calculateArtifactsCount() {
	                var _this = this;
	
	                this.calculatingArtifactsCount = true;
	                var _generalData$info = this.generalData.info;
	                var name = _generalData$info.name;
	                var repositoryPath = _generalData$info.repositoryPath;
	
	                this.artifactGeneralDao.artifactsCount({ name: name, repositoryPath: repositoryPath }).$promise.then(function (response) {
	                    _this.generalData.info.artifactsCount = response.artifactsCount;
	                })["finally"](function () {
	                    _this.calculatingArtifactsCount = false;
	                    _this.finishedArtifactCount = true;
	                });
	            }
	        },
	        calculateArtifactsCountAndSize: {
	            value: function calculateArtifactsCountAndSize() {
	                var _this = this;
	
	                this.calculatingArtifactsCount = true;
	                var _generalData$info = this.generalData.info;
	                var name = _generalData$info.name;
	                var repositoryPath = _generalData$info.repositoryPath;
	
	                this.artifactGeneralDao.artifactsCount({ name: name, repositoryPath: repositoryPath }).$promise.then(function (response) {
	                    _this.generalData.info.artifactsCount = "" + response.artifactsCount + " / " + response.artifactSize;
	                })["finally"](function () {
	                    _this.calculatingArtifactsCount = false;
	                    _this.finishedArtifactCount = true;
	                });
	            }
	        },
	        artifactsCountEnabled: {
	            value: function artifactsCountEnabled() {
	                return _.includes(["local", "cached"], this.currentNode.data.repoType);
	            }
	        },
	        onFilteredResourceCB: {
	            value: function onFilteredResourceCB() {
	                var payload = { repoKey: this.currentNode.data.repoKey, path: this.currentNode.data.path };
	                this.filteredResourceDao.setFiltered({ setFiltered: this.generalData.info.filtered }, payload).$promise.then(function (res) {});
	            }
	        },
	        fixChecksum: {
	            value: function fixChecksum() {
	                var _this = this;
	
	                this.ChecksumsDao.fix({}, { repoKey: this.currentNode.data.repoKey, path: this.currentNode.data.path }).$promise.then(function (data) {
	                    _this._getGeneralData();
	                });
	            }
	        },
	        isDeclarationSelected: {
	            value: function isDeclarationSelected(item) {
	                return this.currentDeclaration == item;
	            }
	        },
	        selectDeclaration: {
	            value: function selectDeclaration(item) {
	                var self = this;
	                this.currentDeclaration = item;
	                this.dependencyDeclarationDao.get({
	                    buildtool: item.toLowerCase(),
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	
	                }).$promise.then(function (data) {
	                    if (data.dependencyData) {
	                        self.generalData.dependencyDeclaration.dependencyData = data.dependencyData;
	                    }
	                });
	            }
	        },
	        loadPackageDescription: {
	            value: function loadPackageDescription() {
	                var _this = this;
	
	                this.bintrayData = {};
	                this.artifactGeneralDao.bintray({ sha1: this.generalData.checksums.sha1Value }).$promise.then(function (data) {
	                    if (!data.name && !data.errorMessage) _this.generalData.bintrayInfoEnabled = false;else _this.bintrayData = data;
	                });
	            }
	        },
	        openAddLicenseModal: {
	
	            /**Licenses actions and display
	             * saving all default licenses on the generalScope for modal display
	             * **/
	
	            value: function openAddLicenseModal() {
	                this.generalScope.modalTitle = "Add Artifactory License Property";
	                this.modalInstance = this.modal.launchModal("add_license_modal", this.generalScope);
	            }
	        },
	        openFoundLicenseModal: {
	            value: function openFoundLicenseModal() {
	
	                var associatedLicenses = this.generalData.info.licenses[0].name === "Not Found" ? [] : _.map(this.generalData.info.licenses, function (lic) {
	                    return lic.name;
	                });
	
	                this.generalScope.foundLicenses = _.difference(this.generalScope.selectedLicenses, associatedLicenses);
	
	                if (this.generalScope.foundLicenses.length === 0) {
	                    this.artifactoryNotifications.create({ info: "Found licenses are already attached" });
	                } else {
	                    this.generalScope.modalTitle = this.generalScope.foundLicenses.length + " " + (this.generalScope.foundLicenses.length < 2 ? " License" : " Licenses") + " Found";
	                    this.modalInstance = this.modal.launchModal("found_license_modal", this.generalScope);
	                }
	            }
	        },
	        editLicenses: {
	            value: function editLicenses(scan) {
	                var _this = this;
	
	                this.artifactLicensesDao.getLicenses().$promise.then(function (licenses) {
	                    _this.generalScope.licenses = _.map(licenses, function (rec) {
	                        return rec.name;
	                    });
	                    _this.generalScope.selectedLicenses = _.filter(_this.generalData.info.licenses, function (lic) {
	                        return lic.name !== "Not Found";
	                    });
	                    _this.openAddLicenseModal();
	                });
	            }
	        },
	        saveLicenses: {
	            value: function saveLicenses(selectedLicenses) {
	                var _this = this;
	
	                this.artifactLicensesDao.setLicenses({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }, selectedLicenses).$promise.then(function (result) {
	                    _this._getGeneralData();
	                    _this.modalInstance.close();
	                });
	            }
	        },
	        attachLicenses: {
	            value: function attachLicenses() {
	                var _this = this;
	
	                this.artifactLicensesDao.setLicenses({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }, this.generalScope.selectedLicenses).$promise.then(function (result) {
	                    _this._getGeneralData();
	                    _this.modalInstance.close();
	                });
	            }
	        },
	        deleteLicenses: {
	            value: function deleteLicenses() {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to delete the license information attached to " + this.generalData.info.name + "?").then(function () {
	                    _this.saveLicenses([]);
	                });
	            }
	        },
	        scanForLicenses: {
	            value: function scanForLicenses() {
	                var _this = this;
	
	                this.artifactLicensesDao.scanArtifact({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (result) {
	                    if (result.data.length > 0) {
	                        _this.generalScope.selectedLicenses = _.map(result.data, function (rec) {
	                            return rec.name;
	                        });
	
	                        _this.openFoundLicenseModal();
	                    } else {
	                        _this.artifactoryNotifications.create({ info: "No licenses found in scan" });
	                    }
	                });
	            }
	        },
	        searchForArchiveFile: {
	            value: function searchForArchiveFile() {
	                var _this = this;
	
	                this.artifactLicensesDao.getArchiveLicenseFile({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.modal.launchCodeModal("License File", data.data);
	                }, function () {
	                    _this.SearchForArchiveLicense = "(No archive license file found)";
	                    _this.noArchiveLicense = true;
	                });
	            }
	        },
	        queryCodeCenter: {
	            value: function queryCodeCenter() {
	                var _this = this;
	
	                this.artifactLicensesDao.queryCodeCenter({
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (result) {
	                    _this._getGeneralData();
	                });
	            }
	        },
	        getFullFilePath: {
	            value: function getFullFilePath() {
	                /*
	                 if (!window.location.origin) { // IE compatibility
	                 window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
	                 }
	                 return window.location.origin+this.currentNode.data.actualDownloadPath;
	                 */
	                return this.currentNode.data.actualDownloadPath;
	            }
	        },
	        getSha256: {
	            value: function getSha256() {
	                var _this = this;
	
	                if (this.features.isOss() || !this.canCalculateSha256()) {
	                    return;
	                }this.sha256Calculated = true;
	                this.calculatingSha256 = true;
	                this.artifactActionsDao.getSha256({ $spinner_domain: "sha256" }, {
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (result) {
	                    // Instead of calling this._getGeneralData() and refreshing the entire tab , just replace the SHA-256
	                    _this.getGeneralTabPromise().then(function (response) {
	                        var generalTab = response;
	                        _this.generalData.checksums.sha2 = generalTab.checksums.sha2;
	                        _this.calculatingSha256 = false;
	                    });
	                });
	            }
	        },
	        canCalculateSha256: {
	            value: function canCalculateSha256() {
	                return this.canAnnotate && this.userService.currentUser.getCanDeploy() && !this.isInVirtual();
	            }
	        },
	        isInVirtual: {
	            value: function isInVirtual() {
	                return this.currentNode && this.currentNode.data && this.currentNode.data.getRoot && this.currentNode.data.getRoot().repoType === "virtual";
	            }
	        },
	        getChecksumKey: {
	            value: function getChecksumKey(keyval) {
	                return keyval.split(":")[0];
	            }
	        },
	        getChecksumVal: {
	            value: function getChecksumVal(keyval) {
	                var splitted = keyval.split(":");
	                splitted.shift();
	                return splitted.join(":");
	            }
	        },
	        isTrashcanEnabled: {
	            value: function isTrashcanEnabled() {
	                return !this.footerDao.getInfo().trashDisabled;
	            }
	        },
	        isTrashcan: {
	            value: function isTrashcan() {
	                return this.currentNode.data && this.currentNode.data.isTrashcan && this.currentNode.data.isTrashcan();
	            }
	        },
	        isInTrashcan: {
	            value: function isInTrashcan() {
	                return this.currentNode.data && this.currentNode.data.isInTrashcan && this.currentNode.data.isInTrashcan();
	            }
	        },
	        isDistRepo: {
	            value: function isDistRepo() {
	                return this.currentNode.data && this.currentNode.data.repoType === "distribution";
	            }
	        },
	        _moveObjectElement: {
	            value: function _moveObjectElement(obj, currentKey, afterKey) {
	                var result = {};
	                var val = obj[currentKey];
	                delete obj[currentKey];
	                var next = -1;
	                var i = 0;
	                if (typeof afterKey == "undefined" || afterKey == null) afterKey = "";
	                $.each(obj, function (k, v) {
	                    if (afterKey == "" && i == 0 || next == 1) {
	                        result[currentKey] = val;
	                        next = 0;
	                    }
	                    if (k == afterKey) {
	                        next = 1;
	                    }
	                    result[k] = v;
	                    ++i;
	                });
	                if (next == 1) {
	                    result[currentKey] = val;
	                }
	                if (next !== -1) {
	                    return result;
	                } else {
	                    return obj;
	                }
	            }
	        },
	        isCurrentNodeAFolderInArchive: {
	            value: function isCurrentNodeAFolderInArchive() {
	                var isFolder = this.currentNode.data.folder;
	                var isInArchive = !!this.currentNode.data.archivePath;
	                return isFolder && isInArchive;
	            }
	        }
	    });
	
	    return jfGeneralController;
	})();
	
	function jfGeneral() {
	    return {
	        restrict: "EA",
	        scope: {
	            currentNode: "="
	        },
	        controller: jfGeneralController,
	        controllerAs: "jfGeneral",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_general.html"
	    };
	}
	
	//console.log(res);

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfProperties = jfProperties;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var KEYS = _interopRequire(__webpack_require__(295));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var jfPropertiesController = (function () {
	    function jfPropertiesController($q, $scope, JFrogGridFactory, ArtifactPropertyDao, JFrogEventBus, JFrogModal, PredefineDao, RepoPropertySetDao, JFrogNotifications, $timeout, User, GoogleAnalytics) {
	        var _this = this;
	
	        _classCallCheck(this, jfPropertiesController);
	
	        this.propertyGridOption = {};
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.user = User;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.artifactPropertyDao = ArtifactPropertyDao.getInstance();
	        this.predefineDao = PredefineDao.getInstance();
	        this.repoPropertySetDao = RepoPropertySetDao.getInstance();
	        this.modal = JFrogModal;
	        this.$scope = $scope;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.propertyTypeKeys = KEYS.PROPERTY_TYPE;
	        this.propertyType = "Property";
	        this.propertiesOptions = [];
	        this.repoPropertyRecursive = { recursive: false };
	        this.TOOLTIP = TOOLTIP.artifacts.browse;
	
	        JFrogEventBus.registerOnScope($scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	            _this.currentNode = node;
	            _this.clearFields();
	            _this._getPropertiesData();
	        });
	
	        /**
	         *  config selectize inputs
	         *  **/
	        this.propertySetMultiValuesConfig = {
	            sortField: "text",
	            maxItems: null,
	            plugins: ["remove_button"]
	        };
	        this.propertySetSingleValueConfig = {
	            sortField: "text",
	            maxItems: 1
	        };
	        this.propertySetAnyValueConfig = {
	            sortField: "text",
	            maxItems: 1,
	            create: true,
	            createOnBlur: true,
	            persist: true
	        };
	    }
	
	    _createClass(jfPropertiesController, {
	        $onInit: {
	            value: function $onInit() {
	                this._createGrid();
	                this._getPropertiesData();
	                this._createModalScope();
	            }
	        },
	        deleteSelectedProperties: {
	
	            /**
	             * delete Selected properties by batch
	             * **/
	
	            value: function deleteSelectedProperties(recursive) {
	                var _this = this;
	
	                var self = this;
	                var rowSelection = this.propertyGridOption.api.selection;
	                var selectedProperties = rowSelection.getSelectedRows();
	                var confirmMessage = "Are you sure you wish to delete " + selectedProperties.length;
	                confirmMessage += selectedProperties.length > 1 ? " properties?" : " property?";
	
	                this.modal.confirm(confirmMessage).then(function () {
	                    rowSelection.clearSelectedRows();
	                    var propertiesToDelete = selectedProperties.map(function (property) {
	                        return {
	                            name: property.name,
	                            path: self.currentNode.data.path,
	                            repoKey: self.currentNode.data.repoKey,
	                            recursive: recursive
	                        };
	                    });
	                    _this.artifactPropertyDao.deleteBatch({ properties: propertiesToDelete }).$promise.then(function () {
	                        _this._getPropertiesData();
	                    });
	                });
	            }
	        },
	        deleteSingleProperty: {
	
	            /**
	             * delete single proerty
	             * ***/
	
	            value: function deleteSingleProperty(row, recursive) {
	                var _this = this;
	
	                var json = { properties: [{
	                        name: row.name,
	                        path: this.currentNode.data.path,
	                        repoKey: this.currentNode.data.repoKey,
	                        recursive: recursive
	                    }]
	                };
	
	                this.modal.confirm("Are you sure you wish to delete this property?").then(function () {
	                    _this.artifactPropertyDao.deleteBatch(json).$promise.then(function () {
	                        _this._getPropertiesData();
	                    });
	                });
	            }
	        },
	        clearFields: {
	            value: function clearFields() {
	                if (this.repoPropertySetSelected) {
	                    if (this.repoPropertySetSelected.parent) {
	                        delete this.repoPropertySetSelected.parent;
	                    }
	                    if (this.repoPropertySetSelected.property) {
	                        delete this.repoPropertySetSelected.property;
	                    }
	                    if (this.repoPropertySetSelected.value) {
	                        delete this.repoPropertySetSelected.value;
	                    }
	                }
	            }
	        },
	        isSelected: {
	            value: function isSelected(propertyType) {
	                return this.propertyType == propertyType;
	            }
	        },
	        setProperty: {
	            value: function setProperty(propertyType) {
	                this.propertyType = propertyType;
	            }
	        },
	        addPropertySet: {
	
	            /**
	             * add Property Set to list
	             * **/
	
	            value: function addPropertySet() {
	                this._trackAddPropertyEvent("Add property set");
	                if (this.repoPropertySetSelected) {
	                    this._savePropertySetValues(this.repoPropertySetSelected);
	                }
	                this.repoPropertySetSelected = "";
	                this.propertyValuesOptions = [];
	            }
	        },
	        addProperty: {
	
	            /**
	             * add single property to list
	             * **/
	
	            value: function addProperty() {
	                this._trackAddPropertyEvent("Add property");
	                var objProperty = this._createNewRepoObject(this.repoPropertySelected.name);
	                delete objProperty.text;
	                delete objProperty.value;
	                this._savePropertyValues(objProperty);
	
	                this.repoPropertySelected.name = "";
	                this.repoPropertySelected.value = "";
	            }
	        },
	        _trackAddPropertyEvent: {
	            value: function _trackAddPropertyEvent(type) {
	                this.GoogleAnalytics.trackEvent("Artifacts", "Tab - Property", type, null, this.currentNode.data.repoPkgType, this.currentNode.data.repoType);
	            }
	        },
	        getPropertySetValues: {
	
	            /**
	             * pouplited values to input propertyValuesOptions
	             *
	             * **/
	
	            value: function getPropertySetValues() {
	                var _this = this;
	
	                if (this.repoPropertySetSelected) {
	                    this.predefineDao.get({
	                        name: this.repoPropertySetSelected.parent.name + "." + this.repoPropertySetSelected.property.name,
	                        path: this.currentNode.data.path,
	                        repoKey: this.currentNode.data.repoKey,
	                        recursive: this.recursive
	                    }).$promise.then(function (predefineValues) {
	
	                        _this._getPropertySetPreDefinedValues(predefineValues);
	                    });
	                }
	            }
	        },
	        isCurrentPropertyType: {
	            value: function isCurrentPropertyType(type) {
	                if (!this.repoPropertySetSelected && type === "ANY_VALUE") {
	                    return true;
	                } else if (this.repoPropertySetSelected) {
	                    if (!this.repoPropertySetSelected.propertyType && type === "ANY_VALUE") {
	                        return true;
	                    }
	                    return this.propertyTypeKeys[this.repoPropertySetSelected.propertyType] === this.propertyTypeKeys[type];
	                }
	            }
	        },
	        setModalData: {
	            value: function setModalData(selectedProperty, predefineValues) {
	                var _this = this;
	
	                this.modalScope.property = selectedProperty;
	                this.modalScope.property.predefineValues = predefineValues ? predefineValues.predefinedValues : null;
	                this.modalScope.property.selectedValues = [];
	                this.modalScope.property.modalTitle = "Add New '" + selectedProperty.property.name + "' Property";
	                this.modalScope.save = function (property) {
	                    return _this._savePropertySetValues(property);
	                };
	                this._propertyFormModal();
	            }
	        },
	        editSelectedProperty: {
	            value: function editSelectedProperty(row) {
	                var _this = this;
	
	                var selectedProperty = row;
	
	                this.artifactPropertyDao.get({
	                    name: selectedProperty.name,
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey
	
	                }).$promise.then(function (currentProperty) {
	                    //console.log('currentProperty=',currentProperty);
	                    _this.modalScope.property = currentProperty;
	                    _this.modalScope.property.selectedValues = _this.modalScope.property.propertyType !== "MULTI_SELECT" && _.isArray(_this.modalScope.property.selectedValues) ? _this.modalScope.property.selectedValues.join(";") : _this.modalScope.property.selectedValues;
	                    _this.modalScope.selectizeConfig = {
	                        create: currentProperty.propertyType === "ANY_VALUE",
	                        maxItems: 1
	                    };
	                    _this.modalScope.property.options = currentProperty.predefineValues && currentProperty.predefineValues.slice(0);
	                    //                this.modalScope.property.multiValue = currentProperty.propertyType && currentProperty.propertyType === 'MULTI_SELECT';
	                    _this.modalScope.property.modalTitle = "Edit '" + selectedProperty.name + "' Property";
	                    _this.modalScope.property.name = selectedProperty.name;
	                    _this.modalScope.save = function (property) {
	                        return _this._updatePropertySetValues(property);
	                    };
	                    _this._propertyFormModal();
	                });
	            }
	        },
	        _createNewRepoObject: {
	
	            /**
	             * build defulat template proerty
	             * **/
	
	            value: function _createNewRepoObject(repoName) {
	                return {
	                    multiValue: false,
	                    property: { name: repoName },
	                    text: repoName,
	                    value: repoName
	                };
	            }
	        },
	        _getPropertiesData: {
	
	            /**
	             * popluted grid data and property Set list name
	             * **/
	
	            value: function _getPropertiesData() {
	                var _this = this;
	
	                this.user.canAnnotate(this.currentNode.data.repoKey, this.currentNode.data.path).then(function (response) {
	                    _this.canAnnotate = response.data;
	                });
	                this.artifactPropertyDao.query({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey
	                }).$promise.then(function (properties) {
	
	                    _this.properties = properties.artifactProperties ? properties.artifactProperties.map(_this._formatToArray) : [];
	                    _this._createDisplayValues();
	                    _this.propertyGridOption.setGridData(_this.properties);
	
	                    _this._getPropertySetData();
	                });
	            }
	        },
	        _getPropertySetData: {
	            value: function _getPropertySetData() {
	                var _this = this;
	
	                this.repoPropertySetDao.query({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey
	                }).$promise.then(function (_propertyOptionList) {
	                    var propertyOptionList = [];
	                    _propertyOptionList.forEach(function (propertyOption) {
	                        propertyOption.value = propertyOption.property.name;
	                        propertyOption.text = propertyOption.property.name;
	                        propertyOptionList.push(propertyOption);
	                    });
	                    _this.propertiesOptions = propertyOptionList;
	                });
	            }
	        },
	        _createModalScope: {
	            value: function _createModalScope() {
	                var _this = this;
	
	                this.modalScope = this.$scope.$new();
	                this.modalScope.closeModal = function () {
	                    return _this.modalInstance.close();
	                };
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.propertyGridOption = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setButtons(this._getActions()).setBatchActions(this._getBatchActions());
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteSingleProperty(row, false);
	                    },
	                    visibleWhen: function () {
	                        return _this.canAnnotate && (_this.currentNode.data.type == "folder" || _this.currentNode.data.type == "repository");
	                    }
	                }, {
	                    icon: "icon icon-delete-versions",
	                    tooltip: "Delete Recursively",
	                    callback: function (row) {
	                        return _this.deleteSingleProperty(row, true);
	                    },
	                    visibleWhen: function () {
	                        return _this.canAnnotate && (_this.currentNode.data.type == "folder" || _this.currentNode.data.type == "repository");
	                    }
	                }];
	            }
	        },
	        _getBatchActions: {
	            value: function _getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function () {
	                        return _this.deleteSelectedProperties(false);
	                    },
	                    visibleWhen: function () {
	                        return _this.canAnnotate && _this.currentNode && _this.currentNode.data && _this.currentNode.data.getRoot().repoType !== "virtual";
	                    }
	                }, {
	                    icon: "delete-recursive",
	                    name: "Delete Recursively",
	                    callback: function () {
	                        return _this.deleteSelectedProperties(true);
	                    },
	                    visibleWhen: function () {
	                        return _this.canAnnotate && (_this.currentNode.data.type == "folder" || _this.currentNode.data.type == "repository") && _this.currentNode.data.getRoot().repoType !== "virtual";
	                    }
	                }];
	            }
	        },
	        _propertyFormModal: {
	            value: function _propertyFormModal() {
	                this.modalInstance = this.modal.launchModal("property_modal", this.modalScope, this.modalScope.property.propertyType != "MULTI_SELECT" ? "sm" : "lg");
	            }
	        },
	        _savePropertyValues: {
	            value: function _savePropertyValues(property) {
	                var _this = this;
	
	                if (this.repoPropertySelected.value.indexOf(";") >= 0) {
	                    property.selectedValues = _.filter(this.repoPropertySelected.value.split(";"), function (val) {
	                        return !!val;
	                    });
	                } else {
	                    property.selectedValues = [];
	                    property.selectedValues.push(this.repoPropertySelected.value);
	                }
	                this.artifactPropertyDao.save({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey,
	                    recursive: this.repoPropertyRecursive.recursive
	                }, property).$promise.then(function () {
	                    _this._getPropertiesData();
	                });
	            }
	        },
	        _savePropertySetValues: {
	            value: function _savePropertySetValues(property) {
	                var _this = this;
	
	                if (property.propertyType === "MULTI_SELECT") {
	                    this._addValuesToMulti(property, this.repoPropertySetSelected.value);
	                } else {
	                    property.selectedValues = this.repoPropertySetSelected.value;
	                }
	
	                if (!property.multiValue && !_.isArray(property.selectedValues)) {
	                    var selectedValuesToArray = angular.copy(property.selectedValues);
	                    property.selectedValues = [];
	                    property.selectedValues.push(selectedValuesToArray);
	                }
	
	                this.artifactPropertyDao.save({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey,
	                    recursive: this.repoPropertyRecursive.recursive
	                }, property).$promise.then(function () {
	                    _this._getPropertiesData();
	                });
	            }
	        },
	        _addValuesToMulti: {
	            value: function _addValuesToMulti(property, addedValues) {
	                //console.log(property);
	                var theProperty = _.find(this.properties, { name: property.parent.name + "." + property.property.name });
	                if (theProperty) {
	                    property.selectedValues = theProperty.value.concat(addedValues);
	                } else {
	                    property.selectedValues = addedValues;
	                }
	            }
	        },
	        _updatePropertySetValues: {
	            value: function _updatePropertySetValues(property) {
	                var _this = this;
	
	                if (property.selectedValues.indexOf(";") >= 0) property.selectedValues = _.filter(property.selectedValues.split(";"), function (val) {
	                    return !!val;
	                });
	                if (!property.multiValue && !_.isArray(property.selectedValues)) {
	                    var selectedValuesToArray = angular.copy(property.selectedValues);
	                    property.selectedValues = [];
	                    property.selectedValues.push(selectedValuesToArray);
	                }
	                //console.log(property);
	                this.artifactPropertyDao.update({
	                    path: this.currentNode.data.path,
	                    repoKey: this.currentNode.data.repoKey,
	                    recursive: this.repoPropertyRecursive.recursive
	                }, property).$promise.then(function () {
	                    _this._getPropertiesData();
	                    _this.modalInstance.close();
	                });
	            }
	        },
	        _getPropertySetPreDefinedValues: {
	            value: function _getPropertySetPreDefinedValues(predefineValues) {
	                var _this = this;
	
	                this.propertyValuesOptions = [];
	                predefineValues.predefinedValues.forEach(function (preValue) {
	                    _this.propertyValuesOptions.push(_this._createNewRepoObject(preValue));
	                    _this.repoPropertySetSelected.value = [];
	                });
	                this.repoPropertySetSelected.value = predefineValues.selectedValues;
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	
	                var cellTemplate = "<div class=\"grid-items-container gridcell-content-text\"\n                                 id=\"{{row.uid}}\">\n                                <div class=\"item\" \n                                     ng-if=\"row.entity.value.length>1\" \n                                     ng-repeat=\"col in row.entity.value track by $index\">{{col}}\n                                </div>\n                                <a class=\"gridcell-showall jf-link\" \n                                   ng-if=\"row.entity.value.length>1 && grid.options.htmlIsOverflowing(row.uid) && !grid.options.lastHtmlElementOverflowing(row.uid)\" \n                                   href \n                                   ng-click=\"grid.options.showAll(row.entity.value,row.entity.name,col)\"> (See All)</a>\n                                <a class=\"gridcell-showall jf-link\" \n                                   ng-if=\"row.entity.value.length>1 && grid.options.lastHtmlElementOverflowing(row.uid)\" \n                                   href \n                                   ng-click=\"grid.options.showAll(row.entity.value,row.entity.name,col)\"> (See List)</a>\n                                <div class=\"ui-grid-cell-contents\" ng-if=\"row.entity.value.length==1\">\n                                    <span ng-if=\"!row.entity.displayValues[0]\">{{row.entity.value[0]}}</span>\n                                    <span ng-if=\"row.entity.displayValues[0]\" ng-bind-html=\"row.entity.displayValues[0]\"></span>\n                                </div>\n                            </div>";
	
	                var keyCellTemplate = "<div ng-if=\"!grid.appScope.jfProperties.canAnnotate\" class=\"ui-grid-cell-contents\">{{row.entity.name}}</div>" + "<div ng-if=\"grid.appScope.jfProperties.canAnnotate\" class=\"ui-grid-cell-contents\"><a href=\"\" class=\"jf-link\" ng-click=\"grid.appScope.jfProperties.editSelectedProperty(row.entity)\">{{row.entity.name}}</a></div>";
	
	                return [{
	                    name: "Property",
	                    displayName: "Property",
	                    field: "name",
	                    cellTemplate: keyCellTemplate
	                }, {
	                    name: "Value(s)",
	                    displayName: "Value(s)",
	                    field: "value",
	                    cellTemplate: cellTemplate
	                }];
	            }
	        },
	        _formatToArray: {
	            value: function _formatToArray(list) {
	                return { name: list.name, value: _.trimEnd(list.value.toString(), ";").split(";") };
	            }
	        },
	        _createDisplayValues: {
	            value: function _createDisplayValues() {
	                var urlRegex = /^https?:\/\/[a-zA-Z0-9]+(\.)?(:[0-9]+)?.+?(?=\s|$|"|'|>|<)/;
	                _.map(this.properties, function (prop) {
	                    var displayValues = [];
	                    for (var i = 0; i < prop.value.length; i++) {
	                        var val = prop.value[i];
	                        if (val.match(urlRegex)) {
	                            displayValues[i] = "<a href=\"" + val + "\" target=\"_blank\">" + val + "</a>";
	                        } else displayValues[i] = undefined;
	                    }
	                    prop.displayValues = displayValues;
	                });
	            }
	        },
	        isInVirtual: {
	            value: function isInVirtual() {
	                return this.currentNode && this.currentNode.data && this.currentNode.data.getRoot().repoType === "virtual";
	            }
	        }
	    });
	
	    return jfPropertiesController;
	})();
	
	function jfProperties() {
	    return {
	        restrict: "EA",
	        controller: jfPropertiesController,
	        scope: {
	            currentNode: "="
	        },
	        controllerAs: "jfProperties",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_properties.html"
	    };
	}

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfViewSource = jfViewSource;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var jfViewSourceController = (function () {
	    function jfViewSourceController($scope, ArtifactViewSourceDao, JFrogEventBus) {
	        _classCallCheck(this, jfViewSourceController);
	
	        this.sourceData = "";
	        this.artifactViewSourceDao = ArtifactViewSourceDao.getInstance();
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	        this.editorOptions = {
	            lineNumbers: true,
	            readOnly: "nocursor",
	            lineWrapping: true,
	            viewportMargin: Infinity
	        };
	    }
	
	    _createClass(jfViewSourceController, {
	        $onInit: {
	            value: function $onInit() {
	                this.loadSourceData();
	                this._registerEvents();
	            }
	        },
	        loadSourceData: {
	            value: function loadSourceData() {
	                var _this = this;
	
	                if (this.currentNode.data.mimeType) {
	                    this.editorOptions.mode = this.currentNode.data.mimeType;
	                }
	                // get source path from general info
	                var info = _.find(this.currentNode.data.tabs, { name: "General" }).info;
	                if (info) {
	                    var sourcePath = info.path;
	                    // fetch source from server
	                    this.artifactViewSourceDao.fetch({
	                        archivePath: this.currentNode.data.archivePath,
	                        repoKey: this.currentNode.data.repoKey,
	                        sourcePath: sourcePath
	                    }).$promise.then(function (result) {
	                        _this.sourceData = result.source;
	                    });
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        _this.loadSourceData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfViewSourceController;
	})();
	
	function jfViewSource() {
	    return {
	        restrict: "EA",
	        scope: {
	            currentNode: "="
	        },
	        controller: jfViewSourceController,
	        controllerAs: "jfViewSource",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_view_source.html"
	    };
	}

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfPomView = jfPomView;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var jfPomViewController = (function () {
	    function jfPomViewController($scope, ArtifactViewsDao, JFrogEventBus) {
	        _classCallCheck(this, jfPomViewController);
	
	        this.artifactPomViewDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	    }
	
	    _createClass(jfPomViewController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initPomView();
	            }
	        },
	        _initPomView: {
	            value: function _initPomView() {
	                this._registerEvents();
	                this._getPomViewData();
	            }
	        },
	        _getPomViewData: {
	            value: function _getPomViewData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactPomViewDao.fetch({
	                    view: "pom",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.pomViewData = data;
	                    _this.pomViewData.fileContent = data.fileContent.trim();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getPomViewData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfPomViewController;
	})();
	
	function jfPomView() {
	    return {
	        restrict: "EA",
	        controller: jfPomViewController,
	        controllerAs: "jfPomView",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_pom_view.html"
	    };
	}

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfXmlView = jfXmlView;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var jfXmlViewController = (function () {
	    function jfXmlViewController($scope, ArtifactViewsDao, JFrogEventBus) {
	        _classCallCheck(this, jfXmlViewController);
	
	        this.artifactXmlViewDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	    }
	
	    _createClass(jfXmlViewController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initXmlView();
	            }
	        },
	        _initXmlView: {
	            value: function _initXmlView() {
	                this._registerEvents();
	                this._getXmlViewData();
	            }
	        },
	        _getXmlViewData: {
	            value: function _getXmlViewData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactXmlViewDao.fetch({
	                    view: "pom",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.xmlViewData = data;
	                    _this.xmlViewData.fileContent = data.fileContent.trim();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getXmlViewData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfXmlViewController;
	})();
	
	function jfXmlView() {
	    return {
	        restrict: "EA",
	        controller: jfXmlViewController,
	        controllerAs: "jfXmlView",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_xml_view.html"
	    };
	}

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfIvyView = jfIvyView;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var jfIvyViewController = (function () {
	    function jfIvyViewController($scope, ArtifactViewsDao, JFrogEventBus) {
	        _classCallCheck(this, jfIvyViewController);
	
	        this.artifactIvyViewDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	    }
	
	    _createClass(jfIvyViewController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initIvyView();
	            }
	        },
	        _initIvyView: {
	            value: function _initIvyView() {
	                this._registerEvents();
	                this._getIvyViewData();
	            }
	        },
	        _getIvyViewData: {
	            value: function _getIvyViewData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactIvyViewDao.fetch({
	                    view: "pom",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    //console.log(data);
	                    _this.ivyViewData = data;
	                    _this.ivyViewData.fileContent = data.fileContent.trim();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        _this._getIvyViewData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfIvyViewController;
	})();
	
	function jfIvyView() {
	    return {
	        restrict: "EA",
	        controller: jfIvyViewController,
	        controllerAs: "jfIvyView",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_ivy_view.html"
	    };
	}

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfNuget = jfNuget;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfNugetController = (function () {
	    function jfNugetController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfNugetController);
	
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.nuget;
	        this.gridDependenciesOptions = {};
	        this.gridFrameworkAssembliesOptions = {};
	        this.nugetData = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfNugetController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initNuget();
	            }
	        },
	        _initNuget: {
	            value: function _initNuget() {
	                this._registerEvents();
	                this.getNugetData();
	            }
	        },
	        getNugetData: {
	            value: function getNugetData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "nuget",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.nugetData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.nugetData.dependencies) {
	                    if (!Object.keys(this.gridDependenciesOptions).length) {
	                        this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies")).setGridData(this.nugetData.dependencies);
	                    } else {
	                        this.gridDependenciesOptions.setGridData(this.nugetData.dependencies);
	                    }
	                }
	                if (this.nugetData.frameworkAssemblies) {
	                    if (!Object.keys(this.gridFrameworkAssembliesOptions).length) {
	                        this.gridFrameworkAssembliesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns("frameworkAssemblies")).setRowTemplate("default").setGridData(this.nugetData.frameworkAssemblies);
	                    } else {
	                        this.gridFrameworkAssembliesOptions.setGridData(this.nugetData.frameworkAssemblies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Id",
	                        displayName: "Id",
	                        field: "id"
	                    }, {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version"
	                    }, {
	                        name: "Target Framework",
	                        displayName: "Target Framework",
	                        field: "targetFramework"
	                    }];
	                }
	                if (gridType === "frameworkAssemblies") {
	                    return [{
	                        name: "Assembly Name",
	                        displayName: "Assembly Name",
	                        field: "assemblyName"
	                    }, {
	                        name: "Target Framework",
	                        displayName: "Target Framework",
	                        field: "targetFramework"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getNugetData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfNugetController;
	})();
	
	function jfNuget() {
	    return {
	        restrict: "EA",
	        controller: jfNugetController,
	        controllerAs: "jfNuget",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_nuget.html"
	    };
	}

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfComposer = jfComposer;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfComposerController = (function () {
	    function jfComposerController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfComposerController);
	
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.composer;
	        this.gridDependenciesOptions = {};
	        this.composerData = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfComposerController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initComposer();
	            }
	        },
	        _initComposer: {
	            value: function _initComposer() {
	                this._registerEvents();
	                this.getComposerData();
	            }
	        },
	        getComposerData: {
	            value: function getComposerData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "composer",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.composerData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.composerData.composerDependencies) {
	                    if (!Object.keys(this.gridDependenciesOptions).length) {
	                        this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies")).setGridData(this.composerData.composerDependencies);
	                    } else {
	                        this.gridDependenciesOptions.setGridData(this.composerData.composerDependencies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }, {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getComposerData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfComposerController;
	})();
	
	function jfComposer() {
	    return {
	        restrict: "EA",
	        controller: jfComposerController,
	        controllerAs: "jfComposer",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_composer.html"
	    };
	}

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfPyPi = jfPyPi;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfPyPiController = (function () {
	    function jfPyPiController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfPyPiController);
	
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.pyPi;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.pyPiData = {};
	        this.$scope = $scope;
	        this.categoriesGridOptions = {};
	    }
	
	    _createClass(jfPyPiController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initPyPi();
	                this._createGrid();
	            }
	        },
	        _initPyPi: {
	            value: function _initPyPi() {
	                this._registerEvents();
	                this.getPyPiData();
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                this.categoriesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getCategoriesColumns()).setRowTemplate("default");
	            }
	        },
	        _getCategoriesColumns: {
	            value: function _getCategoriesColumns() {
	                return [{
	                    name: "Category",
	                    displayName: "Category",
	                    field: "category"
	                    //                cellTemplate: '<div class="ui-grid-cell-contents">{{row.entity}}</div>'
	                }];
	            }
	        },
	        isValidUrl: {
	            value: function isValidUrl(str) {
	                var regex = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]+-?)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]+-?)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/i;
	                return regex.test(str);
	            }
	        },
	        getPyPiData: {
	            value: function getPyPiData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "pypi",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.pyPiData = data;
	                    _this.categoriesGridOptions.setGridData(data.categories.map(function (cat) {
	                        return { category: cat };
	                    }));
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (self.currentNode != node) {
	                        self.currentNode = node;
	                        self.getPyPiData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfPyPiController;
	})();
	
	function jfPyPi() {
	    return {
	        restrict: "EA",
	        controller: jfPyPiController,
	        controllerAs: "jfPyPi",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_pypi.html"
	    };
	}

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfHelm = jfHelm;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by matang on 09/11/2017.
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfHelmController = (function () {
	    function jfHelmController($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfHelmController);
	
	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.helm;
	        this.gridDependenciesOptions = {};
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.helmData = {};
	    }
	
	    _createClass(jfHelmController, {
	        $onInit: {
	            value: function $onInit() {
	                this._getHelmData();
	                this._registerEvents();
	            }
	        },
	        _getHelmData: {
	            value: function _getHelmData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "helm",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.helmData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.helmData.helmDependencies) {
	                    this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.helmData.helmDependencies);
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getHelmData();
	                });
	            }
	        }
	    });
	
	    return jfHelmController;
	})();
	
	function jfHelm() {
	    return {
	        restrict: "EA",
	        controller: jfHelmController,
	        controllerAs: "jfHelm",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_helm.html"
	    };
	}

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfGo = jfGo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by matang on 09/11/2017.
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfGoController = (function () {
	    function jfGoController($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfGoController);
	
	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.go;
	        this.gridDependenciesOptions = {};
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.goData = {};
	    }
	
	    _createClass(jfGoController, {
	        $onInit: {
	            value: function $onInit() {
	                this._getGoData();
	                this._registerEvents();
	            }
	        },
	        _getGoData: {
	            value: function _getGoData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "go",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.goData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.goData.goDependencies) {
	                    this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.goData.goDependencies);
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getGoData();
	                });
	            }
	        }
	    });
	
	    return jfGoController;
	})();
	
	function jfGo() {
	    return {
	        restrict: "EA",
	        controller: jfGoController,
	        controllerAs: "jfGo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_go.html"
	    };
	}

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfCran = jfCran;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by matang on 09/11/2017.
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfCranController = (function () {
	    function jfCranController($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfCranController);
	
	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.cran;
	        this.gridDependenciesOptions = {};
	        this.gridSuggestsOptions = {};
	        this.gridImportsOptions = {};
	        this.gridLinkingToOptions = {};
	        this.gridEnhancesOptions = {};
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.cranData = {};
	    }
	
	    _createClass(jfCranController, {
	        $onInit: {
	            value: function $onInit() {
	                this._getCranData();
	                this._registerEvents();
	            }
	        },
	        _getCranData: {
	            value: function _getCranData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "cran",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.cranData = data;
	                    _this._createDependenciesGrid();
	                    _this._createSuggestsGrid();
	                    _this._createImportsGrid();
	                    _this._createLinkingToGrid();
	                    _this._createEnhancesGrid();
	                });
	            }
	        },
	        _createDependenciesGrid: {
	            value: function _createDependenciesGrid() {
	                if (this.cranData.cranDependencies) {
	                    this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.cranData.cranDependencies);
	                }
	            }
	        },
	        _createSuggestsGrid: {
	            value: function _createSuggestsGrid() {
	                if (this.cranData.cranSuggests) {
	                    this.gridSuggestsOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.cranData.cranSuggests);
	                }
	            }
	        },
	        _createImportsGrid: {
	            value: function _createImportsGrid() {
	                if (this.cranData.cranSuggests) {
	                    this.gridImportsOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.cranData.cranImports);
	                }
	            }
	        },
	        _createLinkingToGrid: {
	            value: function _createLinkingToGrid() {
	                if (this.cranData.cranSuggests) {
	                    this.gridLinkingToOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.cranData.cranImports);
	                }
	            }
	        },
	        _createEnhancesGrid: {
	            value: function _createEnhancesGrid() {
	                if (this.cranData.cranSuggests) {
	                    this.gridEnhancesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.cranData.cranImports);
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getCranData();
	                });
	            }
	        }
	    });
	
	    return jfCranController;
	})();
	
	function jfCran() {
	    return {
	        restrict: "EA",
	        controller: jfCranController,
	        controllerAs: "jfCran",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_cran.html"
	    };
	}

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfConda = jfConda;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by matang on 09/11/2017.
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfCondaController = (function () {
	    function jfCondaController($scope, $element, $timeout, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfCondaController);
	
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$timeout = $timeout;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.conda;
	        this.gridDependenciesOptions = {};
	
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.condaData = {};
	    }
	
	    _createClass(jfCondaController, {
	        $onInit: {
	            value: function $onInit() {
	
	                this._getCondaData();
	                this._registerEvents();
	            }
	        },
	        _getCondaData: {
	            value: function _getCondaData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "conda",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.condaData = data.condaInfo;
	                    _this._createDependenciesGrid();
	                });
	            }
	        },
	        _createDependenciesGrid: {
	            value: function _createDependenciesGrid() {
	                var _this = this;
	
	                if (this.condaData.depends) {
	
	                    this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns());
	
	                    this.$timeout(function () {
	                        _this.gridDependenciesOptions.setGridData(_this.condaData.depends);
	                    });
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getCondaData();
	                });
	            }
	        }
	    });
	
	    return jfCondaController;
	})();
	
	function jfConda() {
	    return {
	        restrict: "EA",
	        controller: jfCondaController,
	        controllerAs: "jfConda",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_conda.html"
	    };
	}

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfPuppet = jfPuppet;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfPuppetController = (function () {
	    function jfPuppetController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfPuppetController);
	
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.puppet;
	        this.puppetData = {};
	        this.puppetKeywordsGridOptions = {};
	        this.puppetDependenciesGridOptions = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfPuppetController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initPuppetInfo();
	            }
	        },
	        _initPuppetInfo: {
	            value: function _initPuppetInfo() {
	                this._getPuppetInfoData();
	                this._registerEvents();
	            }
	        },
	        _getPuppetInfoData: {
	            value: function _getPuppetInfoData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "puppet",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.puppetData = data;
	                    _this._createGrids();
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                if (this.puppetData.puppetKeywords) {
	                    if (!Object.keys(this.puppetKeywordsGridOptions).length) {
	                        this.puppetKeywordsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getKeywordsColumns()).setGridData(this.puppetData.puppetKeywords);
	                    } else {
	                        this.puppetKeywordsGridOptions.setGridData(this.puppetData.puppetKeywords);
	                    }
	                }
	                if (this.puppetData.puppetDependencies) {
	                    if (!Object.keys(this.puppetDependenciesGridOptions).length) {
	                        this.puppetDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getDependenciesColumns()).setGridData(this.puppetData.puppetDependencies);
	                    } else {
	                        this.puppetDependenciesGridOptions.setGridData(this.puppetData.puppetDependencies);
	                    }
	                }
	            }
	        },
	        _getKeywordsColumns: {
	            value: function _getKeywordsColumns() {
	                return [{
	                    name: "name",
	                    displayName: "Name",
	                    field: "name"
	                }];
	            }
	        },
	        _getDependenciesColumns: {
	            value: function _getDependenciesColumns() {
	                return [{
	                    name: "name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getPuppetInfoData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfPuppetController;
	})();
	
	function jfPuppet() {
	    return {
	        restrict: "EA",
	        controller: jfPuppetController,
	        controllerAs: "jfPuppet",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_puppet.html"
	    };
	}

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfBower = jfBower;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfBowerController = (function () {
	    function jfBowerController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfBowerController);
	
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.bower;
	        this.gridDependenciesOptions = {};
	        this.bowerData = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfBowerController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initBower();
	            }
	        },
	        _initBower: {
	            value: function _initBower() {
	                this._registerEvents();
	                this.getBowerData();
	            }
	        },
	        getBowerData: {
	            value: function getBowerData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "bower",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.bowerData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.bowerData.bowerDependencies) {
	                    if (!Object.keys(this.gridDependenciesOptions).length) {
	                        this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.bowerData.bowerDependencies);
	                    } else {
	                        this.gridDependenciesOptions.setGridData(this.bowerData.bowerDependencies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getBowerData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfBowerController;
	})();
	
	function jfBower() {
	    return {
	        restrict: "EA",
	        controller: jfBowerController,
	        controllerAs: "jfBower",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_bower.html"
	    };
	}

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfDocker = jfDocker;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfDockerController = (function () {
	    function jfDockerController($scope, ArtifactViewsDao, JFrogEventBus) {
	        _classCallCheck(this, jfDockerController);
	
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.docker;
	        this.dockerData = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfDockerController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initDocker();
	            }
	        },
	        _initDocker: {
	            value: function _initDocker() {
	                this._registerEvents();
	                this.getDockerData();
	            }
	        },
	        gotoPath: {
	            value: function gotoPath(key) {
	                var repoKey = this.currentNode.data.repoKey;
	                var pathField = key === "imageId" ? "imageIdPath" : key === "parent" ? "parentIdPath" : undefined;
	                if (pathField) {
	                    this.JFrogEventBus.dispatch(EVENTS.TREE_NODE_OPEN, repoKey + "/" + this.dockerData.dockerInfo[pathField]);
	                }
	            }
	        },
	        getDockerData: {
	            value: function getDockerData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "docker",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path + "/json.json"
	                }).$promise.then(function (data) {
	                    _this.dockerData = data;
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getDockerData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfDockerController;
	})();
	
	function jfDocker() {
	    return {
	        restrict: "EA",
	        controller: jfDockerController,
	        controllerAs: "jfDocker",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_docker.html"
	    };
	}

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfDockerAncestry = jfDockerAncestry;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfDockerAncestryController = (function () {
	    function jfDockerAncestryController($scope, ArtifactViewsDao, JFrogEventBus, $q) {
	        _classCallCheck(this, jfDockerAncestryController);
	
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.dockerAncestry;
	        this.dockerAncestryData = {};
	        this.$scope = $scope;
	        this.$q = $q;
	    }
	
	    _createClass(jfDockerAncestryController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initDockerAncestry();
	            }
	        },
	        _initDockerAncestry: {
	            value: function _initDockerAncestry() {
	                this._registerEvents();
	                this.getDockerAncestryData();
	            }
	        },
	        getDockerAncestryData: {
	            value: function getDockerAncestryData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this._findAncestryJsonNode().then(function (node) {
	                    return _this.artifactViewsDao.fetch({
	                        view: "dockerancestry",
	                        repoKey: node.repoKey,
	                        path: node.path
	                    }).$promise;
	                }).then(function (data) {
	                    _this.dockerAncestryData = _this._linkedListToArray(data.dockerLinkedImage);
	                });
	            }
	        },
	        _findAncestryJsonNode: {
	            value: function _findAncestryJsonNode() {
	                var _this = this;
	
	                return this.currentNode.data.getChildren().then(function (data) {
	                    for (var i = 0; i < data.length; i++) {
	                        if (data[i].text === "ancestry.json") {
	                            return data[i];
	                        }
	                    }
	                    return _this.$q.reject();
	                });
	            }
	        },
	        gotoPath: {
	            value: function gotoPath(index) {
	                var repoKey = this.currentNode.data.repoKey;
	                var fullpath = repoKey + "/" + this.dockerAncestryData[index].path;
	
	                this.JFrogEventBus.dispatch(EVENTS.TREE_NODE_OPEN, fullpath);
	            }
	        },
	        _linkedListToArray: {
	            value: function _linkedListToArray(linkedData) {
	                var arr = [];
	                var curr = linkedData;
	                var indent = 1;
	                while (curr) {
	                    var rec = { id: curr.id,
	                        size: curr.size,
	                        path: curr.path,
	                        indent: "|" + "__".repeat(indent) };
	                    arr.push(rec);
	                    curr = curr.child;
	                    indent++;
	                }
	                return arr;
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getDockerAncestryData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfDockerAncestryController;
	})();
	
	function jfDockerAncestry() {
	    return {
	        restrict: "EA",
	        controller: jfDockerAncestryController,
	        controllerAs: "jfDockerAncestry",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_docker_ancestry.html"
	    };
	}

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfDockerV2 = jfDockerV2;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfDockerV2Controller = (function () {
	    function jfDockerV2Controller($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory, JFrogTableViewOptions) {
	        _classCallCheck(this, jfDockerV2Controller);
	
	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.dockerV2;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.dockerV2Data = {};
	        this.labelGridOptions = {};
	        this.JFrogTableViewOptions = JFrogTableViewOptions;
	    }
	
	    _createClass(jfDockerV2Controller, {
	        $onInit: {
	            value: function $onInit() {
	                this._getDockerV2Data();
	                this._registerEvents();
	            }
	        },
	        _getDockerV2Data: {
	            value: function _getDockerV2Data() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "dockerv2",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.dockerV2Data = data;
	                    _this._createGrid();
	                    if (_this.layersController) _this.layersController.refreshView();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.dockerV2Data.tagInfo.labels) {
	                    if (!this.tableViewOptions) {
	                        this.tableViewOptions = new this.JFrogTableViewOptions(this.$scope).setColumns(this._getColumns()).setRowsPerPage(5).setEmptyTableText("No Labels").setObjectName("Label");
	                        this.tableViewOptions.setData(this.dockerV2Data.tagInfo.labels);
	                    } else {
	                        this.tableViewOptions.setData(this.dockerV2Data.tagInfo.labels);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    field: "key",
	                    header: "Key",
	                    width: "35%"
	                }, {
	                    field: "value",
	                    header: "Value",
	                    width: "35%"
	                }];
	            }
	        },
	        isNotEmptyValue: {
	            value: function isNotEmptyValue(value) {
	                return value && (!_.isArray(value) || value.length > 0);
	            }
	        },
	        formatValue: {
	            value: function formatValue(value) {
	                if (_.isArray(value)) {
	                    return value.join(", ");
	                } else {
	                    return value;
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getDockerV2Data();
	                });
	            }
	        },
	        scrollToLabels: {
	            value: function scrollToLabels() {
	                document.getElementById("labels").scrollIntoView();
	            }
	        }
	    });
	
	    return jfDockerV2Controller;
	})();
	
	function jfDockerV2() {
	    return {
	        restrict: "EA",
	        controller: jfDockerV2Controller,
	        controllerAs: "jfDockerV2",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_docker_v2.html"
	    };
	}

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfRubyGems = jfRubyGems;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfRubyGemsController = (function () {
	    function jfRubyGemsController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfRubyGemsController);
	
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.rubyGems;
	        this.gemsRubyGridOptions = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfRubyGemsController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initRubyGems();
	            }
	        },
	        getRepoPath: {
	            value: function getRepoPath() {
	                return this.currentNode.data.repoKey + "/" + this.currentNode.data.path;
	            }
	        },
	        _initRubyGems: {
	            value: function _initRubyGems() {
	                this._createGrid();
	                this._registerEvents();
	                this._getRubyGemsData();
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "type"
	                }];
	            }
	        },
	        _getRubyGemsData: {
	            value: function _getRubyGemsData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "gems",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    //console.log(data);
	                    _this.gemsRubyData = data;
	                    _this.gemsRubyGridOptions.setGridData(_this.gemsRubyData.gemsDependencies);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (!this.gridFrameworkAssembliesOptions || !Object.keys(this.gridFrameworkAssembliesOptions).length) {
	                    this.gemsRubyGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default");
	                } else {
	                    this._getRubyGemsData();
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getRubyGemsData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfRubyGemsController;
	})();
	
	function jfRubyGems() {
	    return {
	        restrict: "EA",
	        controller: jfRubyGemsController,
	        controllerAs: "jfRubyGems",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_ruby_gems.html"
	    };
	}

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfNpmInfo = jfNpmInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfNpmInfoController = (function () {
	    function jfNpmInfoController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfNpmInfoController);
	
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.npm;
	        this.npmData = {};
	        this.npmDependenciesGridOptions = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfNpmInfoController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initNpmInfo();
	            }
	        },
	        _initNpmInfo: {
	            value: function _initNpmInfo() {
	                this._getNpmInfoData();
	                this._registerEvents();
	            }
	        },
	        _getNpmInfoData: {
	            value: function _getNpmInfoData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "npm",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.npmData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.npmData.npmDependencies) {
	                    if (!Object.keys(this.npmDependenciesGridOptions).length) {
	                        this.npmDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.npmData.npmDependencies);
	                    } else {
	                        this.npmDependenciesGridOptions.setGridData(this.npmData.npmDependencies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getNpmInfoData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfNpmInfoController;
	})();
	
	function jfNpmInfo() {
	    return {
	        restrict: "EA",
	        controller: jfNpmInfoController,
	        controllerAs: "jfNpmInfo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_npm_info.html"
	    };
	}

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfRpm = jfRpm;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfRpmController = (function () {
	    function jfRpmController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfRpmController);
	
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.rpm;
	        this.gridProvideOptions = {};
	        this.gridRequireOptions = {};
	        this.gridObsoleteOptions = {};
	        this.gridConflictOptions = {};
	        this.rpmData = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfRpmController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initRpm();
	            }
	        },
	        _initRpm: {
	            value: function _initRpm() {
	                this._registerEvents();
	                this.getRpmData();
	            }
	        },
	        getRpmData: {
	            value: function getRpmData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "rpm",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.rpmData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.rpmData.provide) {
	                    if (!Object.keys(this.gridProvideOptions).length) {
	                        this.gridProvideOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("provide")).setGridData(this.rpmData.provide);
	                    } else {
	                        this.gridProvideOptions.setGridData(this.rpmData.provide);
	                    }
	                }
	                if (this.rpmData.require) {
	                    if (!Object.keys(this.gridRequireOptions).length) {
	                        this.gridRequireOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData(this.rpmData.require);
	                    } else {
	                        this.gridRequireOptions.setGridData(this.rpmData.require);
	                    }
	                }
	                if (this.rpmData.obsolete) {
	                    if (!Object.keys(this.gridObsoleteOptions).length) {
	                        this.gridObsoleteOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData(this.rpmData.obsolete);
	                    } else {
	                        this.gridObsoleteOptions.setGridData(this.rpmData.obsolete);
	                    }
	                }
	
	                if (this.rpmData.conflict) {
	                    if (!Object.keys(this.gridConflictOptions).length) {
	                        this.gridConflictOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData(this.rpmData.conflict);
	                    } else {
	                        this.gridConflictOptions.setGridData(this.rpmData.conflict);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name",
	                    width: "25%"
	                }, {
	                    name: "Flags",
	                    displayName: "Flags",
	                    field: "flags",
	                    width: "15%"
	                }, {
	                    name: "Epoch",
	                    displayName: "Epoch",
	                    field: "epoch",
	                    width: "15%"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version",
	                    width: "15%"
	                }, {
	                    name: "Release",
	                    displayName: "Release",
	                    field: "release",
	                    width: "15%"
	                }, {
	                    name: "Pre",
	                    displayName: "Pre",
	                    field: "pre",
	                    width: "15%"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self.getRpmData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfRpmController;
	})();
	
	function jfRpm() {
	    return {
	        restrict: "EA",
	        controller: jfRpmController,
	        controllerAs: "jfRpm",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_rpm_info.html"
	    };
	}

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfCocoapods = jfCocoapods;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfCocoapodsController = (function () {
	    function jfCocoapodsController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfCocoapodsController);
	
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.cocoapods;
	        this.gridDependenciesOptions = {};
	        this.cocoapodsData = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfCocoapodsController, {
	        $onInit: {
	            value: function $onInit() {
	                this._initCocoapods();
	            }
	        },
	        _initCocoapods: {
	            value: function _initCocoapods() {
	                this._registerEvents();
	                this.getCocoapodsData();
	            }
	        },
	        getCocoapodsData: {
	            value: function getCocoapodsData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "cocoapods",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.cocoapodsData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                if (this.cocoapodsData.dependencies) {
	                    if (!Object.keys(this.gridDependenciesOptions).length) {
	                        this.gridDependenciesOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns()).setGridData(this.cocoapodsData.dependencies);
	                    } else {
	                        this.gridDependenciesOptions.setGridData(this.cocoapodsData.dependencies);
	                    }
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Name",
	                    displayName: "Name",
	                    field: "name"
	                }, {
	                    name: "Version",
	                    displayName: "Version",
	                    field: "version"
	                }];
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        _this.getCocoapodsData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfCocoapodsController;
	})();
	
	function jfCocoapods() {
	    return {
	        restrict: "EA",
	        controller: jfCocoapodsController,
	        controllerAs: "jfCocoapods",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_cocoapods.html"
	    };
	}

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfConan = jfConan;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfConanController = (function () {
	    function jfConanController($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfConanController);
	
	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.conan;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.conanData = {};
	        this.labelGridOptions = {};
	    }
	
	    _createClass(jfConanController, {
	        $onInit: {
	            value: function $onInit() {
	                this._getConanData();
	                this._registerEvents();
	            }
	        },
	        _getConanData: {
	            value: function _getConanData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "conan",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.conanData = data;
	                    if (_this.layersController) _this.layersController.refreshView();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getConanData();
	                });
	            }
	        }
	    });
	
	    return jfConanController;
	})();
	
	function jfConan() {
	    return {
	        restrict: "EA",
	        controller: jfConanController,
	        controllerAs: "jfConan",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_conan.html"
	    };
	}

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfConanPackage = jfConanPackage;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfConanPackageController = (function () {
	    function jfConanPackageController($scope, $element, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfConanPackageController);
	
	        this.$scope = $scope;
	        this.$element = $element;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.DICTIONARY = DICTIONARY.conan;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.conanPackageData = {};
	        this.labelGridOptions = {};
	    }
	
	    _createClass(jfConanPackageController, {
	        $onInit: {
	            value: function $onInit() {
	                this._getConanPackageData();
	                this._registerEvents();
	            }
	        },
	        _getConanPackageData: {
	            value: function _getConanPackageData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "conan_package",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.conanPackageData = data;
	                    if (_this.layersController) _this.layersController.refreshView();
	                });
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    _this.currentNode = node;
	                    _this._getConanPackageData();
	                });
	            }
	        },
	        isNonEmptyObject: {
	            value: function isNonEmptyObject(val) {
	                return val && Object.keys(val).length > 0;
	            }
	        },
	        hasSettings: {
	            value: function hasSettings() {
	                if (this.isNonEmptyObject(this.conanPackageData.settings)) {
	                    return true;
	                }
	                var knownSettings = this.knownSettings();
	                for (var i in knownSettings) {
	                    if (this.conanPackageData[knownSettings[i]]) {
	                        return true;
	                    }
	                }
	                return false;
	            }
	        },
	        knownSettings: {
	            value: function knownSettings() {
	                return ["os", "arch", "buildType", "compiler", "compilerVersion", "compilerRuntime"];
	            }
	        }
	    });
	
	    return jfConanPackageController;
	})();
	
	function jfConanPackage() {
	    return {
	        restrict: "EA",
	        controller: jfConanPackageController,
	        controllerAs: "jfConanPackage",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_conan_package.html"
	    };
	}

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfStashInfo = jfStashInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var jfStashInfoController = (function () {
	    function jfStashInfoController($state, BrowseFilesDao, StashResultsDao, JFrogEventBus) {
	        _classCallCheck(this, jfStashInfoController);
	
	        this.$state = $state;
	        this.browseFilesDao = BrowseFilesDao.getInstance();
	        this.stashResultsDao = StashResultsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	
	        this.TOOLTIP = TOOLTIP.admin.import_export.stash;
	
	        this.exportOptions = {};
	
	        this.exportFileBrowserOptions = {
	            canSelectFiles: false,
	            selectionLabel: "Directory To Export",
	            pathLabel: "Path to export",
	            confirmButtonLabel: "Select",
	            showSelectedItem: true,
	            enableSelectedItem: true
	        };
	    }
	
	    _createClass(jfStashInfoController, {
	        updateExportFolderPath: {
	            value: function updateExportFolderPath(directory) {
	                this.exportOptions.path = directory;
	            }
	        },
	        clearValidations: {
	            value: function clearValidations() {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_CLEAR_FIELD_VALIDATION, true);
	            }
	        },
	        "export": {
	            value: function _export() {
	                var payload = {
	                    path: this.exportOptions.path,
	                    excludeMetadata: this.exportOptions.excludeMetadata || false,
	                    m2: this.exportOptions.createM2CompatibleExport || false,
	                    createArchive: this.exportOptions.createArchive || false,
	                    verbose: this.exportOptions.verbose || false
	                };
	
	                this.stashResultsDao["export"]({ name: "stash" }, payload).$promise.then(function (response) {});
	            }
	        },
	        gotoSearch: {
	            value: function gotoSearch() {
	                this.$state.go("search", { searchType: "quick" });
	            }
	        }
	    });
	
	    return jfStashInfoController;
	})();
	
	function jfStashInfo() {
	    return {
	        restrict: "EA",
	        scope: {
	            currentNode: "=",
	            allowExport: "="
	        },
	        controller: jfStashInfoController,
	        controllerAs: "jfStashInfo",
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_stash_info.html"
	    };
	}
	
	//            console.log(response);

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfDebianInfo = jfDebianInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfDebianInfoController = (function () {
	    function jfDebianInfoController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfDebianInfoController);
	
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.debian;
	        this.debianData = {};
	        this.debianDependenciesGridOptions = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfDebianInfoController, {
	        $onInit: {
	            value: function $onInit() {
	                this.initDebianInfo();
	            }
	        },
	        initDebianInfo: {
	            value: function initDebianInfo() {
	                this._registerEvents();
	                this._getDebianInfoData();
	            }
	        },
	        _getDebianInfoData: {
	            value: function _getDebianInfoData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "debian",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.debianData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;
	
	                this.formattedDependencies = [];
	                _.forEach(this.debianData.debianDependencies, function (item) {
	                    _this.formattedDependencies.push({
	                        name: item
	                    });
	                });
	
	                if (this.debianData.debianDependencies) {
	                    this.debianDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies")).setGridData(this.formattedDependencies);
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getDebianInfoData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfDebianInfoController;
	})();
	
	function jfDebianInfo() {
	    return {
	        restrict: "EA",
	        controller: jfDebianInfoController,
	        controllerAs: "jfDebianInfo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_debian_info.html"
	    };
	}

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfOpkgInfo = jfOpkgInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfOpkgInfoController = (function () {
	    function jfOpkgInfoController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfOpkgInfoController);
	
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.opkg;
	        this.opkgData = {};
	        this.opkgDependenciesGridOptions = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfOpkgInfoController, {
	        $onInit: {
	            value: function $onInit() {
	                this.initOpkgInfo();
	            }
	        },
	        initOpkgInfo: {
	            value: function initOpkgInfo() {
	                this._registerEvents();
	                this._getOpkgInfoData();
	            }
	        },
	        _getOpkgInfoData: {
	            value: function _getOpkgInfoData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "opkg",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.opkgData = data;
	                    _this._createGrid();
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;
	
	                this.formattedDependencies = [];
	                _.forEach(this.opkgData.debianDependencies, function (item) {
	                    _this.formattedDependencies.push({
	                        name: item
	                    });
	                });
	
	                if (this.opkgData.debianDependencies) {
	                    this.opkgDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies")).setGridData(this.formattedDependencies);
	                }
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getOpkgInfoData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfOpkgInfoController;
	})();
	
	function jfOpkgInfo() {
	    return {
	        restrict: "EA",
	        controller: jfOpkgInfoController,
	        controllerAs: "jfOpkgInfo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_opkg_info.html"
	    };
	}

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfChefInfo = jfChefInfo;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var DICTIONARY = _interopRequire(__webpack_require__(304));
	
	var jfChefInfoController = (function () {
	    function jfChefInfoController($scope, ArtifactViewsDao, JFrogEventBus, JFrogGridFactory) {
	        _classCallCheck(this, jfChefInfoController);
	
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactViewsDao = ArtifactViewsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.DICTIONARY = DICTIONARY.opkg;
	        this.chefData = {};
	        this.chefDependenciesGridOptions = {};
	        this.chefPlatformsGridOptions = {};
	        this.$scope = $scope;
	    }
	
	    _createClass(jfChefInfoController, {
	        $onInit: {
	            value: function $onInit() {
	                this._createGrids();
	                this.initChefInfo();
	            }
	        },
	        initChefInfo: {
	            value: function initChefInfo() {
	                this._registerEvents();
	                this._getChefInfoData();
	            }
	        },
	        _getChefInfoData: {
	            value: function _getChefInfoData() {
	                var _this = this;
	
	                //Temp fix for preventing fetching data for non-file nodes (occurred when pressing "Artifacts" on sidebar)
	                if (!this.currentNode.data.path) {
	                    return;
	                }
	
	                this.artifactViewsDao.fetch({
	                    view: "chef",
	                    repoKey: this.currentNode.data.repoKey,
	                    path: this.currentNode.data.path
	                }).$promise.then(function (data) {
	                    _this.chefData = data.chefCookbookInfo;
	                    _this._setGridsData();
	                });
	            }
	        },
	        _setGridsData: {
	            value: function _setGridsData() {
	                var _this = this;
	
	                this.formattedDependencies = [];
	                _.forEach(this.chefData.dependencies, function (value, key) {
	                    _this.formattedDependencies.push({
	                        name: key,
	                        version: value
	                    });
	                });
	
	                this.formattedPlatforms = [];
	                _.forEach(this.chefData.platforms, function (value, key) {
	                    _this.formattedPlatforms.push({
	                        name: key,
	                        version: value
	                    });
	                });
	                this.chefDependenciesGridOptions.setGridData(this.formattedDependencies);
	                this.chefPlatformsGridOptions.setGridData(this.formattedPlatforms);
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.chefDependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("dependencies"));
	
	                this.chefPlatformsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setRowTemplate("default").setColumns(this._getColumns("platforms"));
	            }
	        },
	        _getColumns: {
	            value: function _getColumns(gridType) {
	                if (gridType === "dependencies") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }, {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version"
	                    }];
	                }
	                if (gridType === "platforms") {
	                    return [{
	                        name: "Name",
	                        displayName: "Name",
	                        field: "name"
	                    }, {
	                        name: "Version",
	                        displayName: "Version",
	                        field: "version"
	                    }];
	                }
	            }
	        },
	        _registerEvents: {
	            value: function _registerEvents() {
	                var _this = this;
	
	                var self = this;
	                this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.TAB_NODE_CHANGED, function (node) {
	                    if (_this.currentNode != node) {
	                        _this.currentNode = node;
	                        self._getChefInfoData();
	                    }
	                });
	            }
	        }
	    });
	
	    return jfChefInfoController;
	})();
	
	function jfChefInfo() {
	    return {
	        restrict: "EA",
	        controller: jfChefInfoController,
	        controllerAs: "jfChefInfo",
	        scope: {
	            currentNode: "="
	        },
	        bindToController: true,
	        templateUrl: "states/artifacts/jf_artifact_info/info_tabs/jf_chef_info.html"
	    };
	}

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var AllBuildsController = __webpack_require__(339).AllBuildsController;
	
	var BuildsPageController = __webpack_require__(340).BuildsPageController;
	
	var buildTabs = _interopRequire(__webpack_require__(342));
	
	function buildsConfig($stateProvider) {
	    $stateProvider.state("builds", {
	        url: "/builds",
	        parent: "app-layout",
	        abstract: true,
	        templateUrl: "states/builds/builds.html"
	    }).state("builds.all", {
	        url: "/",
	        templateUrl: "states/builds/all_builds.html",
	        controller: "AllBuildsController as AllBuilds"
	    }).state("builds.build_page", {
	        url: "/:buildName/:buildNumber/:startTime/:tab/:moduleID",
	
	        params: {
	            startTime: {
	                value: null,
	                squash: true
	            },
	            tab: {
	                value: "published",
	                squash: true
	            },
	            moduleID: {
	                value: null,
	                squash: true
	            }
	        },
	        templateUrl: "states/builds/builds_page/builds_page.html",
	        controller: "BuildsPageController as BuildsPage"
	    });
	}
	
	module.exports = angular.module("builds", ["buildTabs"]).config(buildsConfig).controller("AllBuildsController", AllBuildsController).controller("BuildsPageController", BuildsPageController);

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var assign = __webpack_require__(254).assign;
	
	var CONFIG_MESSAGES = _interopRequire(__webpack_require__(190));
	
	var AllBuildsController = exports.AllBuildsController = (function () {
	    function AllBuildsController($scope, $q, $timeout, JFrogGridFactory, BuildsDao, JFrogEventBus, JFrogModal, JFrogNotifications, JFrogTableViewOptions, User, GoogleAnalytics) {
	        _classCallCheck(this, AllBuildsController);
	
	        this.$scope = $scope;
	        // this.uiGridConstants = uiGridConstants;
	        this.JFrogTableViewOptions = JFrogTableViewOptions;
	        this.user = User.getCurrent();
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.sortState = {
	            direction: "DESC",
	            orderBy: "build_date"
	        };
	        this.buildsDao = BuildsDao;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.modal = JFrogModal;
	        this.firstFetch = true;
	        this.CONFIG_MESSAGES = CONFIG_MESSAGES.builds;
	        this.allBuildsGridOptions = {};
	    }
	
	    _createClass(AllBuildsController, {
	        $onInit: {
	            value: function $onInit() {
	                this._createGrid();
	            }
	        },
	        getPaginatedBuildsData: {
	
	            // _getBuildsData(dontTrack) {
	            //     this.buildsDao.get().$promise.then((data) => {
	            //         let numOfBuilds = data && data.data ? data.data.length : 0;
	            //         if (!dontTrack) this.GoogleAnalytics.trackEvent('Builds' , 'Number of builds' , numOfBuilds , numOfBuilds);
	            //         this.buildsData = data.data || [];
	            //
	            //         this.tableViewOptions.setData(this.buildsData);
	            //     });
	            // }
	
	            value: function getPaginatedBuildsData(params, dontTrack) {
	                return this.buildsDao.get(params).$promise.then(function (data) {
	                    //TODO: Ask what to do here -> num of builds ?
	                    // const numOfBuilds = data && data.data ? data.data.length : 0;
	                    // if (!dontTrack) {
	                    //     this.GoogleAnalytics.trackEvent('Builds', 'Number of builds', numOfBuilds, numOfBuilds);
	                    // }
	                    return data;
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	                var _this = this;
	
	                var paginationCallback = function (_ref) {
	                    var offset = _ref.offset;
	                    var numOfRows = _ref.numOfRows;
	
	                    if (_this.sorting) {
	                        _this.continueState = null;
	                        _this.sorting = false;
	                    }
	                    var queryParams = assign({}, {
	                        limit: 50,
	                        continueState: _this.continueState
	                    }, _this.sortState);
	                    return _this.getPaginatedBuildsData(queryParams).then(function (response) {
	                        _this.buildsData = response.data.length;
	                        _this.showNoDataMessage = !response.data.length;
	                        _this.continueState = response.continueState;
	                        return assign({}, response, {
	                            hasMore: !!response.continueState
	                        });
	                    });
	                };
	
	                var externalSortCallback = function (orderBy, direction) {
	                    switch (orderBy) {
	                        case "buildName":
	                            orderBy = "build_name";
	                            break;
	                        case "buildNumber":
	                            orderBy = "build_number";
	                            break;
	                        case "time":
	                        default:
	                            orderBy = "build_date";
	                            break;
	                    }
	
	                    _this.sortState.orderBy = orderBy;
	                    _this.sortState.direction = direction.toUpperCase();
	                    _this.sorting = true;
	                };
	
	                this.tableViewOptions = new this.JFrogTableViewOptions(this.$scope);
	                this.tableViewOptions.setColumns(this._getColumns()).setRowsPerPage("auto").setSelection(this.tableViewOptions.MULTI_SELECTION).setActions(this._getActions()).setBatchActions(this.getBatchActions()).setEmptyTableText(this.CONFIG_MESSAGES.noBuildsDataMessage).setEmptyTableAction(this.onEmptyTableAction.bind(this)).setEmptyTableCallToAction(this.CONFIG_MESSAGES.callToAction).setPaginationMode(this.tableViewOptions.INFINITE_VIRTUAL_SCROLL, paginationCallback).setSortable(true).sortBy("time").reverseSortingDir().useExternalSortCallback(externalSortCallback);
	
	                this.tableViewOptions.isRowSelectable = function (row) {
	                    return row.entity.canDelete;
	                };
	            }
	        },
	        onEmptyTableAction: {
	            value: function onEmptyTableAction() {
	                window.open(this.CONFIG_MESSAGES.actionUrl);
	            }
	        },
	        onFilterChange: {
	            value: function onFilterChange() {
	                this.continueState = null;
	                this.sortState.searchStr = this.filter;
	                this.tableViewOptions.dirCtrl.vsApi.reset();
	                this.tableViewOptions.setData([]);
	                this.tableViewOptions.sendInfiniteScrollRequest();
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                var nameCellTemplate = "<div class=\"ui-grid-cell-contents\"><a href class=\"jf-link\" ui-sref=\"builds.build_page({buildName:row.entity.buildName,buildNumber:row.entity.buildNumber,startTime:row.entity.time})\">{{row.entity.buildName}}</a></div>";
	                var numberCellTemplate = "<div class=\"ui-grid-cell-contents\">\n                                       <a href=\"\" class=\"jf-link\" id=\"last-build-id\" ui-sref=\"builds.build_page({buildName:row.entity.buildName,buildNumber:row.entity.buildNumber,startTime:row.entity.time})\" >{{row.entity.buildNumber}}</a>\n                                    </div>";
	
	                var timeCellTemplate = "<div class=\"ui-grid-cell-contents\" id=\"last-build-time\">{{row.entity.time | date: 'd MMMM, yyyy - HH:mm:ss Z'}}</div>";
	
	                return [{
	                    header: "Build Name",
	                    field: "buildName",
	                    cellTemplate: nameCellTemplate,
	                    filterable: true
	                }, {
	                    header: "Last Build ID",
	                    field: "buildNumber",
	                    cellTemplate: numberCellTemplate,
	                    width: "10%"
	                }, {
	                    header: "Last Build Time",
	                    cellTemplate: timeCellTemplate,
	                    field: "time",
	                    width: "15%"
	                }];
	            }
	        },
	        getBatchActions: {
	            value: function getBatchActions() {
	                var _this = this;
	
	                return [{
	                    icon: "clear",
	                    name: "Delete",
	                    callback: function (selected) {
	                        return _this.bulkDelete(selected);
	                    }
	                }];
	            }
	        },
	        bulkDelete: {
	            value: function bulkDelete(selected) {
	                var _this = this;
	
	                var confirmMessage = "Are you sure you wish to delete " + selected.length;
	                confirmMessage += selected.length > 1 ? " build projects?" : " build project?";
	
	                this.modal.confirm(confirmMessage).then(function () {
	                    var buildsToDelete = selected.map(function (build) {
	                        return { buildName: build.buildName };
	                    });
	                    _this._deleteBuilds({ buildsCoordinates: buildsToDelete });
	                });
	            }
	        },
	        deleteBuild: {
	            value: function deleteBuild(row) {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you wish to delete all the builds '" + row.buildName + "'?").then(function () {
	                    _this._deleteBuilds({ buildsCoordinates: [{ buildName: row.buildName }] });
	                });
	            }
	        },
	        _deleteBuilds: {
	            value: function _deleteBuilds(json) {
	                var _this = this;
	
	                this.buildsDao.deleteAll(json).$promise.then(function () {
	                    _this.tableViewOptions.dirCtrl.vsApi.reset();
	                    _this.tableViewOptions.setData([]);
	                    _this.tableViewOptions.sendInfiniteScrollRequest();
	                });
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                var _this = this;
	
	                return [{
	                    icon: "icon icon-clear",
	                    tooltip: "Delete",
	                    callback: function (row) {
	                        return _this.deleteBuild(row);
	                    },
	                    visibleWhen: function (row) {
	                        return row.canDelete;
	                    }
	                }];
	            }
	        }
	    });
	
	    return AllBuildsController;
	})();

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var DICTIONARY = _interopRequire(__webpack_require__(341));
	
	var MESSAGES = _interopRequire(__webpack_require__(170));
	
	var BuildsPageController = exports.BuildsPageController = (function () {
	    function BuildsPageController($scope, $stateParams, BuildsDao, User, ArtifactoryFeatures, $state, $filter, JFrogEventBus, DistributionDao, JFrogModal) {
	        _classCallCheck(this, BuildsPageController);
	
	        this.$scope = $scope;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$filter = $filter;
	        this.distributionDao = DistributionDao;
	        this.modal = JFrogModal;
	
	        this.buildsDao = BuildsDao;
	        this.DICTIONARY = DICTIONARY.tabs;
	
	        this.buildTitle = this.$stateParams.buildName;
	
	        this.user = User.getCurrent();
	        this.features = ArtifactoryFeatures;
	        this.userCanDistribute = false;
	        this.continueState = null;
	        this.tabs = [{ name: "published" }, { name: "environment" }, { name: "issues" }, { name: "licenses", feature: "licenses" }, { name: "diff", feature: "diff" }, { name: "history" }, { name: "json" }, { name: "effectivePermission" }];
	        this.fetchInitialBuildsHistoryData();
	    }
	
	    _createClass(BuildsPageController, {
	        deleteBuildVersion: {
	            value: function deleteBuildVersion(build) {
	                var _this = this;
	
	                var json = {
	                    buildsCoordinates: [{
	                        buildName: this.$stateParams.buildName,
	                        buildNumber: build.buildNumber,
	                        date: build.time
	                    }]
	                };
	
	                this.modal.confirm("Are you sure you wish to delete " + build.buildNumber + " version of " + this.$stateParams.buildName + " build?").then(function () {
	                    _this.buildsDao["delete"](json).$promise.then(function () {
	                        _this._getBuildsData();
	                    });
	                });
	            }
	        },
	        _isTabDisabled: {
	            value: function _isTabDisabled(tab) {
	                if (tab.name === "effectivePermission" && !this.canManage && !this.user.isAdmin()) {
	                    return true;
	                }return !(tab.name === "published" || this.buildFullView);
	            }
	        },
	        fetchInitialBuildsHistoryData: {
	            value: function fetchInitialBuildsHistoryData() {
	                var _this = this;
	
	                this.loading = true;
	                this.buildsDao.getData({
	                    action: "history",
	                    name: this.$stateParams.buildName,
	                    limit: 50
	                }).$promise.then(function (res) {
	                    _this.builds = res.data;
	                    _this.continueState = res.continueState;
	                    _this.ciUrl = _.find(_this.builds, { buildNumber: _this.$stateParams.buildNumber }).ciUrl;
	                    _this.loading = false;
	                    _this._getBuildData();
	                });
	            }
	        },
	        fetchMoreBuildsData: {
	            value: function fetchMoreBuildsData() {
	                var _this = this;
	
	                if (!this.continueState || this.loading) {
	                    return;
	                }this.loading = true;
	                var payload = {
	                    action: "history",
	                    name: this.$stateParams.buildName,
	                    limit: 50,
	                    continueState: this.continueState
	                };
	                this.buildsDao.getData(payload).$promise.then(function (res) {
	                    var _builds;
	
	                    (_builds = _this.builds).push.apply(_builds, _toConsumableArray(res.data));
	                    _this.continueState = res.continueState;
	                    _this.loading = false;
	                });
	            }
	        },
	        setOnScroll: {
	            value: function setOnScroll() {
	                var _this = this;
	
	                var EDGE = 10;
	                setTimeout(function () {
	                    var scrollParent = $(".list-content-scrolling-container");
	                    _this.scrollParent = scrollParent;
	                    scrollParent.on("scroll", function (e) {
	                        if (scrollParent[0].scrollHeight - scrollParent.scrollTop() <= scrollParent[0].clientHeight + EDGE) {
	                            if (!_this.loading) {
	                                _this.fetchMoreBuildsData();
	                            }
	                        }
	                    });
	                });
	            }
	        },
	        _getBuildsData: {
	
	            // Get list of builds
	
	            value: function _getBuildsData() {
	                var _this = this;
	
	                this.buildsDao.getData({
	                    action: "history",
	                    name: this.$stateParams.buildName,
	                    limit: 20
	                }).$promise.then(function (res) {
	                    _this.builds = _.map(_.orderBy(res.data, ["time"], false));
	                    _this.ciUrl = _.find(_this.builds, { buildNumber: _this.$stateParams.buildNumber }).ciUrl;
	                    _this._getBuildData();
	                });
	            }
	        },
	        _getBuildData: {
	            value: function _getBuildData() {
	                var _this = this;
	
	                this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildInfo"
	                }).$promise.then(function (data) {
	                    _this.buildFullView = data.buildFullView;
	                    _this.userCanDistribute = data.userCanDistribute;
	                    _this.canDelete = data.canDelete;
	                    _this.canManage = data.canManage;
	                    _this.$stateParams.startTime = data.time;
	                    _this.buildData = data;
	                    _this.summaryData = _this.getSummaryColumns();
	
	                    _this.tabs.forEach(function (tab) {
	                        tab.isDisabled = _this._isTabDisabled(tab);
	                    });
	                    _this.setOnScroll();
	                });
	            }
	        },
	        getSummaryColumns: {
	            value: function getSummaryColumns() {
	                var agentTemplate = this.ciUrl ? "<a class=\"jf-link\" ng-href=\"{{BuildsPage.buildData.url}}\" target=\"_blank\">{{BuildsPage.buildData.agent}}</a> <a ng-href=\"{{BuildsPage.buildData.url}}\" target=\"_blank\"><i class=\"icon-linked\" jf-tooltip='<a href=\"{{BuildsPage.buildData.url}}\">{{BuildsPage.buildData.url}}</a>'></i></a>" : "{{BuildsPage.buildData.agent}}";
	                return [{
	                    label: "Agent",
	                    template: agentTemplate,
	                    isActive: true
	                }, {
	                    label: "Build Agent",
	                    template: "{{BuildsPage.buildData.buildAgent}}",
	                    isActive: true
	                }, {
	                    label: "Started",
	                    template: "<div class=\"text-truncate\" jf-tooltip-on-overflow>{{BuildsPage.buildData.lastBuildTime | date:\"d MMMM, yyyy\"}} {{BuildsPage.buildData.lastBuildTime | date:\"HH:mm:ss\"}}</div>",
	                    isActive: true
	                }, {
	                    label: "Duration",
	                    template: "{{BuildsPage.buildData.duration || '-'}}",
	                    isActive: true
	                }, {
	                    label: "Principal",
	                    template: "{{BuildsPage.buildData.principal || '-'}}",
	                    isActive: true
	                }, {
	                    label: "Artifactory Principal",
	                    template: "{{BuildsPage.buildData.artifactoryPrincipal || '-'}}",
	                    isActive: true,
	                    width: "1.2fr"
	                }];
	            }
	        },
	        goToBuildNumber: {
	            value: function goToBuildNumber(build) {
	                var _this = this;
	
	                this.ciUrl = build.ciUrl;
	                _.extend(this.$stateParams, { buildNumber: build.buildNumber, startTime: build.time, tab: this.$state.params.tab, moduleID: null });
	                this.$state.go(".", this.$stateParams, { location: true, inherit: true, relative: this.$state.$current, notify: false, reload: true }).then(function () {
	                    _this._getBuildData();
	                    _this.JFrogEventBus.dispatch(_this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH);
	                });
	            }
	        },
	        deleteBuildId: {
	            value: function deleteBuildId(e, buildId) {
	                var _this = this;
	
	                e.stopPropagation();
	                var buildName = this.$stateParams.buildName;
	                var buildNumber = buildId;
	                var date = this.$stateParams.startTime;
	                var index = _.findIndex(this.builds, function (build) {
	                    return build.buildNumber === buildNumber;
	                });
	                var isDeleteingActiveBuildNumber = buildNumber === this.$stateParams.buildNumber;
	
	                var json = {
	                    buildsCoordinates: [{
	                        buildName: buildName,
	                        buildNumber: buildNumber,
	                        date: date
	                    }]
	                };
	
	                this.modal.confirm("Are you sure you want to delete build number " + buildNumber + " in " + buildName + "?").then(function () {
	                    _this.buildsDao["delete"](json).$promise.then(function () {
	                        if (index === 0 && _this.builds.length === 1) {
	                            _this.backToBuilds();
	                        } else if (isDeleteingActiveBuildNumber) {
	                            _this.builds.splice(index, 1);
	                            if (index === 0) {
	                                _this.goToBuildNumber(_this.builds[0]);
	                            } else {
	                                _this.goToBuildNumber(_this.builds[index - 1]);
	                            }
	                        } else {
	                            _this.builds.splice(index, 1);
	                        }
	                    });
	                });
	            }
	        },
	        distribute: {
	            value: function distribute() {
	                var _this = this;
	
	                this.distributionDao.getAvailableDistributionRepos({}).$promise.then(function (data) {
	                    var modalInstance = undefined;
	                    _this.distributeModalScope = _this.$scope.$new();
	
	                    _this.distributeModalScope.title = "Distribute " + _this.$stateParams.buildName + " #" + _this.$stateParams.buildNumber;
	                    _this.distributeModalScope.distributionRepositoriesOptions = _.map(data.data.availableDistributionRepos, "repoKey");
	
	                    _this.distributeModalScope.data = {};
	
	                    if (!_this.distributeModalScope.distributionRepositoriesOptions.length) {
	                        _this.distributeModalScope.errorMessage = MESSAGES.actions.distribute.noRepos.nonAdmin.message;
	                        _this.distributeModalScope.messageType = MESSAGES.actions.distribute.noRepos.nonAdmin.messageType;
	                    }
	
	                    _this.distributeModalScope.data.async = true;
	                    _this.distributeModalScope.data.publish = true;
	                    _this.distributeModalScope.data.publish = true;
	                    _this.distributeModalScope.data.overrideExistingFiles = false;
	                    _this.distributeModalScope.data.selectedRepo = null;
	                    _this.distributeModalScope.distribute = function () {
	                        _this._resetChanges();
	                        _this.distributionDao.distributeBuild({
	                            targetRepo: _this.distributeModalScope.data.selectedRepo,
	                            async: _this.distributeModalScope.data.async,
	                            overrideExistingFiles: _this.distributeModalScope.data.overrideExistingFiles,
	                            date: _this.$stateParams.startTime
	                        }, {
	                            buildName: _this.$stateParams.buildName,
	                            buildNumber: _this.$stateParams.buildNumber,
	                            date: _this.$stateParams.startTime
	                        }).$promise.then(function (res) {
	                            // Success
	                            if (_this.distributeModalScope.data.async) {
	                                modalInstance.close();
	                            } else {
	                                _this._runRulesTest(res);
	                            }
	                        });
	                    };
	
	                    // DRY RUN
	                    _this.distributeModalScope.dryRun = function () {
	                        _this._resetChanges();
	                        _this.distributionDao.distributeBuild({
	                            targetRepo: _this.distributeModalScope.data.selectedRepo,
	                            async: _this.distributeModalScope.data.async,
	                            publish: _this.distributeModalScope.data.publish,
	                            overrideExistingFiles: _this.distributeModalScope.data.overrideExistingFiles,
	                            dryRun: true
	                        }, {
	                            buildName: _this.$stateParams.buildName,
	                            buildNumber: _this.$stateParams.buildNumber,
	                            date: _this.$stateParams.startTime
	                        }).$promise.then(function (res) {
	                            _this._runRulesTest(res);
	                        });
	                    };
	
	                    modalInstance = _this.modal.launchModal("distribute_modal", _this.distributeModalScope, 650);
	                });
	            }
	        },
	        _runRulesTest: {
	            value: function _runRulesTest(res) {
	                var _this = this;
	
	                var ind = 0;
	                var result = res.data;
	                _.forEach(result, function (value, key) {
	                    if (key == "distributed") {
	                        (function () {
	                            var distributed = result[key];
	
	                            _.forEach(distributed, function (value, key) {
	                                distributed[key].customId = "dis" + ind;
	                                ind++;
	
	                                var packages = distributed[key].packages;
	
	                                _.forEach(packages, function (value, key) {
	                                    packages[key].customId = "pac" + ind;
	                                    ind++;
	
	                                    var versions = packages[key].versions;
	                                    _.forEach(versions, function (value, key) {
	                                        versions[key].customId = "ver" + ind;
	                                        ind++;
	                                    });
	                                });
	                            });
	                        })();
	                    }
	                });
	                this.distributeModalScope.data.dryRunResults = result;
	
	                _.forEach(result.messagesByPath, function (value) {
	                    if (value.warnings) {
	                        _this.distributeModalScope.data.warningExist = value.warnings.length ? true : false;
	                    }
	                    if (value.errors) {
	                        _this.distributeModalScope.data.errorsExist = value.errors.length ? true : false;
	                    }
	                });
	
	                this._expandModal();
	            }
	        },
	        _expandModal: {
	            value: function _expandModal() {
	                $("form[name=\"distributeRepo\"]").closest(".modal-dialog").animate({
	                    maxWidth: "850px"
	                }, 500);
	            }
	        },
	        _resetChanges: {
	            value: function _resetChanges() {
	                // RESET
	                this.distributeModalScope.data.dryRunResults = null;
	                this.distributeModalScope.data.toggleSuccessTitle = null;
	                this.distributeModalScope.data.toggleWarnTitle = null;
	                this.distributeModalScope.data.toggleErrorTitle = null;
	                this.distributeModalScope.data.warningExist = null;
	                this.distributeModalScope.data.errorsExist = null;
	            }
	        },
	        backToBuilds: {
	            value: function backToBuilds() {
	                this.$state.go("builds.all");
	            }
	        }
	    });
	
	    return BuildsPageController;
	})();

/***/ }),
/* 341 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	    tabs: {
	        published: "Published Modules",
	        environment: "Environment",
	        issues: "Issues",
	        licenses: "Licenses",
	        diff: "Diff",
	        history: "Release History",
	        json: "Build Info JSON",
	        effectivePermission: "Effective Permissions"
	    },
	    generalInfo: {
	        buildName: "Name",
	        buildNumber: "Number",
	        agent: "Agent",
	        buildAgent: "Build Agent",
	        lastBuildTime: "Started",
	        duration: "Duration",
	        principal: "Principal",
	        artifactoryPrincipal: "Artifactory Principal",
	        url: "URL"
	    },
	    releaseHistory: {
	        repository: "Repository",
	        comment: "Comment",
	        ciUser: "CI User",
	        user: "Artifactory User",
	        timestamp: "Timestamp"
	    }
	};

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var jfPublishedModules = __webpack_require__(343).jfPublishedModules;
	
	var jfBuildInfoJson = __webpack_require__(344).jfBuildInfoJson;
	
	var jfEnvironment = __webpack_require__(345).jfEnvironment;
	
	var jfIssues = __webpack_require__(346).jfIssues;
	
	var jfDiff = __webpack_require__(347).jfDiff;
	
	var jfReleaseHistory = __webpack_require__(348).jfReleaseHistory;
	
	var jfLicenses = __webpack_require__(349).jfLicenses;
	
	var jfEffectivePermission = __webpack_require__(350).jfEffectivePermission;
	
	module.exports = angular.module("buildTabs", []).directive({
	  jfPublishedModules: jfPublishedModules,
	  jfBuildInfoJson: jfBuildInfoJson,
	  jfEnvironment: jfEnvironment,
	  jfIssues: jfIssues,
	  jfDiff: jfDiff,
	  jfReleaseHistory: jfReleaseHistory,
	  jfLicenses: jfLicenses,
	  jfBuildEffectivePermission: jfEffectivePermission
	});

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfPublishedModules = jfPublishedModules;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var DICTIONARY = _interopRequire(__webpack_require__(341));
	
	var defaultPagination = {
	    pageNum: 1,
	    numOfRows: 25,
	    direction: "asc",
	    orderBy: "name"
	};
	
	var jfPublishedModulesController = (function () {
	    function jfPublishedModulesController($scope, $state, $stateParams, $q, BuildsDao, ArtifactBuildsDao, ArtifactActionsDao, JFrogGridFactory, JFrogDownload, JFrogModal, ArtifactoryFeatures, JFrogEventBus, $timeout, uiGridConstants, commonGridColumns, User, ArtifactoryStorage) {
	        var _this = this;
	
	        _classCallCheck(this, jfPublishedModulesController);
	
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.$stateParams = $stateParams;
	        this.$state = $state;
	        this.$scope = $scope;
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.initialModuleId = $stateParams.moduleID;
	        this.buildsDao = BuildsDao;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.artifactBuildsDao = ArtifactBuildsDao.getInstance();
	        this.download = JFrogDownload;
	        this.modal = JFrogModal;
	        this.modulesGridOptions = {};
	        this.artifactsGridOptions = {};
	        this.dependenciesGridOptions = {};
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.user = User;
	        this.modulesCount = 0;
	        this.artifactsCount = 0;
	        this.dependenciesCount = 0;
	        this.DICTIONARY = DICTIONARY.generalInfo;
	        this.selectedModule = null;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.comparableNumbers = [""];
	        this.selectedBuildNumber = "";
	        this.artifactoryFeatures = ArtifactoryFeatures;
	
	        if (this.$stateParams.startTime) {
	            this.init();
	        } else {
	            this.getBuildTime().then(function () {
	                _this.init();
	            });
	        }
	
	        this.JFrogEventBus.registerOnScope(this.$scope, this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH, function () {
	            _this.init();
	        });
	    }
	
	    _createClass(jfPublishedModulesController, {
	        getBuildTime: {
	            value: function getBuildTime() {
	                var _this = this;
	
	                var defer = this.$q.defer();
	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    action: "buildInfo"
	                }).$promise.then(function (data) {
	                    _this.$stateParams.startTime = data.time;
	                    _this.$state.transitionTo(".", _this.$stateParams, { location: "replace", inherit: true, relative: _this.$state.$current, notify: false });
	                    defer.resolve();
	                });
	                return defer.promise;
	            }
	        },
	        init: {
	            value: function init() {
	                this._getComparableBuildNumbers();
	                this._createGrids();
	
	                if (this.$stateParams.moduleID) {
	                    this.selectedModule = this.$stateParams.moduleID;
	                    this.getSubData();
	                } else {
	                    this.selectedModule = null;
	                }
	            }
	        },
	        showArtifactInTree: {
	            value: function showArtifactInTree(row) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") browser = "tree";
	                var path = row.repoKey + "/" + row.path;
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    artifact: path,
	                    browser: browser
	                });
	            }
	        },
	        downloadArtifact: {
	            value: function downloadArtifact(row) {
	                this.download(row.downloadLink);
	            }
	        },
	        viewCodeArtifact: {
	            value: function viewCodeArtifact(row) {
	                var _this = this;
	
	                this.artifactActionsDao.perform({ action: "view" }, {
	                    repoKey: row.repoKey,
	                    path: row.path
	                }).$promise.then(function (result) {
	                    _this.modal.launchCodeModal(row.name, result.data.fileContent, { name: row.type, json: true });
	                });
	            }
	        },
	        selectModule: {
	            value: function selectModule(entity) {
	                var _this = this;
	
	                if (!this.artifactoryFeatures.isDisabled("publishedmodule")) {
	                    _.extend(this.$stateParams, {
	                        buildName: this.$stateParams.buildName,
	                        buildNumber: this.$stateParams.buildNumber,
	                        startTime: this.$stateParams.startTime,
	                        tab: "published ", //this.$stateParams.tab,
	                        moduleID: entity.moduleId
	                    });
	                    this.$state.go(".", this.$stateParams, { location: true, inherit: true, relative: this.$state.$current, notify: false, reload: true }).then(function () {
	                        _this.init();
	                    });
	                }
	            }
	        },
	        getSubData: {
	            value: function getSubData() {
	                if (this.compare && this.selectedBuildNumber && this.selectedBuildNumber.buildNumber) {
	                    this._getArtifactsDiff();
	                    this._getDependenciesDiff();
	                } else {
	                    this._getArtifacts();
	                    this._getDependencies();
	                }
	            }
	        },
	        onCompareChanged: {
	            value: function onCompareChanged() {
	                if (!(this.selectedBuildNumber && this.selectedBuildNumber.buildNumber)) {
	                    // Don't get data if haven't selected build number yet
	                    return;
	                }
	                this.getSubData();
	            }
	        },
	        _getModulesData: {
	            value: function _getModulesData() {
	                var _this = this;
	
	                this.buildsDao.getData(defaultPagination, {
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "publishedModules"
	                }).$promise.then(function (data) {
	                    _this.modulesCount = data.pagingData.length;
	                    _this.modulesGridOptions.setGridData(data.pagingData);
	                    if (_this.initialModuleId) {
	                        _this.initialModuleId = null;
	                        var _module2 = _.find(data.pagingData, { moduleId: _this.$stateParams.moduleID })
	                        //                        this.modulesGridOptions.selectItem(module);
	                        ;
	                    }
	                });
	            }
	        },
	        _getArtifacts: {
	            value: function _getArtifacts() {
	                var _this = this;
	
	                this.buildsDao.getData(defaultPagination, {
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "modulesArtifact",
	                    moduleId: this.selectedModule
	                }).$promise.then(function (data) {
	                    _this.artifactsCount = data.pagingData.length;
	                    _this.artifactsGridOptions.setGridData(data.pagingData);
	                });
	            }
	        },
	        _getDependencies: {
	            value: function _getDependencies() {
	                var _this = this;
	
	                var defaultPagination = {
	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "id"
	                };
	                this.buildsDao.getData(defaultPagination, {
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "modulesDependency",
	                    moduleId: this.selectedModule
	                }).$promise.then(function (data) {
	                    _this.dependenciesCount = data.pagingData.length;
	                    _this.dependenciesGridOptions.setGridData(data.pagingData);
	                });
	            }
	        },
	        _getArtifactsDiff: {
	            value: function _getArtifactsDiff() {
	                var _this = this;
	
	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "artifactDiff",
	                    moduleId: this.selectedModule,
	
	                    otherNumber: this.selectedBuildNumber.buildNumber,
	                    otherDate: this.selectedBuildNumber.time,
	
	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "name" }).$promise.then(function (data) {
	                    _this.artifactsCount = data.pagingData.length;
	                    _this.artifactsGridOptions.setGridData(data.pagingData);
	                });
	                ;
	            }
	        },
	        _getDependenciesDiff: {
	            value: function _getDependenciesDiff() {
	                var _this = this;
	
	                this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "dependencyDiff",
	                    moduleId: this.selectedModule,
	                    otherNumber: this.selectedBuildNumber.buildNumber,
	                    otherDate: this.selectedBuildNumber.time,
	
	                    pageNum: 1,
	                    numOfRows: 25,
	                    direction: "asc",
	                    orderBy: "id"
	                }).$promise.then(function (data) {
	                    _this.dependenciesCount = data.pagingData.length; //data.totalItems ? data.totalItems : 0;
	                    _this.dependenciesGridOptions.setGridData(data.pagingData);
	                });
	            }
	        },
	        _getComparableBuildNumbers: {
	            value: function _getComparableBuildNumbers() {
	                var _this = this;
	
	                this.buildsDao.getDataArray({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "prevBuild"
	                }).$promise.then(function (data) {
	                    _this.comparableBuildNumbers = data;
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                var _this = this;
	
	                this.modulesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getModulesColumns()).setRowTemplate("default");
	
	                this.modulesGridOptions.onSelectionChange = function (data) {
	                    _this.selectModule(data.entity);
	                };
	
	                this.artifactsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getArtifactsColumns()).setRowTemplate("default");
	
	                this.dependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getDependenciesColumns()).setRowTemplate("default");
	
	                this._getModulesData();
	
	                var featureLink = this.artifactoryFeatures.getFeatureLink("publishedmodule");
	                var featureName = this.artifactoryFeatures.getFeatureName("publishedmodule");
	
	                if (this.artifactoryFeatures.isDisabled("publishedmodule")) {
	                    this.$timeout(function () {
	                        //$('.grid-counter').css('color', 'red');
	                        $(".grid-counter").append("<span class=\"license-required\"></span>");
	                        $(".grid-counter").find(".license-required").tooltipster({
	                            animation: "fade",
	                            contentAsHTML: "true",
	                            trigger: "hover",
	                            onlyOne: "true",
	                            interactive: "true",
	                            interactiveTolerance: 150,
	                            position: "top",
	                            theme: "tooltipster-default top",
	                            content: "Learn more about the <a href=\"" + featureLink + "\" target=\"_blank\">" + featureName + "</a> feature"
	                        });
	                    });
	                }
	            }
	        },
	        _getModulesColumns: {
	            value: function _getModulesColumns() {
	                var cellTemplate = undefined;
	                if (this.artifactoryFeatures.isNonCommercial()) {
	                    cellTemplate = "<div class=\"ui-grid-cell-contents\"><span>{{row.entity.moduleId}}</span></div>";
	                } else {
	                    cellTemplate = "<div ng-click=\"grid.appScope.jfPublishedModules.selectModule(row.entity)\" class=\"ui-grid-cell-contents\"><a href class=\"jf-link\">{{row.entity.moduleId}}</a></div>";
	                }
	
	                return [{
	                    name: "Module ID",
	                    displayName: "Module ID",
	                    field: "moduleId",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    cellTemplate: cellTemplate,
	                    width: "60%"
	                }, {
	                    name: "Number Of Artifacts",
	                    displayName: "Number Of Artifacts",
	                    field: "numOfArtifacts",
	                    width: "20%"
	                }, {
	                    name: "Number Of Dependencies",
	                    displayName: "Number Of Dependencies",
	                    field: "numOfDependencies",
	                    width: "20%"
	                }];
	            }
	        },
	        _getArtifactsColumns: {
	            value: function _getArtifactsColumns() {
	                var _this = this;
	
	                var typeCellTemplate = "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.type}}</div>";
	
	                return [{
	                    name: "Artifact Name",
	                    displayName: "Artifact Name",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "30%",
	                    cellTemplate: this.commonGridColumns.downloadableColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    customActions: [{
	                        icon: "icon icon-view",
	                        tooltip: "View",
	                        callback: function (row) {
	                            return _this.viewCodeArtifact(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.find(row.actions, { name: "View" });
	                        }
	                    }],
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.find(row.actions, { name: "Download" });
	                            }
	                        }
	                    }
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "type",
	                    cellTemplate: typeCellTemplate,
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "10%"
	                }, {
	                    name: "Repo Path",
	                    displayName: "Repo Path",
	                    field: "repoPath",
	                    width: "50%",
	                    cellTemplate: this.commonGridColumns.repoPathColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showArtifactInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.find(row.actions, { name: "ShowInTree" });
	                        }
	                    }]
	                }];
	            }
	        },
	        _getDependenciesColumns: {
	            value: function _getDependenciesColumns() {
	                var _this = this;
	
	                var typeCellTemplate = "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.type}}</div>";
	                var scopeCellTemplate = "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.scope}}</div>";
	
	                return [{
	                    name: "Dependency ID",
	                    displayName: "Dependency ID",
	                    field: "name",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    },
	                    width: "25%",
	                    cellTemplate: this.commonGridColumns.downloadableColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.find(row.actions, { name: "Download" });
	                            }
	                        }
	                    }
	                }, {
	                    name: "Scope",
	                    displayName: "Scope",
	                    field: "scope",
	                    cellTemplate: scopeCellTemplate,
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "15%"
	                }, {
	                    name: "Type",
	                    displayName: "Type",
	                    field: "type",
	                    cellTemplate: typeCellTemplate,
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "15%"
	                }, {
	                    name: "Repo Path",
	                    displayName: "Repo Path",
	                    field: "repoPath",
	                    width: "45%",
	                    cellTemplate: this.commonGridColumns.repoPathColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showArtifactInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.find(row.actions, { name: "ShowInTree" });
	                        }
	                    }]
	                }];
	            }
	        },
	        _installWatchers: {
	            value: function _installWatchers() {
	                var _this = this;
	
	                this.$scope.$watch("jfPublishedModules.selectedBuildNumber", function (val) {
	                    if (val.length) {
	                        _this.getSubData();
	                    }
	                });
	                this.$scope.$watch("jfPublishedModules.compare", function (val) {
	                    if (val !== undefined) {
	                        _this.getSubData();
	                    }
	                });
	            }
	        },
	        backToModules: {
	            value: function backToModules() {
	                var _this = this;
	
	                _.extend(this.$stateParams, {
	                    buildName: this.$stateParams.buildName,
	                    buildNumber: this.$stateParams.buildNumber,
	                    startTime: this.$stateParams.startTime,
	                    tab: "published",
	                    moduleID: null
	                });
	
	                this.$state.go(".", this.$stateParams, { location: true, inherit: true, relative: this.$state.$current, notify: false, reload: true }).then(function () {
	                    _this.selectedModule = null;
	                });
	            }
	        }
	    });
	
	    return jfPublishedModulesController;
	})();
	
	function jfPublishedModules() {
	    return {
	        restrict: "EA",
	        controller: jfPublishedModulesController,
	        controllerAs: "jfPublishedModules",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/build_tabs/jf_published_modules.html"
	    };
	}

/***/ }),
/* 344 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfBuildInfoJson = jfBuildInfoJson;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var jfBuildInfoJsonController = (function () {
	    function jfBuildInfoJsonController($stateParams, $scope, BuildsDao, JFrogEventBus) {
	        var _this = this;
	
	        _classCallCheck(this, jfBuildInfoJsonController);
	
	        this.$stateParams = $stateParams;
	        this.json = "";
	        this.buildsDao = BuildsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	
	        this._getJson();
	        this.JFrogEventBus.registerOnScope(this.$scope, this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH, function () {
	            _this._getJson();
	        });
	
	        $(window).resize(function () {
	            setTimeout(function () {
	                _this._calculateCodeMirrorHeight();
	            }, 50);
	        });
	    }
	
	    _createClass(jfBuildInfoJsonController, {
	        _getJson: {
	            value: function _getJson() {
	                var _this = this;
	
	                this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildJson"
	                }).$promise.then(function (data) {
	                    _this.json = data.fileContent;
	
	                    setTimeout(function () {
	                        _this._calculateCodeMirrorHeight();
	                    }, 100);
	                });
	            }
	        },
	        _calculateCodeMirrorHeight: {
	            value: function _calculateCodeMirrorHeight() {
	                var codeMirrorElement = $(".CodeMirror");
	                var buildWrapperElement = $(".builds-inner-wrapper");
	
	                var buildWrapperOffset = buildWrapperElement.outerHeight() + buildWrapperElement.offset().top;
	                var codeMirrorOffset = codeMirrorElement.outerHeight() + codeMirrorElement.offset().top;
	
	                var codeMirrorHeight = buildWrapperOffset - codeMirrorOffset + codeMirrorElement.outerHeight() - 30;
	
	                codeMirrorElement.css({ height: codeMirrorHeight });
	            }
	        }
	    });
	
	    return jfBuildInfoJsonController;
	})();
	
	function jfBuildInfoJson() {
	    return {
	        restrict: "EA",
	        controller: jfBuildInfoJsonController,
	        controllerAs: "jfBuildInfoJson",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/build_tabs/jf_build_info_json.html"
	    };
	}

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfEnvironment = jfEnvironment;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var DICTIONARY = _interopRequire(__webpack_require__(341));
	
	var jfEnvironmentController = (function () {
	    function jfEnvironmentController($scope, BuildsDao, JFrogGridFactory, $stateParams, uiGridConstants, JFrogEventBus) {
	        var _this = this;
	
	        _classCallCheck(this, jfEnvironmentController);
	
	        this.$scope = $scope;
	        this.$stateParams = $stateParams;
	        this.buildsDao = BuildsDao;
	        this.uiGridConstants = uiGridConstants;
	        this.environmentGridOptions = {};
	        this.systemGridOptions = {};
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.DICTIONARY = DICTIONARY.generalInfo;
	        this._getEnvironmentData();
	        this._createGrids();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH, function () {
	            _this._getEnvironmentData();
	        });
	    }
	
	    _createClass(jfEnvironmentController, {
	        _getEnvironmentData: {
	            value: function _getEnvironmentData() {
	                this._getEnvVars();
	                this._getSysVars();
	            }
	        },
	        _getEnvVars: {
	            value: function _getEnvVars() {
	                var _this = this;
	
	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildProps",
	                    subAction: "env",
	                    orderBy: "key",
	                    numOfRows: 25,
	                    pageNum: 1,
	                    direction: "asc"
	                }).$promise.then(function (data) {
	                    _this.environmentGridOptions.setGridData(data.pagingData || []);
	                });
	            }
	        },
	        _getSysVars: {
	            value: function _getSysVars() {
	                var _this = this;
	
	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildProps",
	                    subAction: "system",
	                    orderBy: "key",
	                    numOfRows: 25,
	                    pageNum: 1,
	                    direction: "asc"
	                }).$promise.then(function (data) {
	                    _this.systemGridOptions.setGridData(data.pagingData || []);
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	
	                this.environmentGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData([]);
	
	                this.systemGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData([]);
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    name: "Key",
	                    displayName: "Key",
	                    field: "key",
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    }
	                }, {
	                    name: "Value",
	                    displayName: "Value",
	                    field: "value"
	                }];
	            }
	        }
	    });
	
	    return jfEnvironmentController;
	})();
	
	function jfEnvironment() {
	    return {
	        restrict: "EA",
	        controller: jfEnvironmentController,
	        controllerAs: "jfEnvironment",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/build_tabs/jf_environment.html"
	    };
	}

/***/ }),
/* 346 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfIssues = jfIssues;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var jfIssuesController = (function () {
	    function jfIssuesController($scope, $stateParams, JFrogEventBus, BuildsDao, JFrogGridFactory, uiGridConstants, commonGridColumns) {
	        var _this = this;
	
	        _classCallCheck(this, jfIssuesController);
	
	        this.$stateParams = $stateParams;
	        this.$scope = $scope;
	        this.uiGridConstants = uiGridConstants;
	        this.buildsDao = BuildsDao;
	        this.gridOptions = {};
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.commonGridColumns = commonGridColumns;
	        this.JFrogEventBus = JFrogEventBus;
	        this.noData = false;
	
	        this._createGrid();
	        this._getIssuesData();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH, function () {
	            _this._getIssuesData();
	        });
	    }
	
	    _createClass(jfIssuesController, {
	        _getIssuesData: {
	            value: function _getIssuesData() {
	                var _this = this;
	
	                this.buildsDao.getDataArray({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "buildIssues"
	                }).$promise.then(function (data) {
	                    if (data.length) {
	                        _this.gridOptions.setGridData(data);
	                    } else {
	                        _this.noData = true;
	                    }
	                })["catch"](function () {
	                    _this.noData = true;
	                    _this.gridOptions.setGridData([]);
	                });
	            }
	        },
	        _createGrid: {
	            value: function _createGrid() {
	
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setButtons(this._getActions());
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                var cellTemplate = "<div class=\"ui-grid-cell-contents\"><a target=\"_blank\" ng-href=\"{{row.entity.url}}\" class=\"jf-link\" >{{row.entity.key}}</a></div>";
	
	                return [{
	                    name: "Key",
	                    displayName: "Key",
	                    field: "key",
	                    cellTemplate: cellTemplate }, {
	                    name: "Summary",
	                    displayName: "Summary",
	                    field: "summary"
	                }, {
	                    name: "Previous Build",
	                    displayName: "Previous Build",
	                    field: "aggregated",
	                    cellTemplate: this.commonGridColumns.booleanColumn("row.entity.aggregated"),
	                    sort: {
	                        direction: this.uiGridConstants.ASC
	                    }
	                }];
	            }
	        },
	        _getActions: {
	            value: function _getActions() {
	                return [];
	            }
	        }
	    });
	
	    return jfIssuesController;
	})();
	
	function jfIssues() {
	    return {
	        restrict: "EA",
	        controller: jfIssuesController,
	        controllerAs: "jfIssues",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/build_tabs/jf_issues.html"
	    };
	}

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfDiff = jfDiff;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var jfDiffController = (function () {
	    function jfDiffController($scope, $stateParams, $state, $window, BuildsDao, JFrogGridFactory, uiGridConstants, commonGridColumns, JFrogEventBus, JFrogDownload, ArtifactActionsDao, ArtifactoryStorage) {
	        var _this = this;
	
	        _classCallCheck(this, jfDiffController);
	
	        this.$stateParams = $stateParams;
	        this.$scope = $scope;
	        this.$window = $window;
	        this.$state = $state;
	        this.uiGridConstants = uiGridConstants;
	        this.commonGridColumns = commonGridColumns;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.buildsDao = BuildsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactsGridOptions = {};
	        this.dependenciesGridOptions = {};
	        this.envVarsGridOptions = {};
	        this.download = JFrogDownload;
	        this.artifactoryGridFactory = JFrogGridFactory;
	
	        this.headerCellDefaultTemplate = JFrogGridFactory.getDefaultCellTemplate();
	
	        this.comparableBuildNumbers = [];
	
	        this.selectedBuildNumber = "";
	        this.excludeInternalDeps = false;
	
	        this._createGrids();
	
	        this._getComparableBuildNumbers();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH, function () {
	            _this._getComparableBuildNumbers().then(function () {
	                if (_this.selectedBuildNumber) {
	                    _this.getDiffData();
	                }
	            });
	        });
	    }
	
	    _createClass(jfDiffController, {
	        _getCellTemplate: {
	            value: function _getCellTemplate(field) {
	                return "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity." + field + "}}</div>";
	            }
	        },
	        _addCellTemplates: {
	            value: function _addCellTemplates(colDef) {
	                for (var i = 0; i < colDef.length; i++) {
	                    var col = colDef[i];
	                    if (!col.cellTemplate) {
	                        col.cellTemplate = this._getCellTemplate(col.field);
	                    }
	                }
	                return colDef;
	            }
	        },
	        _getComparableBuildNumbers: {
	            value: function _getComparableBuildNumbers() {
	                var _this = this;
	
	                return this.buildsDao.getDataArray({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "prevBuild"
	                }).$promise.then(function (data) {
	                    data = _.sortBy(data, function (r) {
	                        return -r.buildNumber;
	                    });
	                    _this.comparableBuildNumbers = data;
	                    if (_this.selectedBuildNumber && !_.find(data, { buildNumber: _this.selectedBuildNumber.buildNumber })) {
	                        delete _this.selectedBuildNumber;
	                    }
	                    //            this.comparableBuildNumbers.unshift({buildNumber:''});
	                });
	            }
	        },
	        getDiffData: {
	            value: function getDiffData() {
	                var _this = this;
	
	                if (this.selectedBuildNumber.buildNumber) {
	                    this.buildsDao.getData({
	                        name: this.$stateParams.buildName,
	                        number: this.$stateParams.buildNumber,
	                        time: this.$stateParams.startTime,
	                        action: "buildDiff",
	                        otherNumber: this.selectedBuildNumber.buildNumber,
	                        otherDate: this.selectedBuildNumber.time,
	                        exDep: this.excludeInternalDeps
	                    }).$promise.then(function (data) {
	                        if (data) {
	                            _this.variablesLength = data.props.length ? data.props.length : 0;
	                            _this.dependenciesLength = data.dependencies.length ? data.dependencies.length : 0;
	                            _this.artifactsLength = data.artifacts.length ? data.artifacts.length : 0;
	
	                            if (data.artifacts) {
	                                _this.artifactsGridOptions.setGridData(data.artifacts || []);
	                            }
	                            if (data.dependencies) {
	                                _this.dependenciesGridOptions.setGridData(data.dependencies || []);
	                            }
	                            if (data.props) {
	                                _this.envVarsGridOptions.setGridData(data.props || []);
	                            }
	                        }
	                    });
	                }
	            }
	        },
	        showInTree: {
	            value: function showInTree(row) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") browser = "tree";
	                var artifactPath = row.repoKey + "/" + row.path;
	                var archivePath = "";
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    browser: browser,
	                    artifact: artifactPath
	                });
	                this.JFrogEventBus.dispatch(EVENTS.TREE_NODE_OPEN, artifactPath);
	            }
	        },
	        downloadArtifact: {
	            value: function downloadArtifact(row) {
	                this.download(row.downloadLink);
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	
	                this.artifactsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getArtifactsColumns()).setRowTemplate("default");
	                this.dependenciesGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getDependenciesColumns()).setRowTemplate("default");
	                this.envVarsGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getEnvVarsColumns()).setRowTemplate("default");
	            }
	        },
	        _getArtifactsColumns: {
	            value: function _getArtifactsColumns() {
	                var _this = this;
	
	                return this._addCellTemplates([{
	                    name: "Name (Current Build)",
	                    field: "name",
	                    cellTemplate: this.commonGridColumns.downloadableColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    width: "20%",
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.find(row.actions, { name: "Download" });
	                            }
	                        }
	                    }
	                }, {
	                    name: "Name",
	                    field: "prevName",
	                    headerCellTemplate: this.headerCellDefaultTemplate.replace("{{ col.displayName CUSTOM_FILTERS }}", "Name (Build #{{grid.appScope.jfDiff.selectedBuildNumber.buildNumber}})"),
	                    width: "20%"
	                }, {
	                    name: "Status",
	                    field: "status",
	                    allowGrouping: true,
	                    sort: { direction: this.uiGridConstants.DESC },
	                    grouped: true,
	                    width: "10%"
	                }, {
	                    name: "Module",
	                    field: "moduleName",
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "20%"
	                }, {
	                    name: "Repo path",
	                    field: "downloadLink",
	                    cellTemplate: this.commonGridColumns.repoPathColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    width: "30%",
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.find(row.actions, { name: "ShowInTree" });
	                        }
	                    }]
	                }]);
	            }
	        },
	        _getDependenciesColumns: {
	            value: function _getDependenciesColumns() {
	                var _this = this;
	
	                return this._addCellTemplates([{
	                    name: "Dependency ID (Current Build)",
	                    displayName: "Dependency ID (Current Build)",
	                    field: "name",
	                    cellTemplate: this.commonGridColumns.downloadableColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    width: "20%",
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return _.find(row.actions, { name: "Download" });
	                            }
	                        }
	                    }
	                }, {
	                    name: "Id",
	                    field: "prevName",
	                    headerCellTemplate: this.headerCellDefaultTemplate.replace("{{ col.displayName CUSTOM_FILTERS }}", "Id (Build #{{grid.appScope.jfDiff.selectedBuildNumber.buildNumber}})"),
	                    width: "20%"
	                }, {
	                    name: "Status",
	                    field: "status",
	                    allowGrouping: true,
	                    sort: { direction: this.uiGridConstants.DESC },
	                    grouped: true,
	                    width: "10%"
	                }, {
	                    name: "Module",
	                    field: "moduleName",
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "20%"
	                }, {
	                    name: "Repo path",
	                    field: "downloadLink",
	                    cellTemplate: this.commonGridColumns.repoPathColumn("status-{{(row.entity.status).toLowerCase()}}"),
	                    width: "30%",
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return _.find(row.actions, { name: "ShowInTree" });
	                        }
	                    }]
	                }]);
	            }
	        },
	        _getEnvVarsColumns: {
	            value: function _getEnvVarsColumns() {
	                return this._addCellTemplates([{
	                    name: "Current Key",
	                    field: "key",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.key}}</div>",
	                    width: "20%"
	                }, {
	                    name: "Current Value",
	                    field: "value",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.value}}</div>",
	                    width: "20%"
	                }, {
	                    name: "Prev Key",
	                    field: "prevKey",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.prevKey}}</div>",
	                    headerCellTemplate: this.headerCellDefaultTemplate.replace("{{ col.displayName CUSTOM_FILTERS }}", "Build#{{grid.appScope.jfDiff.selectedBuildNumber.buildNumber}} Key"),
	                    width: "20%"
	                }, {
	                    name: "Prev Value",
	                    field: "prevValue",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents status-{{(row.entity.status).toLowerCase()}}\">{{row.entity.prevValue}}</div>",
	                    headerCellTemplate: this.headerCellDefaultTemplate.replace("{{ col.displayName CUSTOM_FILTERS }}", "Build#{{grid.appScope.jfDiff.selectedBuildNumber.buildNumber}} Value"),
	                    width: "20%"
	                }, {
	                    name: "Status",
	                    field: "status",
	                    sort: { direction: this.uiGridConstants.DESC },
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "20%"
	                }]);
	            }
	        }
	    });
	
	    return jfDiffController;
	})();
	
	function jfDiff() {
	    return {
	        restrict: "EA",
	        controller: jfDiffController,
	        controllerAs: "jfDiff",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/build_tabs/jf_diff.html"
	    };
	}

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfReleaseHistory = jfReleaseHistory;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var DICTIONARY = _interopRequire(__webpack_require__(341));
	
	var jfReleaseHistoryController = (function () {
	    function jfReleaseHistoryController($stateParams, $scope, BuildsDao, JFrogEventBus) {
	        var _this = this;
	
	        _classCallCheck(this, jfReleaseHistoryController);
	
	        this.$stateParams = $stateParams;
	        this.buildsDao = BuildsDao;
	        this.historyData = null;
	        this.DICTIONARY = DICTIONARY.releaseHistory;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	
	        this._getData();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH, function () {
	            _this._getData();
	        });
	    }
	
	    _createClass(jfReleaseHistoryController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;
	
	                return this.buildsDao.getDataArray({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    action: "releaseHistory"
	                }).$promise.then(function (data) {
	                    _this.historyData = data;
	                })["catch"](function () {
	                    _this.historyData = [];
	                });
	            }
	        }
	    });
	
	    return jfReleaseHistoryController;
	})();
	
	function jfReleaseHistory() {
	    return {
	        restrict: "EA",
	        controller: jfReleaseHistoryController,
	        controllerAs: "jfReleaseHistory",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/build_tabs/jf_release_history.html"
	    };
	}

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfLicenses = jfLicenses;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var jfLicensesController = (function () {
	    function jfLicensesController($scope, $state, $window, $stateParams, BuildsDao, ArtifactPropertyDao, JFrogGridFactory, JFrogModal, ArtifactoryState, JFrogDownload, commonGridColumns, ArtifactActionsDao, ArtifactoryStorage, JFrogEventBus) {
	        var _this = this;
	
	        _classCallCheck(this, jfLicensesController);
	
	        this.TOOLTIP = TOOLTIP.builds;
	        this.$stateParams = $stateParams;
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$window = $window;
	        this.buildsDao = BuildsDao;
	        this.propsDao = ArtifactPropertyDao.getInstance();
	        this.artifactActionsDao = ArtifactActionsDao;
	        this.JFrogEventBus = JFrogEventBus;
	        this.modal = JFrogModal;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.download = JFrogDownload;
	        this.artifactoryState = ArtifactoryState;
	        this.gridOptions = {};
	        this.commonGridColumns = commonGridColumns;
	        this.extendedGridOptions = {};
	
	        this.modalInstance = null;
	
	        this.includePublished = false;
	
	        this.allData = {};
	
	        this.filteredData = {};
	
	        this.scopesOptions = {};
	        this.scopesOptionsCopy = {};
	
	        this.showExtendedGrid = false;
	
	        this.canOverride = true;
	
	        this._createGrids();
	
	        this._getLicensesData();
	
	        this.toOverride = [];
	
	        this.JFrogEventBus.registerOnScope(this.$scope, this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH, function () {
	            _this.allData = {};
	            _this.filteredData = {};
	            _this.scopesOptions = {};
	            _this.scopesOptionsCopy = {};
	            _this.showExtendedGrid = false;
	            _this._getLicensesData();
	        });
	    }
	
	    _createClass(jfLicensesController, {
	        getFilteredData: {
	            value: function getFilteredData() {
	                var data = _.map(angular.copy(this.filteredData), function (obj) {
	                    delete obj.$$hashKey;
	                    return obj;
	                });
	
	                return JSON.stringify({ licenses: data });
	            }
	        },
	        downloadArtifact: {
	            value: function downloadArtifact(row) {
	                var _this = this;
	
	                var params = { action: "download" };
	                this.artifactActionsDao.perform(params, {
	                    path: row.path,
	                    repoKey: row.repoKey
	                }).$promise.then(function (response) {
	                    _this.download(response.data.path);
	                });
	            }
	        },
	        showInTree: {
	            value: function showInTree(row) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") browser = "tree";
	                var path = row.repoKey + "/" + row.path;
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    artifact: path,
	                    browser: browser
	                });
	            }
	        },
	        editLicense: {
	            value: function editLicense(row) {
	                var prevState = { state: this.$state.current.name, params: angular.copy(this.$stateParams) };
	                this.artifactoryState.setState("prevState", prevState);
	                this.$state.go("admin.configuration.editLicense", { licenseName: row.license.name });
	            }
	        },
	        changeLicense: {
	            value: function changeLicense(row) {
	                var _this = this;
	
	                this._getLicensesPredefineValues(row).then(function (data) {
	                    var modalScope = _this.$scope.$new();
	                    modalScope.saveLicenses = function (licenses) {
	                        _this.propsDao.update({
	                            repoKey: row.repoKey,
	                            path: row.path
	                        }, {
	                            parent: { name: "artifactory" },
	                            property: { name: "licenses" },
	                            selectedValues: licenses
	                        }).$promise.then(function (res) {
	                            //console.log(res);
	                            _this.modalInstance.close();
	                            _this._getLicensesData();
	                        });
	                    };
	                    modalScope.closeModal = function () {
	                        return _this.modalInstance.close();
	                    };
	
	                    if (_this.showExtendedGrid && row.extractedLicense.name !== "Not Found") {
	                        modalScope.foundLicense = row.extractedLicense.name;
	
	                        if (row.extractedLicense.found && row.extractedLicense.name !== row.license.name) modalScope.foundLicenseClass = row.extractedLicense.approved ? "license-approved" : "license-unapproved";else if (!row.extractedLicense.found || row.extractedLicense.name === row.license.name) modalScope.foundLicenseClass = "license-found-same-or-notfound";
	
	                        if (row.overridable) {
	                            modalScope.overridable = true;
	                            modalScope.override = function () {
	                                modalScope.selectedLicenses = [row.extractedLicense.name];
	                            };
	                        }
	                    }
	                    modalScope.modalTitle = "Edit 'artifactory.licenses' Property";
	                    modalScope.licenses = data.predefinedValues;
	                    modalScope.selectedLicenses = data.selectedValues;
	                    _this.modalInstance = _this.modal.launchModal("add_license_modal", modalScope);
	                });
	            }
	        },
	        autoLink: {
	            value: function autoLink() {
	                this.showExtendedGrid = true;
	                this._getLicensesData();
	            }
	        },
	        overrideSelected: {
	            value: function overrideSelected() {
	                var _this = this;
	
	                if (this.toOverride.length) {
	                    var requestObject = {
	                        name: this.$stateParams.buildName,
	                        number: this.$stateParams.buildNumber,
	                        time: this.$stateParams.startTime,
	                        licenses: this.toOverride
	                    };
	
	                    this.buildsDao.overrideLicenses(requestObject).$promise.then(function (data) {
	                        _this.cancel();
	                    });
	                }
	            }
	        },
	        cancel: {
	            value: function cancel() {
	                this.showExtendedGrid = false;
	                this._getLicensesData();
	            }
	        },
	        onIncludePublish: {
	            value: function onIncludePublish() {
	                this._filterData();
	            }
	        },
	        onIncludeByScopes: {
	            value: function onIncludeByScopes() {
	                if (this.includeByScopes) {
	                    angular.copy(this.scopesOptionsCopy, this.scopesOptions);
	                } else {
	                    angular.copy(this.scopesOptions, this.scopesOptionsCopy);
	                    for (var key in this.scopesOptions) {
	                        this.scopesOptions[key] = true;
	                    }
	                }
	                this._filterData();
	            }
	        },
	        onScopeOptionChange: {
	            value: function onScopeOptionChange() {
	                this._filterData();
	            }
	        },
	        _getLicensesPredefineValues: {
	            value: function _getLicensesPredefineValues(row) {
	                return this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    autoFind: this.showExtendedGrid,
	                    id: row.id,
	                    repoKey: row.repoKey,
	                    path: row.path,
	                    action: "changeLicenses"
	                }).$promise;
	            }
	        },
	        _getLicensesData: {
	            value: function _getLicensesData() {
	                var _this = this;
	
	                this.buildsDao.getData({
	                    name: this.$stateParams.buildName,
	                    number: this.$stateParams.buildNumber,
	                    time: this.$stateParams.startTime,
	                    autoFind: this.showExtendedGrid,
	                    action: "buildLicenses"
	                }).$promise.then(function (data) {
	                    //console.log(data);
	                    _.map(data.scopes, function (scope) {
	                        _this.scopesOptions[scope] = true;
	                    });
	                    angular.copy(_this.scopesOptions, _this.scopesOptionsCopy);
	                    _this.allData = data;
	                    _this._filterData();
	                });
	            }
	        },
	        _filterData: {
	            value: function _filterData() {
	                var _this = this;
	
	                var relevantData = this.allData.licenses;
	
	                if (this.includePublished) {
	                    relevantData = relevantData.concat(this.allData.publishedModules);
	                }
	
	                this.filteredData = _.filter(relevantData, function (license) {
	                    if (!_this.includeByScopes) return true;else {
	                        var ret = false;
	                        for (var key in _this.scopesOptions) {
	                            if (_this.scopesOptions[key] && license.scopeNames.includes(key)) {
	                                ret = true;
	                                break;
	                            }
	                        }
	                        return ret;
	                    }
	                });
	                if (this.showExtendedGrid) {
	                    this.extendedGridOptions.setGridData(this.filteredData);
	                } else {
	                    this.gridOptions.setGridData(this.filteredData);
	                }
	
	                this._calculateSummary();
	            }
	        },
	        _calculateSummary: {
	            value: function _calculateSummary() {
	                this.summary = {
	                    notApproved: _.filter(this.filteredData, function (license) {
	                        return license.license.found && !license.license.approved;
	                    }).length,
	                    notFound: _.filter(this.filteredData, function (license) {
	                        return license.license.notFound;
	                    }).length,
	                    unknown: _.filter(this.filteredData, function (license) {
	                        return license.license.unknown;
	                    }).length,
	                    neutral: _.filter(this.filteredData, function (license) {
	                        return license.license.notSearched;
	                    }).length,
	                    approved: _.filter(this.filteredData, function (license) {
	                        return license.license.approved;
	                    }).length };
	
	                this.summary.ok = this.summary.notApproved === 0 && this.summary.notFound === 0 && this.summary.unknown === 0;
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default");
	                this.extendedGridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getExtendedColumns()).setRowTemplate("default");
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                var _this = this;
	
	                var nameCellTemplate = "<div ng-if=\"row.entity.repoKey\" class=\"ui-grid-cell-contents\">{{row.entity.id}}</div>" + "<div ng-if=\"!row.entity.repoKey\" class=\"ui-grid-cell-contents\">{{row.entity.id}}</div>";
	
	                var licenseCellTemplate = "<div class=\"ui-grid-cell-contents\"" + "ng-class=\"{'license-unapproved': row.entity.license.found && !row.entity.license.approved," + "'license-approved': row.entity.license.approved," + "'license-notfound': row.entity.license.notFound," + "'license-neutral': row.entity.license.notSearched}\"" + "><div ng-if=\"row.groupHeader\">{{row.entity['license.name']}}</div>" + "<div ng-if=\"!row.groupHeader\">" + "<span ng-if=\"row.entity.actions.indexOf('ChangeLicense') !== -1\"><a href=\"\" ng-click=\"grid.appScope.jfLicenses.changeLicense(row.entity)\">{{row.entity.license.name === \"Unknown\" ? \"Unknown(\" + row.entity.license.longName + \")\" : row.entity.license.name}}</a></span>" + "<span ng-if=\"row.entity.actions.indexOf('ChangeLicense') === -1\">{{row.entity.license.name === \"Unknown\" ? \"Unknown(\" + row.entity.license.longName + \")\" : row.entity.license.name}}</span>" + "</div></div>";
	                return [{
	                    name: "Artifact ID",
	                    displayName: "Artifact ID",
	                    field: "id",
	                    cellTemplate: nameCellTemplate,
	                    width: "25%",
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return row.actions.indexOf("Download") !== -1;
	                            }
	                        }
	                    }
	                }, {
	                    name: "Scopes",
	                    displayName: "Scopes",
	                    field: "scopeNames",
	                    allowGrouping: true,
	                    grouped: true,
	                    width: "12%"
	                }, {
	                    name: "Repo Path",
	                    displayName: "Repo Path",
	                    cellTemplate: this.commonGridColumns.repoPathColumn(),
	                    field: "path",
	                    width: "50%",
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return row.actions.indexOf("ShowInTree") !== -1;
	                        }
	                    }]
	                }, {
	                    name: "License",
	                    displayName: "License",
	                    field: "license.name",
	                    allowGrouping: true,
	                    cellTemplate: licenseCellTemplate,
	                    grouped: true,
	                    width: "13%"
	                }];
	            }
	        },
	        _getExtendedColumns: {
	            value: function _getExtendedColumns() {
	                var _this = this;
	
	                var nameCellTemplate = "<div ng-if=\"row.entity.repoKey\" class=\"ui-grid-cell-contents\">{{row.entity.id}}</div>" + "<div ng-if=\"!row.entity.repoKey\" class=\"ui-grid-cell-contents\">{{row.entity.id}}</div>";
	
	                var licenseCellTemplate = "<div class=\"ui-grid-cell-contents\"" + "ng-class=\"{'license-unapproved': row.entity.license.found && !row.entity.license.approved," + "'license-approved': row.entity.license.approved," + "'license-notfound': row.entity.license.notFound}\"" + "><div ng-if=\"row.groupHeader\">{{row.entity['license.name']}}</div>" + "<div ng-if=\"!row.groupHeader\">" + "<span ng-if=\"row.entity.actions.indexOf('ChangeLicense') !== -1\"><a href=\"\" ng-click=\"grid.appScope.jfLicenses.changeLicense(row.entity)\">{{row.entity.license.name === \"Unknown\" ? \"Unknown(\" + row.entity.license.longName + \")\" : row.entity.license.name}}</a></span>" + "<span ng-if=\"row.entity.actions.indexOf('ChangeLicense') === -1\">{{row.entity.license.name === \"Unknown\" ? \"Unknown(\" + row.entity.license.longName + \")\" : row.entity.license.name}}</span>" + "</div></div>";
	
	                var foundLicenseCellTemplate = "<div class=\"ui-grid-cell-contents\"" + "ng-class=\"{'license-approved': row.entity.extractedLicense.found && row.entity.extractedLicense.name !== row.entity.license.name && row.entity.extractedLicense.approved," + "'license-unapproved': row.entity.extractedLicense.found && row.entity.extractedLicense.name !== row.entity.license.name && !row.entity.extractedLicense.approved," + "'license-found-same-or-notfound': !row.entity.extractedLicense.found || row.entity.extractedLicense.name === row.entity.license.name}\"" + ">{{row.entity.extractedLicense.name === \"Unknown\" ? \"Unknown(\" + row.entity.extractedLicense.longName + \")\" : row.entity.extractedLicense.name}}</div>";
	
	                return [{
	                    name: "Artifact ID",
	                    displayName: "Artifact ID",
	                    field: "id",
	                    cellTemplate: nameCellTemplate,
	                    width: "25%",
	                    actions: {
	                        download: {
	                            callback: function (row) {
	                                return _this.downloadArtifact(row);
	                            },
	                            visibleWhen: function (row) {
	                                return row.actions.indexOf("Download") !== -1;
	                            }
	                        }
	                    }
	                }, {
	                    name: "Scopes",
	                    field: "scopeNames",
	                    allowGrouping: true,
	                    grouped: true
	                }, {
	                    name: "Repo Path",
	                    cellTemplate: this.commonGridColumns.repoPathColumn(),
	                    field: "path",
	                    customActions: [{
	                        icon: "icon icon-show-in-tree",
	                        tooltip: "Show In Tree",
	                        callback: function (row) {
	                            return _this.showInTree(row);
	                        },
	                        visibleWhen: function (row) {
	                            return row.actions.indexOf("ShowInTree") !== -1;
	                        }
	                    }]
	                }, {
	                    name: "License",
	                    field: "license.name",
	                    allowGrouping: true,
	                    cellTemplate: licenseCellTemplate,
	                    grouped: true
	                }, {
	                    name: "Found Licenses",
	                    field: "extractedLicense.name",
	                    cellTemplate: foundLicenseCellTemplate
	                }, {
	                    name: "Override",
	                    field: "selected",
	                    cellTemplate: this.commonGridColumns.checkboxColumn("row.entity.selected", "grid.appScope.jfLicenses.setSelected(row.entity)", "!row.entity.overridable")
	                }];
	            }
	        },
	        setSelected: {
	            value: function setSelected(row) {
	                if (row.selected) {
	                    this.toOverride.push(row);
	                } else {
	                    var index = this.toOverride.indexOf(row);
	                    if (index != -1) {
	                        this.toOverride.splice(index, 1);
	                    }
	                }
	            }
	        },
	        hasScopesOptions: {
	            value: function hasScopesOptions() {
	                return Object.keys(this.scopesOptions).length > 0;
	            }
	        }
	    });
	
	    return jfLicensesController;
	})();
	
	function jfLicenses() {
	    return {
	        restrict: "EA",
	        controller: jfLicensesController,
	        controllerAs: "jfLicenses",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/build_tabs/jf_licenses.html"
	    };
	}

/***/ }),
/* 350 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.jfEffectivePermission = jfEffectivePermission;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var jfEffectivePermissionController = (function () {
	    function jfEffectivePermissionController($stateParams, $scope, BuildsDao, JFrogEventBus, JFrogTableViewOptions, $state, commonGridColumns, User) {
	        var _this = this;
	
	        _classCallCheck(this, jfEffectivePermissionController);
	
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.user = User.getCurrent();
	        this.commonGridColumns = commonGridColumns;
	        this.buildsDao = BuildsDao;
	        this.historyData = null;
	        this.JFrogEventBus = JFrogEventBus;
	        this.$scope = $scope;
	        this.cellTemplateGenerators = JFrogTableViewOptions.cellTemplateGenerators;
	
	        this._getData();
	
	        this.JFrogEventBus.registerOnScope(this.$scope, this.JFrogEventBus.getEventsDefinition().BUILDS_TAB_REFRESH, function () {
	            _this._getData();
	        });
	
	        // Users Table
	        this.usersEffectivePermissionsOptions = {};
	        this.usersEffectivePermissionsOptions = new JFrogTableViewOptions(this.$scope);
	        this.usersEffectivePermissionsOptions.setId("users-effective-permission-table").setObjectName("User").setColumns(this.getColumns());
	
	        // Groups Table
	        this.groupsEffectivePermissionsOptions = {};
	        this.groupsEffectivePermissionsOptions = new JFrogTableViewOptions(this.$scope);
	        this.groupsEffectivePermissionsOptions.setId("groups-effective-permission-table").setObjectName("Group").setColumns(this.getColumns());
	
	        // Permission Targets Table
	        this.permissionTargetsOptions = {};
	        this.permissionTargetsOptions = new JFrogTableViewOptions(this.$scope);
	        this.permissionTargetsOptions.setId("permission-targets-table").setObjectName("Permission Target").setColumns(this.getPermissionTargetsColumns());
	    }
	
	    _createClass(jfEffectivePermissionController, {
	        _getData: {
	            value: function _getData() {
	                var _this = this;
	
	                this.buildsDao.buildEffectivePermission({}, {
	                    name: this.$stateParams.buildName,
	                    buildNumber: this.$stateParams.buildNumber,
	                    startTime: this.$stateParams.startTime
	                }).$promise.then(function (response) {
	                    _this.userEffectivePermissions = response.userEffectivePermissions;
	                    _this.groupEffectivePermissions = response.groupEffectivePermissions;
	                    _this.permissionTargets = response.permissionTargets;
	
	                    _this.usersEffectivePermissionsOptions.setData(_this.userEffectivePermissions);
	                    _this.groupsEffectivePermissionsOptions.setData(_this.groupEffectivePermissions);
	                    _this.permissionTargetsOptions.setData(_this.permissionTargets);
	                });
	            }
	        },
	        getColumns: {
	            value: function getColumns() {
	
	                return [{
	                    header: "Principal",
	                    field: "principal",
	                    filterable: true,
	                    cellTemplate: "<div>{{row.entity.principal}}</div>",
	                    width: "30%"
	                }, {
	                    header: "Permission Target",
	                    field: "permissionTarget",
	                    width: "30%",
	                    cellTemplate: this.cellTemplateGenerators.listableColumn("row.entity.permissionTargets", "row.entity.principal") }, {
	                    header: "Read",
	                    field: "permission.read",
	                    textAlign: "center",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    sortable: false
	                }, {
	                    header: "Annotate",
	                    field: "permission.annotate",
	                    textAlign: "center",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    sortable: false
	                }, {
	                    header: "Upload",
	                    field: "permission.deploy",
	                    textAlign: "center",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    sortable: false
	                }, {
	                    header: "Delete",
	                    textAlign: "center",
	                    field: "permission.delete",
	                    cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
	                    sortable: false
	                }];
	            }
	        },
	        getPermissionTargetsColumns: {
	            value: function getPermissionTargetsColumns() {
	                var _this = this;
	
	                var permissionNameCell = function () {
	                    return _this.user.isAdmin() ? "<div><a class=\"jf-link\" ng-click=\"grid.appScope.jfEffectivePermission.editPermission(row.entity)\">{{row.entity.permissionName}}</a></div>" : "<div>{{row.entity.permissionName}}</div>";
	                };
	
	                return [{
	                    header: "Permission Target Name",
	                    field: "permissionName",
	                    filterable: true,
	                    cellTemplate: permissionNameCell(),
	                    width: "30%"
	                }, {
	                    header: "Users",
	                    field: "users",
	                    cellTemplate: this.cellTemplateGenerators.listableColumn("row.entity.users", "row.entity.permissionName")
	                }, {
	                    header: "Groups",
	                    field: "groups",
	                    cellTemplate: this.cellTemplateGenerators.listableColumn("row.entity.groups", "row.entity.permissionName")
	                }];
	            }
	        },
	        editPermission: {
	            value: function editPermission(row) {
	                this.$state.go("admin.security.permissions.edit", { permission: row.permissionName });
	            }
	        }
	    });
	
	    return jfEffectivePermissionController;
	})();
	
	function jfEffectivePermission() {
	    return {
	        restrict: "EA",
	        controller: jfEffectivePermissionController,
	        controllerAs: "jfEffectivePermission",
	        scope: {},
	        bindToController: true,
	        templateUrl: "states/builds/build_tabs/jf_effective_permission.html"
	    };
	}

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var BundlesListController = __webpack_require__(352).BundlesListController;
	
	var BundlePageController = __webpack_require__(353).BundlePageController;
	
	function bundlesConfig($stateProvider) {
	
	    $stateProvider.state("bundles", {
	        url: "/bundles",
	        templateUrl: "states/bundles/bundles.html",
	        parent: "app-layout" }).state("bundles.list", {
	        url: "/{tab}",
	        templateUrl: "states/bundles/bundles_list.html",
	        controller: "BundlesListController as BundlesList"
	    }).state("bundles.bundle_page", {
	        url: "/{type}/{bundleName}/{version}",
	        templateUrl: "states/bundles/bundle_page.html",
	        controller: "BundlePageController as BundlePage"
	    });
	}
	
	module.exports = angular.module("bundles", []).config(bundlesConfig).controller("BundlesListController", BundlesListController).controller("BundlePageController", BundlePageController);

/***/ }),
/* 352 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var BundlesListController = exports.BundlesListController = (function () {
	    function BundlesListController($scope, $q, BundlesDao, JFrogTableViewOptions, ArtifactoryFeatures, $stateParams, $state) {
	        _classCallCheck(this, BundlesListController);
	
	        this.$scope = $scope;
	        this.$q = $q;
	        this.BundlesDao = BundlesDao;
	        this.JFrogTableViewOptions = JFrogTableViewOptions;
	        this.allBundlesGridOptions = {};
	        this.ArtifactoryFeatures = ArtifactoryFeatures;
	        this.$stateParams = $stateParams;
	        this.$state = $state;
	        this._createGrids();
	        this._getBundlesData();
	    }
	
	    _createClass(BundlesListController, {
	        $onInit: {
	            value: function $onInit() {
	                this.DICTIONARY = {
	                    target: "Received",
	                    source: "Distributable" };
	                this.tabs = [{ name: "target" }, { name: "source" }];
	            }
	        },
	        _getBundlesData: {
	            value: function _getBundlesData() {
	                var _this = this;
	
	                this.BundlesDao.getData({ type: "target" }).$promise.then(function (results) {
	                    _this.targetBundles = results.bundles;
	                    _this.targetTableViewOptions.setData(_this.targetBundles);
	                });
	                this.BundlesDao.getData({ type: "source" }).$promise.then(function (results) {
	                    _this.sourceBundles = results.bundles;
	                    _this.sourceTableViewOptions.setData(_this.sourceBundles);
	                });
	            }
	        },
	        _createGrids: {
	            value: function _createGrids() {
	                this.targetTableViewOptions = new this.JFrogTableViewOptions(this.$scope);
	                this.targetTableViewOptions.setColumns(this._getColumns()).setRowsPerPage(20).setEmptyTableText("No release bundles have been distributed to Artifactory.");
	                this.sourceTableViewOptions = new this.JFrogTableViewOptions(this.$scope);
	                this.sourceTableViewOptions.setColumns(this._getColumns()).setRowsPerPage(20).setEmptyTableText("No release bundles have been distributed from Artifactory.");
	            }
	        },
	        goToBundle: {
	            value: function goToBundle(name, version) {
	                var type = this.$state.params.tab;
	                this.$state.go("bundles.bundle_page", {
	                    type: type,
	                    bundleName: name,
	                    version: version
	                });
	            }
	        },
	        _getColumns: {
	            value: function _getColumns() {
	                return [{
	                    header: "Bundle Name",
	                    field: "name",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">\n                                   <a href class=\"no-cm-action jf-link\" \n                                      ng-click=\"appScope.BundlesList.goToBundle(row.entity.name,row.entity.latestVersion)\">\n                                     {{row.entity.name}}\n                                   </a>\n                               </div>",
	                    width: "55%",
	                    filterable: true
	                }, {
	                    header: "Last Version",
	                    field: "latestVersion",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.latestVersion}}</div>",
	                    width: "20%",
	                    filterable: true
	                }, {
	                    header: "Created",
	                    cellTemplate: "<div class=\"ui-grid-cell-contents\">{{row.entity.created | date: 'd MMMM, yyyy HH:mm:ss Z'}}</div>",
	                    field: "created",
	                    width: "25%"
	                }];
	            }
	        }
	    });
	
	    return BundlesListController;
	})();

/***/ }),
/* 353 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var BundlePageController = exports.BundlePageController = (function () {
	    function BundlePageController($scope, $timeout, $filter, $state, $stateParams, $location, BundlesDao, JFrogUIUtils, JFrogModal, JFrogNotifications) {
	        _classCallCheck(this, BundlePageController);
	
	        this.$scope = $scope;
	        this.$filter = $filter;
	        this.$state = $state;
	        this.$timeout = $timeout;
	        this.$stateParams = $stateParams;
	        this.BundleDao = BundlesDao;
	        this.$location = $location;
	        this.JFrogUIUtils = JFrogUIUtils;
	        this.BundlesDao = BundlesDao;
	        this.artifactoryModal = JFrogModal;
	        this.notifications = JFrogNotifications;
	    }
	
	    _createClass(BundlePageController, {
	        $onInit: {
	            value: function $onInit() {
	                this._getBundleVersions();
	                this.fileInfo = [];
	                this.activeItem = "";
	            }
	        },
	        _getBundleVersions: {
	            value: function _getBundleVersions() {
	                var _this = this;
	
	                this.BundleDao.getBundleVersions({
	                    type: this.$stateParams.type,
	                    name: this.$stateParams.bundleName
	                }).$promise.then(function (data) {
	
	                    // Go to bundle list page if no versions exist
	                    if (_.isEmpty(data.versions)) {
	                        _this.backToBundles(_this.$stateParams.type);
	                        return;
	                    }
	
	                    _this.versions = _.sortBy(data.versions, function (i) {
	                        return -i.created;
	                    });
	
	                    // Go to first version if version isn't exist
	                    var versionsList = _this.versions.map(function (version) {
	                        return version.version;
	                    });
	                    if (!_.includes(versionsList, _this.$stateParams.version)) _this.goToVersion(_this.versions[0]);
	
	                    _this._getBundleData(_this.$stateParams.type, _this.$stateParams.bundleName, _this.$stateParams.version);
	
	                    _this.scrollToVersion();
	                });
	            }
	        },
	        _getBundleData: {
	            value: function _getBundleData(type, name, version) {
	                var _this = this;
	
	                this.BundleDao.getBundleData({ type: type, name: name, version: version }).$promise.then(function (data) {
	                    var artifacts = data.artifacts;
	                    _this.artifactsList = [];
	
	                    // Group by component name
	                    artifacts = _.groupBy(artifacts, "component_name");
	
	                    // sorting the artifacts object alphabetic
	                    Object.keys(artifacts).sort().forEach(function (key) {
	                        if (key !== "undefined") {
	                            _this.artifactsList.push({ key: key, value: artifacts[key] });
	                        }
	                    });
	
	                    _this.artifactsList.push({ key: "undefined", value: artifacts.undefined });
	
	                    // find the first item in first drawer and select it by default
	                    var firstItem = _this.artifactsList[0].value[0];
	                    if (firstItem) _this.updateFileInfo(firstItem, true);
	
	                    _this.summaryColumns = _this.getSummaryColumns();
	                    _this.bundleData = data;
	                });
	            }
	        },
	        updateFileInfo: {
	            value: function updateFileInfo(fileInfo) {
	                var scrpllTop = arguments[1] === undefined ? false : arguments[1];
	
	                this.activeItem = fileInfo.name;
	                this.fileInfo = [{ label: "Name", value: fileInfo.name || "" }, { label: "Path", value: fileInfo.path || "", copy: true }, { label: "Created", value: fileInfo.created || "" }, { label: "Version", value: fileInfo.component_version || "" }, { label: "Path", value: fileInfo.path || "" }, { label: "Size", value: this.formatFileSize(fileInfo.size) || "" }];
	
	                if (scrpllTop) {
	                    $(".inner-data-wrapper > div").scrollTop(0);
	                }
	            }
	        },
	        getSummaryColumns: {
	            value: function getSummaryColumns() {
	                return [{
	                    label: "Version ID",
	                    "class": "name",
	                    template: "{{BundlePage.bundleData.version}}",
	                    isActive: true
	                }, {
	                    label: "Short Description",
	                    "class": "short-description",
	                    template: "{{BundlePage.bundleData.desc}}",
	                    isActive: "{{!!BundlePage.bundleData.desc.length}}",
	                    width: "2fr"
	                }, {
	                    label: "Creation Date",
	                    "class": "creation-date",
	                    template: "{{BundlePage.bundleData.created | date:\"d MMMM, yyyy HH:mm:ss\"}}",
	                    isActive: true
	                }, {
	                    label: "Size",
	                    "class": "size",
	                    template: "{{BundlePage.bundleData.size | filesize}}",
	                    isActive: true
	                }];
	            }
	        },
	        deleteBundleVersion: {
	            value: function deleteBundleVersion(e, version) {
	                var _this = this;
	
	                e.stopPropagation();
	
	                var bundleName = this.$stateParams.bundleName;
	                var bundleVersion = version.version;
	                var index = _.findIndex(this.versions, function (version) {
	                    return version.version === bundleVersion;
	                });
	                var isDeleteingActiveVersion = bundleVersion === this.$stateParams.version;
	
	                this.artifactoryModal.confirm("Are you sure you want to delete version " + bundleVersion + " of the " + bundleName + " release bundle?", "Delete Release Bundle").then(function () {
	                    _this.BundlesDao.deleteBundles({
	                        type: _this.$stateParams.type,
	                        name: bundleName,
	                        version: bundleVersion }).$promise.then(function () {
	                        if (index === 0 && _this.versions.length === 1) {
	                            _this.backToBundles("bundles.list", _this.$stateParams.type);
	                        } else if (isDeleteingActiveVersion) {
	                            _this.versions.splice(index, 1);
	                            if (index === 0) {
	                                _this.goToVersion(_this.versions[0]);
	                            } else {
	                                _this.goToVersion(_this.versions[index - 1]);
	                            }
	                        } else {
	                            _this.versions.splice(index, 1);
	                        }
	                        _this.notifications.create({ info: "You successfully removed version " + bundleVersion + " from " + bundleName + " bundle" });
	                    });
	                });
	            }
	        },
	        goToVersion: {
	            value: function goToVersion(version) {
	                var _this = this;
	
	                _.extend(this.$stateParams, {
	                    type: this.$stateParams.type,
	                    version: version.version,
	                    bundleName: this.$state.params.bundleName
	                });
	
	                this.$state.go(".", this.$stateParams, { location: true, inherit: true, relative: this.$state.$current, notify: false, reload: true }).then(function () {
	                    _this._getBundleData(_this.$stateParams.type, _this.$stateParams.bundleName, _this.$stateParams.version);
	                });
	            }
	        },
	        formatFileSize: {
	            value: function formatFileSize(bytes) {
	                return this.$filter("filesize")(bytes);
	            }
	        },
	        scrollToVersion: {
	            value: function scrollToVersion() {
	                this.$timeout(function () {
	                    $(".versions-wrapper").animate({ scrollTop: $(".versions-wrapper .active").offset().top - 350 }, 350);
	                });
	            }
	        },
	        backToBundles: {
	            value: function backToBundles(type) {
	                this.$state.go("bundles.list", { tab: type });
	            }
	        }
	    });
	
	    return BundlePageController;
	})();

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var HomeController = __webpack_require__(355).HomeController;
	
	function homeConfig($stateProvider) {
	
	    $stateProvider.state("home", {
	        url: "/home",
	        parent: "app-layout",
	        templateUrl: "states/home/home.html",
	        controller: "HomeController as Home",
	        onExit: function (TreeBrowserDao) {
	            TreeBrowserDao.invalidateRoots();
	        } });
	}
	
	module.exports = angular.module("home", []).config(homeConfig).controller("HomeController", HomeController);

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var ArtifactCountController = __webpack_require__(356).ArtifactCountController;
	
	var VersionController = __webpack_require__(357).VersionController;
	
	var UpdatesController = __webpack_require__(358).UpdatesController;
	
	var QuickSearchController = __webpack_require__(359).QuickSearchController;
	
	var AddonsController = __webpack_require__(360).AddonsController;
	
	var LinksController = __webpack_require__(361).LinksController;
	
	var MostDownloadedController = __webpack_require__(362).MostDownloadedController;
	
	var LastDeployedController = __webpack_require__(363).LastDeployedController;
	
	var SetMeUpWidgetController = __webpack_require__(364).SetMeUpWidgetController;
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var HomeController = exports.HomeController = (function () {
	    function HomeController($timeout, $scope, User, ArtifactoryState, ArtifactoryFeatures, HomePageDao, JFrogEventBus, GoogleAnalytics) {
	        var _this = this;
	
	        _classCallCheck(this, HomeController);
	
	        this.$timeout = $timeout;
	        this.$scope = $scope;
	        this.homePageDao = HomePageDao;
	        this.user = User.getCurrent();
	        this.features = ArtifactoryFeatures;
	        this.ArtifactoryState = ArtifactoryState;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.widgetsOptions = {
	            padding: 15,
	            minHeight: 490
	        };
	        var url = "https://jfrog.com/artifactory/eula/";
	        this.homeTitle = "Artifactory is happily serving";
	        if (this.features.isConanCE()) {
	            url = "https://jfrog.com/aritfactory-community-edition-c-c-eula/";
	        } else if (this.features.isJCR()) {
	            // todo:JCR: set proper eula link
	            this.homeTitle = "JFrog Container Registry is happily serving";
	            url = "https://jfrog.com/aritfactory-community-edition-c-c-eula/";
	        }
	        this.footerText = "Other than JFrog's trademarks, marks and logos, all other trademarks displayed in this application are owned by their respective holders. JFrog is not sponsored by, endorsed by or affiliated with the holders of these trademarks. More info here - <a target=_blank\" href=\"https://jfrog.com/artifactory/cloud-eula/\" class=\"jf-link\">Terms of Use</a>,<a target=_blank\" class=\"jf-link\" href=\"" + url + "\">EULA</a>.";
	
	        this.defineWidgets();
	        this.createLayout();
	
	        JFrogEventBus.register(EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.getData();
	        });
	
	        this.getData();
	        this.isAol = function () {
	            return _this.features.isAol();
	        };
	        this.jfNewsIsOn = false; // Turns jf_news on / off
	    }
	
	    _createClass(HomeController, {
	        getData: {
	            value: function getData() {
	                var _this = this;
	
	                this.homepageData = {};
	                this.homePageDao.get({ widgetName: "artifactCount" }).$promise.then(function (data) {
	                    _.extend(_this.homepageData, data.widgetData);
	                    _this.homePageDao.get({ widgetName: "info" }).$promise.then(function (data) {
	                        _.extend(_this.homepageData, data.widgetData);
	                    });
	                });
	            }
	        },
	        defineWidgets: {
	            value: function defineWidgets() {
	                this.widgets = {
	                    artifactCount: {
	                        name: "Artifacts Count",
	                        id: "artifacts-count",
	                        templateUrl: "home_widgets/artifacts_count_widget/artifacts_count.html",
	                        controller: ArtifactCountController,
	                        scroll: false,
	                        showSpinner: true },
	                    version: {
	                        name: "Version",
	                        id: "version",
	                        templateUrl: "home_widgets/version_widget/version.html",
	                        controller: VersionController,
	                        scroll: false,
	                        showSpinner: true },
	                    updates: {
	                        name: "Updates",
	                        id: "updates",
	                        templateUrl: "home_widgets/updates_widget/updates.html",
	                        controller: UpdatesController,
	                        scroll: true,
	                        showSpinner: true
	                    },
	                    quickSearch: {
	                        name: "Quick Search",
	                        id: "quick-search",
	                        templateUrl: "home_widgets/quick_search/quick_search.html",
	                        controller: QuickSearchController,
	                        scroll: false,
	                        showSpinner: false
	                    },
	                    addons: {
	                        name: "Addons",
	                        id: "addons",
	                        templateUrl: "home_widgets/addons_widget/addons.html",
	                        controller: AddonsController,
	                        scroll: false,
	                        showSpinner: true },
	                    usefulLinks: {
	                        name: "Useful Links",
	                        templateUrl: "home_widgets/links_widget/links.html",
	                        controller: LinksController,
	                        scroll: false,
	                        showSpinner: false
	                    },
	                    lastDeployed: {
	                        name: "Last Deployed",
	                        id: "last-deployed",
	                        templateUrl: "home_widgets/last_deployed_widget/last_deployed.html",
	                        controller: LastDeployedController,
	                        scroll: true,
	                        showSpinner: true
	                    },
	                    mostDownloaded: {
	                        name: "Most Downloaded",
	                        id: "most-downloaded",
	                        templateUrl: "home_widgets/most_downloaded_widget/most_downloaded.html",
	                        controller: MostDownloadedController,
	                        scroll: true,
	                        showSpinner: true
	                    },
	                    setMeUp: {
	                        name: "Set me up",
	                        id: "set-me-up",
	                        templateUrl: "home_widgets/set_me_up_widget/set-me-up.html",
	                        controller: SetMeUpWidgetController,
	                        scroll: true,
	                        showSpinner: true
	                    } };
	            }
	        },
	        createLayout: {
	            value: function createLayout() {
	                this.widgetsLayout = {
	                    main: {
	                        rows: [{
	                            size: "73%",
	                            cells: ["100% #top"]
	                        }, {
	                            size: "27%",
	                            cells: ["100% #bottom"]
	                        }]
	                    },
	                    top: {
	                        main: {
	                            rows: [{
	                                size: "100%",
	                                cells: ["33% #topLeft", "34% #topCenter", "33% #topRight"]
	                            }]
	                        },
	                        topLeft: {
	                            columns: [{
	                                size: "100%",
	                                cells: ["40% @quickSearch", "60% @usefulLinks"]
	                            }]
	                        },
	                        topCenter: {
	                            main: {
	                                columns: [{
	                                    size: "100%",
	                                    cells: ["100% @setMeUp"]
	                                }]
	                            }
	                        },
	                        topRight: {
	                            columns: [{
	                                size: "100%",
	                                cells: ["50% @lastDeployed", "50% @mostDownloaded"]
	                            }]
	                        }
	                    },
	                    bottom: {
	                        columns: [{
	                            size: "100%",
	                            cells: ["100% @addons"]
	                        }]
	                    }
	                };
	
	                if (this.features.isEdgeNode()) this.widgetsLayout.top.topRight.columns[0].cells = ["100% @mostDownloaded"];
	            }
	        }
	    });
	
	    return HomeController;
	})();

/***/ }),
/* 356 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var ArtifactCountController = exports.ArtifactCountController = (function () {
	    function ArtifactCountController(HomePageDao) {
	        _classCallCheck(this, ArtifactCountController);
	
	        this.homePageDao = HomePageDao;
	        this.initHomePage();
	        this.updateCount();
	    }
	
	    _createClass(ArtifactCountController, {
	        initHomePage: {
	            value: function initHomePage() {
	                var _this = this;
	
	                this.homePageDao.get({ widgetName: "artifactCount" }).$promise.then(function (data) {
	                    _this.homepageData = data.widgetData;
	                    _this.$widgetObject.showSpinner = false;
	                });
	            }
	        },
	        updateCount: {
	            value: function updateCount() {
	                this.$widgetObject.showSpinner = true;
	                this.initHomePage();
	            }
	        }
	    });
	
	    return ArtifactCountController;
	})();

/***/ }),
/* 357 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var VersionController = exports.VersionController = (function () {
	    function VersionController(HomePageDao) {
	        _classCallCheck(this, VersionController);
	
	        this.homePageDao = HomePageDao;
	        this.initHomePage();
	    }
	
	    _createClass(VersionController, {
	        initHomePage: {
	            value: function initHomePage() {
	                var _this = this;
	
	                this.homePageDao.get({ widgetName: "info" }).$promise.then(function (data) {
	                    _this.homepageData = data.widgetData;
	                    _this.$widgetObject.showSpinner = false;
	                });
	            }
	        }
	    });
	
	    return VersionController;
	})();

/***/ }),
/* 358 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var UpdatesController = exports.UpdatesController = (function () {
	    function UpdatesController(User, $timeout) {
	        _classCallCheck(this, UpdatesController);
	
	        this.$timeout = $timeout;
	        this.showNews = false;
	        var offlineMode = User.getCurrent().offlineMode;
	        if (!offlineMode) this.readUpdateHTML();
	    }
	
	    _createClass(UpdatesController, {
	        readUpdateHTML: {
	            value: function readUpdateHTML() {
	                var _this = this;
	
	                var xhr = new XMLHttpRequest();
	                xhr.open("GET", "https://service.jfrog.org/artifactory/updatesv4", true);
	                xhr.onreadystatechange = function () {
	                    _this.updateHTML = xhr.response;
	                    _this.$scope.$apply();
	
	                    //twitter button javascript !
	                    !(function (d, s, id) {
	                        var js,
	                            fjs = d.getElementsByTagName(s)[0],
	                            p = /^http:/.test(d.location) ? "http" : "https";
	                        if (!d.getElementById(id)) {
	                            js = d.createElement(s);
	                            js.id = id;js.src = p + "://platform.twitter.com/widgets.js";
	                            fjs.parentNode.insertBefore(js, fjs);
	                        }
	                    })(document, "script", "twitter-wjs");
	
	                    _this.$scope.$on("$destroy", function () {
	                        var twitter = document.getElementById("twitter-wjs");
	                        if (twitter) twitter.remove();
	                    });
	
	                    if (xhr.response) {
	                        _this.$timeout(function () {
	                            _this.showNews = true;
	                            _this.$widgetObject.showSpinner = false;
	                        }, 200);
	                    }
	                };
	                xhr.send();
	            }
	        }
	    });
	
	    return UpdatesController;
	})();

/***/ }),
/* 359 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var QuickSearchController = exports.QuickSearchController = (function () {
	    function QuickSearchController($state, ArtifactoryFeatures, GoogleAnalytics) {
	        _classCallCheck(this, QuickSearchController);
	
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.$state = $state;
	        this.features = ArtifactoryFeatures;
	
	        this.links = [{
	            title: "Package\nSearch",
	            search: "package"
	        }, {
	            title: "Archive\nSearch",
	            search: "archive"
	        }, {
	            title: "Property\nSearch",
	            search: "property"
	        }, {
	            title: "Checksum\nSearch",
	            search: "checksum"
	        }, {
	            title: "JCenter\nSearch",
	            search: "remote"
	        }];
	
	        if (this.features.isEdgeNode() || this.features.isConanCE() || this.features.isJCR()) {
	            this.links = _.filter(this.links, function (link) {
	                return link.search != "remote";
	            });
	        }
	    }
	
	    _createClass(QuickSearchController, {
	        search: {
	            value: function search() {
	                if (!this.query) {
	                    return;
	                }var query = {
	                    search: "quick",
	                    query: this.query
	                };
	                this.$state.go("search", { searchType: "quick", query: btoa(JSON.stringify(query)), fromHome: true });
	            }
	        },
	        gotoSearch: {
	            value: function gotoSearch(searchType) {
	                this.GoogleAnalytics.trackEvent("Homepage", "Quick Search link", searchType);
	                this.$state.go("search", { searchType: searchType });
	            }
	        }
	    });
	
	    return QuickSearchController;
	})();

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var FIELD_OPTIONS = _interopRequire(__webpack_require__(135));
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var AddonsController = exports.AddonsController = (function () {
	    function AddonsController(HomePageDao, $timeout, $interval, JFrogEventBus) {
	        var _this = this;
	
	        _classCallCheck(this, AddonsController);
	
	        this.homePageDao = HomePageDao;
	
	        this.$timeout = $timeout;
	        this.$interval = $interval;
	
	        this.tabOptions = ["All", "Package Management", "Features", "Ecosystem", "Available"];
	        this.currentType = this.tabOptions[0];
	
	        this.getData();
	
	        $(window).resize(function () {
	            _this.$timeout(function () {
	                return _this.calculateAddonSize();
	            }, 100);
	        });
	        JFrogEventBus.register(EVENTS.REFRESH_PAGE_CONTENT, function () {
	            _this.$widgetObject.showSpinner = true;
	            _this.getData();
	        });
	
	        this.addonsAnimation = undefined;
	        this.logColor = "color: green;";
	
	        window.move1 = this._move1.bind(this);
	        window.move3 = this._move3.bind(this);
	        window.moveAll = this._moveAll.bind(this);
	
	        this.lastDeltaX = 1;
	    }
	
	    _createClass(AddonsController, {
	        getData: {
	            value: function getData() {
	                var _this = this;
	
	                this.homePageDao.get({ widgetName: "addon" }).$promise.then(function (data) {
	                    _this.addons = data.widgetData.addons;
	
	                    var remainInOneLine = ["git-lfs", "sumo-logic", "ivy", "xray", "jfrog-cli", "plugin"]; // This items should remain in one line
	                    var brake3WordsAfter2ndWord = ["s3fileStore", "gcs", "distribution"]; // This items has 3 words and needs to brake after the second word
	                    var brake3WordsAfter1stWord = ["smart-repo", "sso"]; // This items has 3 words and needs to brake after the first word
	
	                    _.forEach(_this.addons, function (addon) {
	                        if (!_.includes(remainInOneLine, addon.name) && !_.includes(brake3WordsAfter2ndWord, addon.name) && !_.includes(brake3WordsAfter1stWord, addon.name)) {
	                            addon.displayName = addon.displayName.split(" ").join("\n");
	                        }
	                        if (_.includes(brake3WordsAfter2ndWord, addon.name)) {
	                            var splitDisplayName = addon.displayName.split(" ");
	                            var newDisplayName = splitDisplayName[0] + " " + splitDisplayName[1] + "\n" + splitDisplayName[2];
	
	                            addon.displayName = newDisplayName;
	                        }
	                        if (_.includes(brake3WordsAfter1stWord, addon.name)) {
	                            var splitDisplayName = addon.displayName.split(" ");
	                            var newDisplayName = splitDisplayName[0] + "\n" + splitDisplayName[1] + " " + splitDisplayName[2];
	
	                            addon.displayName = newDisplayName;
	                        }
	                    });
	
	                    _this.$timeout(function () {
	                        _this.calculateAddonSize();
	                        _this.$widgetObject.showSpinner = false;
	                    }, 100);
	                });
	            }
	        },
	        getIcon: {
	            value: function getIcon(addonName) {
	                var packageData = _.find(FIELD_OPTIONS.repoPackageTypes, { value: addonName });
	                return "iconrepo-" + (packageData ? packageData.icon : addonName);
	            }
	        },
	        sortByCurrentType: {
	            value: function sortByCurrentType() {
	                var _this = this;
	
	                this.addons = _.filter(this.allAddons, function (addon) {
	                    return addon.categories.indexOf(_this._camelize(_this.currentType)) !== -1;
	                });
	                $(".addon-icon").removeClass("swelling");
	
	                // Commented out until we get a clearance from Yoav
	                // setTimeout(this.animateAddons.bind(this),100)
	
	                this.$timeout(function () {
	                    _this.freezeSwitchMenu();
	                });
	            }
	        },
	        _camelize: {
	            value: function _camelize(str) {
	                return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function (letter, index) {
	                    return index == 0 ? letter.toLowerCase() : letter.toUpperCase();
	                }).replace(/\s+/g, "");
	            }
	        },
	        freezeSwitchMenu: {
	            value: function freezeSwitchMenu() {
	                var swichMenu = $(".homepage-switch");
	                swichMenu.css({
	                    position: "fixed",
	                    width: $(".card.stretch").prop("clientWidth")
	                });
	                $(".addon-list").css("padding-top", 100);
	            }
	        },
	        calculateAddonSize: {
	            value: function calculateAddonSize() {
	                var addonWrapperWidth = $(".addons-wrapper").width();
	                this.numberOfItemsInLine = Math.round(addonWrapperWidth / 200);
	                this.tileWidth = addonWrapperWidth / this.numberOfItemsInLine;
	
	                $(".addon-tile").width(this.tileWidth);
	
	                this.ready = true;
	            }
	        },
	        addonPrevButton: {
	            value: function addonPrevButton() {
	
	                if ($(".addon-tile").is(":animated")) {
	                    return false;
	                }var addonItem = $(".addon-tile").last();
	                addonItem.insertBefore($(".addon-tile").first()).css("margin-left", -this.tileWidth);
	                addonItem.animate({ "margin-left": 0 }, 250);
	            }
	        },
	        addonNextButton: {
	            value: function addonNextButton() {
	
	                if ($(".addon-tile").is(":animated")) {
	                    return false;
	                }var addonItem = $(".addon-tile").first();
	
	                addonItem.animate({ "margin-left": -this.tileWidth }, 250);
	                this.$timeout(function () {
	                    addonItem.insertAfter($(".addon-tile").last());
	                    $(".addon-tile").css("margin-left", "");
	                }, 250);
	            }
	        },
	        _clearInterval: {
	            value: function _clearInterval() {
	                if (angular.isDefined(this.addonsAnimation)) {
	                    this.$interval.cancel(this.addonsAnimation);
	                    this.addonsAnimation = undefined;
	                }
	            }
	        },
	        _move1: {
	            value: function _move1() {
	                var _this = this;
	
	                var time = arguments[0] === undefined ? 5000 : arguments[0];
	
	                this._clearInterval();
	                this.addonsAnimation = this.$interval(function () {
	                    if ($(".addon-tile:hover").length > 0) return false;
	                    _this.addonNextButton();
	                }, time);
	                console.log("%cSwitched to move 1 at a time", this.logColor);
	            }
	        },
	        _move3: {
	            value: function _move3() {
	                var _this = this;
	
	                var time = arguments[0] === undefined ? 5000 : arguments[0];
	
	                this._clearInterval();
	                this.addonsAnimation = this.$interval(function () {
	                    if ($(".addon-tile").is(":animated") || $(".addon-tile:hover").length > 0) return false;
	                    var addonItems = $(".addon-tile:nth-child(-n+3)");
	                    addonItems.eq(0).animate({ "margin-left": -_this.tileWidth * 3 }, 250 * 3);
	                    _this.$timeout(function () {
	                        addonItems.insertAfter($(".addon-tile").last());
	                        $(".addon-tile").css("margin-left", "");
	                    }, 250 * 3);
	                }, time);
	                console.log("%cSwitched to move 3 at a time", this.logColor);
	            }
	        },
	        _moveAll: {
	            value: function _moveAll() {
	                var _this = this;
	
	                var time = arguments[0] === undefined ? 5000 : arguments[0];
	
	                this._clearInterval();
	
	                this.addonsAnimation = this.$interval(function () {
	                    if ($(".addon-tile").is(":animated") || $(".addon-tile:hover").length > 0) return false;
	                    var addonItems = $(".addon-tile:nth-child(-n+" + _this.numberOfItemsInLine + ")");
	                    addonItems.eq(0).animate({ "margin-left": -_this.tileWidth * _this.numberOfItemsInLine }, 250 * _this.numberOfItemsInLine);
	                    _this.$timeout(function () {
	                        addonItems.insertAfter($(".addon-tile").last());
	                        $(".addon-tile").css("margin-left", "");
	                    }, 250 * _this.numberOfItemsInLine);
	                }, time);
	
	                console.log("%cSwitched to move all the line at a time", this.logColor);
	            }
	        },
	        onMouseWheel: {
	            value: function onMouseWheel($event, $delta, $deltaX, $deltaY) {
	                $event.preventDefault();
	
	                if ($deltaX !== 0) {
	                    if (this.lastDeltaX !== undefined && Math.abs($deltaX) <= this.lastDeltaX) {
	                        this.lastDeltaX = Math.abs($deltaX);
	                        return;
	                    } else {
	                        this.lastDeltaX = Math.abs($deltaX);
	                    }
	                }
	
	                if ($deltaX < 0) {
	                    this.addonPrevButton();
	                } else if ($deltaX > 0) {
	                    this.addonNextButton();
	                } else if ($delta > 0) {
	                    this.addonPrevButton();
	                } else if ($delta < 0) {
	                    this.addonNextButton();
	                }
	            }
	        }
	    });
	
	    return AddonsController;
	})();

/***/ }),
/* 361 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var LinksController = exports.LinksController = (function () {
	    function LinksController(GoogleAnalytics, ArtifactoryFeatures) {
	        _classCallCheck(this, LinksController);
	
	        this.features = ArtifactoryFeatures;
	        this.GoogleAnalytics = GoogleAnalytics;
	
	        this.links = [{
	            linkText: "User Guide",
	            "class": "user-guide",
	            url: "https://service.jfrog.org/artifactory/home/userguide",
	            svg: "images/userguide.467.svg"
	        }, {
	            linkText: "Webinar Signup",
	            "class": "webinar",
	            url: "https://service.jfrog.org/artifactory/home/webinars",
	            svg: "images/webinar.467.svg"
	        }, {
	            linkText: "Support Portal",
	            "class": "support",
	            url: "https://service.jfrog.org/artifactory/home/supportportal",
	            svg: "images/support.467.svg"
	        }, {
	            linkText: "Stack Overflow",
	            "class": "stackoverflow",
	            url: "https://service.jfrog.org/artifactory/home/stackoverflow",
	            svg: "images/stackoverflow.467.svg"
	        }, {
	            linkText: "Blog",
	            "class": "blogs",
	            url: "https://service.jfrog.org/artifactory/home/blog",
	            svg: "images/blogs.467.svg"
	        }, {
	            linkText: "Rest API",
	            "class": "rest-api",
	            url: "https://service.jfrog.org/artifactory/home/restapi",
	            svg: "images/rest_api.467.svg"
	        }];
	
	        if (this.features.isJCR()) {
	            var stackoverflowIndex = _.findIndex(this.links, function (i) {
	                return i["class"] === "stackoverflow";
	            });
	            this.links[stackoverflowIndex].url = "https://stackoverflow.com/questions/tagged/jfrog-container-registry";
	        }
	    }
	
	    _createClass(LinksController, {
	        linkClick: {
	            value: function linkClick(linkText) {
	                this.GoogleAnalytics.trackEvent("Homepage", "Knowledge Resources Link", linkText);
	            }
	        }
	    });
	
	    return LinksController;
	})();

/***/ }),
/* 362 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var MostDownloadedController = exports.MostDownloadedController = (function () {
	    function MostDownloadedController(HomePageDao, $timeout, ArtifactoryDeployModal, GoogleAnalytics) {
	        _classCallCheck(this, MostDownloadedController);
	
	        this.homePageDao = HomePageDao;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.deployModal = ArtifactoryDeployModal;
	        this.data = {};
	        this.getData(false);
	    }
	
	    _createClass(MostDownloadedController, {
	        getData: {
	            value: function getData(force) {
	                var _this = this;
	
	                this.mostDownloaded;
	                this.homePageDao.get({ widgetName: "mostDownloaded", force: force }).$promise.then(function (data) {
	                    data.widgetData.mostDownloaded.forEach(function (item) {
	                        item.name = item.path.substr(item.path.lastIndexOf("/") + 1);
	                    });
	                    _this.data = data.widgetData;
	                    _this.mostDownloaded = true;
	                    if (_this.mostDownloaded) {
	                        _this.$widgetObject.showSpinner = false;
	                    }
	                });
	
	                this.dateTime = new Date().getTime();
	            }
	        },
	        refresh: {
	            value: function refresh() {
	                this.$widgetObject.showSpinner = true;
	                this.getData(true);
	            }
	        },
	        itemClick: {
	            value: function itemClick() {
	                this.GoogleAnalytics.trackEvent("Homepage", "Most downloaded item click");
	            }
	        }
	    });
	
	    return MostDownloadedController;
	})();

/***/ }),
/* 363 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var LastDeployedController = exports.LastDeployedController = (function () {
	    function LastDeployedController(HomePageDao, $timeout, ArtifactoryDeployModal, GoogleAnalytics) {
	        _classCallCheck(this, LastDeployedController);
	
	        this.homePageDao = HomePageDao;
	        this.GoogleAnalytics = GoogleAnalytics;
	        this.deployModal = ArtifactoryDeployModal;
	        this.data = {};
	        this.getData();
	    }
	
	    _createClass(LastDeployedController, {
	        getData: {
	            value: function getData() {
	                var _this = this;
	
	                this.lastDeployed;
	
	                this.homePageDao.get({ widgetName: "latestBuilds" }).$promise.then(function (data) {
	                    _this.data = data.widgetData;
	                    _this.lastDeployed = true;
	                    if (_this.lastDeployed) {
	                        _this.$widgetObject.showSpinner = false;
	                    }
	                });
	                this.dateTime = new Date().getTime();
	            }
	        },
	        refresh: {
	            value: function refresh() {
	                this.$widgetObject.showSpinner = true;
	                this.getData();
	            }
	        },
	        itemClick: {
	            value: function itemClick() {
	                this.GoogleAnalytics.trackEvent("Homepage", "Last deployed item click");
	            }
	        }
	    });
	
	    return LastDeployedController;
	})();

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var fieldOptions = _interopRequire(__webpack_require__(135));
	
	var SetMeUpWidgetController = exports.SetMeUpWidgetController = (function () {
		function SetMeUpWidgetController(TreeBrowserDao, SetMeUpModal, JFrogEventBus, ArtifactoryState, GoogleAnalytics) {
			var _this = this;
	
			_classCallCheck(this, SetMeUpWidgetController);
	
			this.treeBrowserDao = TreeBrowserDao;
			this.ArtifactoryState = ArtifactoryState;
			this.GoogleAnalytics = GoogleAnalytics;
			this.SetMeUpModal = SetMeUpModal;
			this.noReposToFetch = false;
			var EVENTS = JFrogEventBus.getEventsDefinition();
	
			JFrogEventBus.register(EVENTS.REFRESH_SETMEUP_WIZARD, function () {
				_this.$widgetObject.showSpinner = true;
				_this.fetchAllRepoList();
			});
	
			this.packageTypes = _.cloneDeep(fieldOptions.repoPackageTypes);
			this.fetchAllRepoList(true);
			this.loading = false;
		}
	
		_createClass(SetMeUpWidgetController, {
			setOnScroll: {
				value: function setOnScroll() {
					var _this = this;
	
					var EDGE = 10;
					setTimeout(function () {
						var scrollParent = $(".list-content-scrolling-container");
						_this.scrollParent = scrollParent;
						scrollParent.on("scroll", function (e) {
							if (scrollParent[0].scrollHeight - scrollParent.scrollTop() <= scrollParent[0].clientHeight + EDGE) {
								if (!_this.loading) {
									_this.fetchMoreRepos();
								}
							}
						});
					});
				}
			},
			onFilterChange: {
				value: function onFilterChange() {
					this.continueState = null;
					this.fetchAllRepoList();
				}
			},
			fetchAllRepoList: {
				value: function fetchAllRepoList(init) {
					var _this = this;
	
					this.loading = true;
					this.noReposToFetch = false;
					if (this.scrollParent) {
						this.scrollParent.scrollTop(0);
					}
					var payload = {
						type: "root",
						byRepoKey: this.repoFilter || "",
						repositoryTypes: ["LOCAL", "VIRTUAL", "REMOTE"] };
					this.treeBrowserDao.getSetMeUpRepos(payload).then(function (repos) {
						if (init) {
							_this.setOnScroll();
						}
						var filteredRepos = _.map(_.filter(repos, function (repo) {
							return repo.repoType !== "trash" && repo.repoType !== "supportBundles" && repo.repoType !== "distribution" && repo.repoKey !== "_intransit";
						}), function (repo) {
							var packageType = _.find(_this.packageTypes, { serverEnumName: repo.repoPkgType });
							if (packageType) repo.icon = packageType.icon;
							return repo;
						});
	
						_this.repos = filteredRepos;
						_this.continueState = repos.continueState;
						_this.loading = false;
						_this.$widgetObject.showSpinner = false;
					});
				}
			},
			fetchMoreRepos: {
				value: function fetchMoreRepos() {
					var _this = this;
	
					if (this.noReposToFetch) {
						return;
					}this.loading = true;
					var payload = {
						type: "root",
						byRepoKey: this.repoFilter || "",
						repositoryTypes: ["LOCAL", "VIRTUAL", "REMOTE"] };
	
					if (this.continueState) {
						_.assign(payload, { continueState: this.continueState });
					}
	
					this.treeBrowserDao.getSetMeUpRepos(payload).then(function (repos) {
						var _repos;
	
						if (!repos.continueState) {
							_this.noReposToFetch = true;
							return;
						}
	
						var filteredRepos = _.map(_.filter(repos, function (repo) {
							return repo.repoType !== "trash" && repo.repoType !== "supportBundles" && repo.repoType !== "distribution" && repo.repoKey !== "_intransit";
						}), function (repo) {
							var packageType = _.find(_this.packageTypes, { serverEnumName: repo.repoPkgType });
							if (packageType) repo.icon = packageType.icon;
							return repo;
						});
						(_repos = _this.repos).push.apply(_repos, _toConsumableArray(filteredRepos));
						_this.continueState = repos.continueState;
						_this.loading = false;
						_this.$widgetObject.showSpinner = false;
					});
				}
			},
			showSetMeUp: {
				value: function showSetMeUp(repo) {
					this.GoogleAnalytics.trackEvent("Homepage", "Quick set me up", repo.repoPkgType, null, repo.repoType);
					this.SetMeUpModal.launch(repo, true);
				}
			},
			filterHasNoMatches: {
				value: function filterHasNoMatches() {
					var _this = this;
	
					if (!this.repoFilter) {
						return false;
					}var count = _.filter(this.repos, function (repo) {
						return _.includes(repo.repoKey, _this.repoFilter);
					}).length;
					return count === 0;
				}
			}
		});
	
		return SetMeUpWidgetController;
	})();

/***/ }),
/* 365 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	function oauthErrorConfig($stateProvider) {
	
	    $stateProvider.state("oauth_error", {
	        url: "/oauth_error",
	        parent: "app-layout" });
	}
	
	module.exports = angular.module("oauth_error", []).config(oauthErrorConfig);

/***/ }),
/* 366 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	function notFound404($stateProvider) {
	
	    $stateProvider.state("not_found_404", {
	        url: "/404",
	        templateUrl: "states/not_found_404/not_found_404.html",
	        parent: "app-layout" });
	}
	
	module.exports = angular.module("not_found_404", []).config(notFound404);

/***/ }),
/* 367 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	function forbidden403($stateProvider) {
	
	    $stateProvider.state("forbidden_403", {
	        url: "/403",
	        templateUrl: "states/forbidden_403/forbidden_403.html",
	        parent: "app-layout" });
	}
	
	module.exports = angular.module("forbidden_403", []).config(forbidden403);

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var LoginController = __webpack_require__(369).LoginController;
	
	function loginConfig($stateProvider) {
	    $stateProvider.state("login", {
	        url: "/login?redirectTo",
	        templateUrl: "states/login/login.html",
	        controller: "LoginController as Login",
	        params: { oauthError: null },
	        parent: "login-layout"
	    }).state("logout", {
	        url: "/logout",
	        onEnter: function (JFrogEventBus) {
	            return LoginController.staticLogout(JFrogEventBus, true);
	        },
	        parent: "login-layout"
	    });
	}
	
	module.exports = angular.module("changePassword", []).config(loginConfig).controller("LoginController", LoginController);

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var LoginController = exports.LoginController = (function () {
	    function LoginController($state, $timeout, FooterDao, $stateParams, User, $location, $window, ArtifactoryState, JFrogEventBus, JFrogNotifications, ArtifactoryFeatures, OnBoardingWizard) {
	        var _this = this;
	
	        _classCallCheck(this, LoginController);
	
	        this.user = {};
	        this.rememberMe = false;
	        this.UserService = User;
	        this.$state = $state;
	        this.$stateParams = $stateParams;
	        this.$window = $window;
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.$location = $location;
	        this.ArtifactoryState = ArtifactoryState;
	        this.ArtifactoryFeatures = ArtifactoryFeatures;
	        this.OnBoardingWizard = OnBoardingWizard;
	        this.FooterDao = FooterDao;
	        this.$timeout = $timeout;
	        this.canResetPassword = false;
	        this.canRememberMe = false;
	        this.loginForm = null;
	        this.pending = false;
	
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	
	        var isNotAnonymous = User.currentUser.name !== "anonymous";
	        this.canExit = isNotAnonymous || User.currentUser.anonAccessEnabled;
	
	        this.oauth = {};
	        User.getOAuthLoginData().then(function (response) {
	            _this.oauth.providers = response;
	        });
	
	        if ($stateParams.oauthError) this.errorMessage = $stateParams.oauthError;
	
	        this.checkResetPassword();
	
	        if (angular.isDefined(this.$stateParams.redirectTo)) {
	            this.UserService.loadUser(true).then(function () {
	                // User might be changed after load user
	                isNotAnonymous = User.currentUser.name !== "anonymous";
	                if (isNotAnonymous && _this.isLoggedIn()) {
	                    _this.redirect();
	                }
	            });
	        }
	    }
	
	    _createClass(LoginController, {
	        login: {
	            value: function login() {
	
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED);
	
	                if (this.loginForm.$valid && !this.pending) {
	                    this.pending = true;
	                    this.UserService.login(this.user, this.rememberMe).then(success.bind(this), error.bind(this));
	                }
	
	                function success(result) {
	                    var _this = this;
	
	                    if (this.redirect()) {
	                        return;
	                    }
	
	                    this.pending = false;
	                    var urlAfterLogin = this.ArtifactoryState.getState("urlAfterLogin");
	                    var aolOnboarding = this.ArtifactoryState.getState("aolOnboarding");
	
	                    this.ArtifactoryState.setState("clearErrorsOnStateChange", true);
	
	                    if (aolOnboarding || aolOnboarding === undefined) {
	                        this.ArtifactoryState.setState("onboarding", undefined);
	                        this.OnBoardingWizard.isSystemOnboarding().then(function (onBoarding) {
	                            if (onBoarding) {
	                                _this.$state.go("home").then(function () {
	                                    return _this.OnBoardingWizard.show();
	                                });
	                            } else {
	                                _this.changeUrlWhenNotOnboarding(urlAfterLogin);
	                            }
	                        });
	                    } else {
	                        this.OnBoardingWizard.setInitStatus();
	                        this.changeUrlWhenNotOnboarding(urlAfterLogin);
	                    }
	                }
	
	                function error(response) {
	                    this.pending = false;
	                    if (response.data) {
	                        if (!this.catchExpired(response)) {
	                            this.errorMessage = response.data.feedbackMsg.error;
	                        }
	                    }
	                }
	            }
	        },
	        redirect: {
	            value: function redirect() {
	                var _this = this;
	
	                if (angular.isDefined(this.$stateParams.redirectTo)) {
	                    this.UserService.redirect(this.$stateParams.redirectTo)["catch"](function (err) {
	                        _this.showErrorMessage(err.message || err);
	                    });
	                    return true;
	                }
	
	                return false;
	            }
	        },
	        isRedirecting: {
	            value: function isRedirecting() {
	                return angular.isDefined(this.$stateParams.redirectTo);
	            }
	        },
	        isSSOMode: {
	            value: function isSSOMode() {
	                return !this.ArtifactoryFeatures.isNonCommercial();
	            }
	        },
	        changeUrlWhenNotOnboarding: {
	            value: function changeUrlWhenNotOnboarding(urlAfterLogin) {
	                if (urlAfterLogin) {
	                    this.$location.path(urlAfterLogin);
	                } else {
	                    this.$state.go("home");
	                }
	            }
	        },
	        isLoggedIn: {
	
	            /**
	             * Check if already logged in
	             * */
	
	            value: function isLoggedIn() {
	                return this.UserService.getCurrent().isLoggedIn();
	            }
	        },
	        shouldShowAlreadyLoginMessage: {
	            value: function shouldShowAlreadyLoginMessage() {
	                return this.isLoggedIn() && !this.isRedirecting();
	            }
	        },
	        logOut: {
	
	            /**
	             * Logout is dispatching an event.
	             * The handler also checks if the current state is one of the admin states.
	             * This is done in order to make sure that logout happens only after all open admin states (windows) are closed.
	             * Otherwise the user could be stuck with an unresponsive screen.
	             * */
	
	            value: function logOut() {
	                LoginController.staticLogout(this.JFrogEventBus, "logoutAndLogin");
	            }
	        },
	        goHome: {
	
	            /**
	             * Go to home state
	             * */
	
	            value: function goHome() {
	                this.UserService.$state.go("home");
	            }
	        },
	        catchExpired: {
	            value: function catchExpired(response) {
	                var code = "CREDENTIALS_EXPIRED";
	                if (response.data && response.data.code && response.data.code === code) {
	                    var msg = response.data.feedbackMsg.error;
	                    if (response.data.profileUpdatable) {
	                        this.$state.go("change-password", { username: this.user.user });
	                    } else {
	                        this.showErrorMessage(msg);
	                    }
	                    return true;
	                }
	                return false;
	            }
	        },
	        showErrorMessage: {
	            value: function showErrorMessage(msg) {
	                msg += ".\nPlease contact your system administrator.";
	                this.artifactoryNotifications.create({ error: msg });
	            }
	        },
	        userPasswordChanged: {
	            value: function userPasswordChanged() {
	                this.errorMessage = null;
	            }
	        },
	        checkResetPassword: {
	            value: function checkResetPassword() {
	                var _this = this;
	
	                this.UserService.getLoginData(this.$stateParams.redirectTo).then(function (response) {
	                    _this.canResetPassword = response.forgotPassword;
	                    _this.canRememberMe = response.canRememberMe;
	                    _this.ssoProviderLink = response.ssoProviderLink;
	                    _this.oauthProviderLink = response.oauthProviderLink;
	                });
	            }
	        },
	        gotoForgotPwd: {
	            value: function gotoForgotPwd() {
	                this.$state.go("forgot-password");
	            }
	        },
	        ssoLogin: {
	
	            /*
	                oauthLogin() {
	                    this.$window.open(this.oauthProviderLink,'_self');
	                }
	            */
	
	            value: function ssoLogin() {
	                var _this = this;
	
	                this.UserService.loadUser(true).then(function (user) {
	                    user.name === "anonymous" ? _this.$window.open(_this.ssoProviderLink, "_self") : _this.redirect();
	                });
	            }
	        },
	        isOAuthEnabled: {
	            value: function isOAuthEnabled() {
	                return this.oauth.providers && this.oauth.providers.length > 0;
	            }
	        },
	        onGotoOAuth: {
	            value: function onGotoOAuth() {
	                localStorage.stateBeforeOAuth = this.$state.current.name;
	            }
	        }
	    }, {
	        staticLogout: {
	            value: function staticLogout(JFrogEventBus, confirmDiscard) {
	                JFrogEventBus.dispatch(EVENTS.USER_LOGOUT, confirmDiscard);
	            }
	        }
	    });
	
	    return LoginController;
	})();

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var ChangePasswordController = __webpack_require__(371).ChangePasswordController;
	
	function changePasswordConfig($stateProvider) {
	    $stateProvider.state("change-password", {
	        url: "/change-password",
	        templateUrl: "states/change_password/change_password.html",
	        controller: "ChangePasswordController as ChangePassword",
	        parent: "login-layout",
	        params: { username: "" } });
	}
	
	module.exports = angular.module("login", []).config(changePasswordConfig).controller("ChangePasswordController", ChangePasswordController);

/***/ }),
/* 371 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var ChangePasswordController = exports.ChangePasswordController = (function () {
	    function ChangePasswordController(UserDao, $state, $stateParams) {
	        _classCallCheck(this, ChangePasswordController);
	
	        this.$state = $state;
	        this.userDao = UserDao.getInstance();
	        this.fields = {};
	        this.username = $stateParams.username;
	    }
	
	    _createClass(ChangePasswordController, {
	        passwordsMatch: {
	            value: function passwordsMatch() {
	                return this.fields.newPassword === this.fields.retypeNewPassword;
	            }
	        },
	        change: {
	            value: function change() {
	                var _this = this;
	
	                this.userDao.changePassword({}, {
	                    userName: this.username,
	                    oldPassword: this.fields.oldPassword,
	                    newPassword1: this.fields.newPassword,
	                    newPassword2: this.fields.retypeNewPassword
	                }).$promise.then(function (res) {
	                    if (res.status === 200) {
	                        _this.$state.go("login");
	                    }
	                });
	            }
	        }
	    });
	
	    return ChangePasswordController;
	})();

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var ForgotPasswordController = __webpack_require__(373).ForgotPasswordController;
	
	var ResetPasswordController = __webpack_require__(374).ResetPasswordController;
	
	function forgotPasswordConfig($stateProvider) {
	    $stateProvider.state("forgot-password", {
	        url: "/forgot-password",
	        templateUrl: "states/forgot_password/forgot_password.html",
	        controller: "ForgotPasswordController as ForgotPassword",
	        parent: "login-layout"
	    }).state("reset-password", {
	        url: "/resetpassword?key",
	        templateUrl: "states/forgot_password/reset_password.html",
	        controller: "ResetPasswordController as ResetPassword",
	        parent: "login-layout"
	    });
	}
	
	module.exports = angular.module("forgotPassword", []).config(forgotPasswordConfig).controller("ForgotPasswordController", ForgotPasswordController).controller("ResetPasswordController", ResetPasswordController);

/***/ }),
/* 373 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	var EMAIL_SENT_MESSAGE = "Reset password email was sent. \nDidn't receive it? Contact your system administrator.";
	
	var ForgotPasswordController = exports.ForgotPasswordController = (function () {
	    function ForgotPasswordController($state, User, JFrogNotifications, JFrogEventBus) {
	        _classCallCheck(this, ForgotPasswordController);
	
	        this.user = {};
	        this.UserService = User;
	        this.$state = $state;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.forgotPasswordForm = null;
	        this.message = "";
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	    }
	
	    _createClass(ForgotPasswordController, {
	        forgot: {
	            value: function forgot() {
	                var self = this;
	
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED);
	                if (this.forgotPasswordForm.$valid) {
	                    this.pending = true;
	                    this.UserService.forgotPassword(this.user).then(success, error);
	                } else {
	                    form.user.$dirty = true;
	                }
	
	                function success(result) {
	                    self.pending = false;
	                    self.$state.go("login");
	                    self.artifactoryNotifications.create({ info: EMAIL_SENT_MESSAGE });
	                }
	
	                function error(errors) {
	                    self.pending = false;
	                    self.$state.go("login");
	                }
	            }
	        }
	    });
	
	    return ForgotPasswordController;
	})();

/***/ }),
/* 374 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	var PASSWORD_CHANGED_MESSAGE = "Password changed successfully";
	
	var ResetPasswordController = exports.ResetPasswordController = (function () {
	    function ResetPasswordController($stateParams, User, $state, JFrogNotifications, JFrogEventBus, $timeout) {
	        _classCallCheck(this, ResetPasswordController);
	
	        this.$stateParams = $stateParams;
	        this.userService = User;
	        this.$state = $state;
	        this.key = $stateParams.key;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.JFrogEventBus = JFrogEventBus;
	        this.ResetPasswordForm = null;
	        this.$timeout = $timeout;
	        this.user = {};
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	    }
	
	    _createClass(ResetPasswordController, {
	        resetPassword: {
	            value: function resetPassword() {
	                var self = this;
	
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED);
	
	                if (this.ResetPasswordForm.$valid) {
	                    this.userService.validateKey(this.key).then(success, error);
	                }
	
	                function success(response) {
	                    if (response.data.user) {
	                        self.user.user = response.data.user;
	                        self.userService.resetPassword(self.key, self.user).then(function (response) {
	                            self.artifactoryNotifications.create(response.data);
	                            self.$state.go("login");
	                        });
	                    }
	                }
	
	                function error(errors) {
	                    if (errors.data.error) {
	                        self.artifactoryNotifications.create({ error: errors.data.error });
	                    }
	                }
	            }
	        },
	        checkMatchingPasswords: {
	            value: function checkMatchingPasswords() {
	                var _this = this;
	
	                this.$timeout(function () {
	                    if (_this.ResetPasswordForm.password.$valid && _this.ResetPasswordForm.repeatPassword.$valid) {
	                        _this.JFrogEventBus.dispatch(_this.EVENTS.FORM_CLEAR_FIELD_VALIDATION);
	                    }
	                });
	            }
	        }
	    });
	
	    return ResetPasswordController;
	})();

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var UserProfileController = __webpack_require__(376).UserProfileController;
	
	function config($stateProvider) {
	
	    $stateProvider.state("user_profile", {
	        url: "/profile",
	        parent: "app-layout",
	        templateUrl: "states/user_profile/user_profile.html",
	        controller: "UserProfileController as UserProfile"
	    });
	}
	
	module.exports = angular.module("user_profile", []).config(config).controller("UserProfileController", UserProfileController);

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var TOOLTIPS = _interopRequire(__webpack_require__(107));
	
	var UserProfileController = exports.UserProfileController = (function () {
	    function UserProfileController($state, $scope, UserProfileDao, ArtifactoryFeatures, BintrayDao, SshClientDao, JFrogNotifications, User, JFrogEventBus, ArtifactoryModelSaver, OAuthDao, JFrogGridFactory, JFrogModal, ArtifactoryState) {
	        var _this = this;
	
	        _classCallCheck(this, UserProfileController);
	
	        this.$scope = $scope;
	        this.$state = $state;
	        this.passwordRank = 0;
	        this.userProfileDao = UserProfileDao;
	        this.bintrayDao = BintrayDao.getInstance();
	        this.sshClientDao = SshClientDao;
	        this.artifactoryNotifications = JFrogNotifications;
	        this.User = User;
	        this.currentUser = User.getCurrent();
	        this.JFrogEventBus = JFrogEventBus;
	        this.artifactoryGridFactory = JFrogGridFactory;
	        this.OAuthDao = OAuthDao;
	        this.features = ArtifactoryFeatures;
	        this.ArtifactoryModelSaver = ArtifactoryModelSaver.createInstance(this, ["userInfo"], ["apiKey"]);
	        this.modal = JFrogModal;
	        this.EVENTS = JFrogEventBus.getEventsDefinition();
	
	        this.userInfo = {};
	        this.currentPassword = null;
	        this.showUserApiKey = false;
	        this.showBintrayApiKey = false;
	        this.profileLocked = true;
	
	        this.tooltips = TOOLTIPS.userProfile;
	        this.artifactoryState = ArtifactoryState;
	        this.emailChanged = false;
	
	        // Reloading is necessary since the User object is cached,
	        // and once the session is over the data becomes deprecated
	        this.User.loadUser(true).then(function () {
	            if (_this.currentUser.name == "anonymous") {
	                $state.go("login");
	            }
	            $("body").addClass("load-complete");
	        });
	
	        if (this.User.currentUser.requireProfileUnlock === false && this.User.currentUser.existsInDB) {
	            this.unlock();
	        }
	    }
	
	    _createClass(UserProfileController, {
	        unlock: {
	            value: function unlock() {
	                var _this = this;
	
	                this.userProfileDao.fetch({ password: this.User.currentUser.requireProfileUnlock === true ? this.currentPassword : "" }).$promise.then(function (response) {
	                    _this.userInfo = response.data;
	                    _this.ArtifactoryModelSaver.save();
	                    //console.log(this.userInfo);
	                    _this.profileLocked = false;
	
	                    if (!_this.features.isNonCommercial()) {
	                        _this._initOAuthData();
	                    }
	
	                    _this._getApiKey();
	                });
	            }
	        },
	        _getApiKey: {
	            value: function _getApiKey() {
	                var _this = this;
	
	                if (this.User.currentUser.requireProfileUnlock && this.User.currentUser.requireProfilePassword) {
	                    this.userProfileDao.getApiKey.authenticate({ username: this.currentUser.name, password: this.currentPassword });
	                }
	
	                this.userProfileDao.getApiKey().$promise.then(function (res) {
	                    _this.userInfo.apiKey = res.apiKey;
	                });
	            }
	        },
	        revokeApiKey: {
	            value: function revokeApiKey() {
	                var _this = this;
	
	                this.modal.confirm("Are you sure you want to revoke your API key?").then(function () {
	                    _this.userProfileDao.revokeApiKey.authenticate({ username: _this.currentUser.name, password: _this.currentPassword });
	                    _this.userProfileDao.revokeApiKey().$promise.then(function (res) {
	                        _this._getApiKey();
	                        _this.artifactoryState.removeState("setMeUpUserData");
	                    });
	                });
	            }
	        },
	        regenerateApiKey: {
	            value: function regenerateApiKey() {
	                var _this = this;
	
	                //
	                this.modal.confirm("Are you sure you want to regenerate your API key?").then(function () {
	                    _this.userProfileDao.regenerateApiKey.authenticate({ username: _this.currentUser.name, password: _this.currentPassword });
	                    _this.userProfileDao.regenerateApiKey({ username: _this.currentUser.name }).$promise.then(function (res) {
	                        if (res.apiKey) {
	                            _this.artifactoryNotifications.create({ info: "Successfully regenerated API key" });
	                            _this.userInfo.apiKey = res.apiKey;
	                            var oldSMUUserData = _this.artifactoryState.getState("setMeUpUserData");
	                            if (oldSMUUserData) {
	                                oldSMUUserData.apiKey = _this.userInfo.apiKey;
	                            }
	                        } else {
	                            _this.artifactoryNotifications.create({ error: "Failed to regenerate API key" });
	                        }
	                    });
	                });
	            }
	        },
	        generateApiKey: {
	            value: function generateApiKey() {
	                var _this = this;
	
	                this.userProfileDao.getAndCreateApiKey.authenticate({ username: this.currentUser.name, password: this.currentPassword });
	                this.userProfileDao.getAndCreateApiKey({ username: this.currentUser.name }).$promise.then(function (res) {
	                    if (res.apiKey) {
	                        _this.artifactoryNotifications.create({ info: "Successfully generated API key" });
	                        _this.userInfo.apiKey = res.apiKey;
	                    } else {
	                        _this.artifactoryNotifications.create({ error: "Failed to generate API key" });
	                    }
	                });
	            }
	        },
	        _initOAuthData: {
	            value: function _initOAuthData() {
	                var _this = this;
	
	                this.oauth = {};
	
	                this.User.getOAuthLoginData().then(function (response) {
	                    _this.oauth.providers = response;
	
	                    _this.OAuthDao.getUserTokens().$promise.then(function (data) {
	                        data.forEach(function (providerName) {
	                            var provider = _.find(_this.oauth.providers, { name: providerName });
	                            if (provider) {
	                                provider.binded = true;
	                            }
	                        });
	                    });
	                });
	            }
	        },
	        unbindOAuthProvider: {
	            value: function unbindOAuthProvider(providerName) {
	                var _this = this;
	
	                this.OAuthDao.deleteUserToken({}, { username: this.currentUser.name, provider: providerName }).$promise.then(function (res) {
	                    _this._initOAuthData();
	                });
	            }
	        },
	        onEmailChanged: {
	            value: function onEmailChanged() {
	                this.emailChanged = true;
	            }
	        },
	        save: {
	            value: function save() {
	                var _this = this;
	
	                if (this.userInfo.user.newPassword && this.userInfo.user.newPassword !== this.userInfo.user.retypePassword) {
	                    this.artifactoryNotifications.create({ error: "Passwords do not match" });
	                    return;
	                }
	
	                var params = {
	                    user: {
	                        email: this.userInfo.user.email,
	                        password: this.userInfo.user.newPassword
	                    },
	                    bintray: this.userInfo.bintray,
	                    ssh: this.userInfo.ssh
	                };
	
	                if (this.emailChanged) {
	                    this.artifactoryState.removeState("setMeUpUserData");
	                }
	
	                this.userProfileDao.update(params).$promise.then(function () {
	                    _this.changePassword = false;
	                    _this.clearPasswordFields();
	                    _this.User.reload();
	                    _this.ArtifactoryModelSaver.save();
	                });
	            }
	        },
	        clearPasswordFields: {
	            value: function clearPasswordFields() {
	                delete this.userInfo.user.newPassword;
	                delete this.userInfo.user.retypePassword;
	            }
	        },
	        testBintray: {
	            value: function testBintray() {
	                this.JFrogEventBus.dispatch(this.EVENTS.FORM_SUBMITTED, this.bintrayForm.$name);
	                this.bintrayDao.fetch(this.userInfo.bintray);
	            }
	        },
	        isOAuthEnabled: {
	            value: function isOAuthEnabled() {
	                return this.oauth && this.oauth.providers && this.oauth.providers.length > 0 && this.userInfo.user.realm === "internal";
	            }
	        },
	        onGotoOAuth: {
	            value: function onGotoOAuth() {
	                localStorage.stateBeforeOAuth = this.$state.current.name;
	            }
	        }
	    });
	
	    return UserProfileController;
	})();

/***/ }),
/* 377 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	/**
	 * Created by tomere on 16/03/2017.
	 */
	
	"use strict";
	
	function config($stateProvider) {
	
	  $stateProvider.state("server_error_5XX", {
	    templateUrl: "states/server_error_5XX/server_error_5XX.html",
	    parent: "app-layout" });
	}
	
	module.exports = angular.module("server_error_5XX", []).config(config);

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	"use strict";
	
	var ServerDownController = __webpack_require__(379).ServerDownController;
	
	function config($stateProvider) {
	
	    $stateProvider.state("server_down", {
	        templateUrl: "states/server_down/server_down.html",
	        controller: "ServerDownController as ServerDown"
	    });
	}
	
	module.exports = angular.module("server_down", []).config(config).controller("ServerDownController", ServerDownController);

/***/ }),
/* 379 */
/***/ (function(module, exports) {

	"use strict";
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var ServerDownController = exports.ServerDownController = function ServerDownController(ArtifactoryFeatures) {
	    _classCallCheck(this, ServerDownController);
	
	    this.features = ArtifactoryFeatures;
	    this.productName = this.features.isJCR() ? this.features.getGlobalName() : "JFrog " + this.features.getGlobalName();
	};

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var BaseController = __webpack_require__(381).BaseController;
	
	function baseConfig($stateProvider) {
	  $stateProvider
	  // Base state for all application states
	  .state("app-layout", {
	    url: "",
	    abstract: true,
	    templateUrl: "layouts/application.html",
	    controller: "BaseController as Base"
	  })
	  // Base state for all login related states (login, forgot password, etc.)
	  .state("login-layout", {
	    url: "",
	    abstract: true,
	    templateUrl: "layouts/login.html"
	  });
	}
	
	module.exports = angular.module("base.module", []).config(baseConfig).controller("BaseController", BaseController);

/***/ }),
/* 381 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var BaseController = exports.BaseController = (function () {
	    function BaseController(FooterDao, ArtifactorySidebarDriver, $timeout) {
	        _classCallCheck(this, BaseController);
	
	        this.FooterDao = FooterDao;
	        this.$timeout = $timeout;
	
	        this.getFooterData();
	
	        this.sidebarDriver = ArtifactorySidebarDriver;
	    }
	
	    _createClass(BaseController, {
	        getFooterData: {
	            value: function getFooterData() {
	                var _this = this;
	
	                var force = arguments[0] === undefined ? false : arguments[0];
	
	                // Ensure page is not displayed before we get the footer data
	                this.FooterDao.get(force).then(function (footerData) {
	                    return _this.footerData = footerData;
	                });
	
	                // Check that we have the footer data, solve RTFACT-13069 (Happens inconsistently when restarting server / starting vanilla)
	                this.$timeout(function () {
	                    if (!_this.footerData) {
	                        _this.getFooterData(true);
	                    }
	                }, 100);
	            }
	        }
	    });
	
	    return BaseController;
	})();

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	var SearchStateController = __webpack_require__(383).SearchStateController;
	
	var searchQueryMaker = __webpack_require__(384).searchQueryMaker;
	
	var packageSearch = __webpack_require__(386).packageSearch;
	
	function searchConfig($stateProvider) {
	    $stateProvider.state("search", {
	        url: "/search/{searchType}/{query}",
	        parent: "app-layout",
	        templateUrl: "states/search/search.html",
	        controller: "SearchStateController as SearchController",
	        params: { oauthError: null, fromHome: false } });
	}
	
	module.exports = angular.module("search", []).config(searchConfig).directive("searchQueryMaker", searchQueryMaker).directive("packageSearch", packageSearch).controller("SearchStateController", SearchStateController);

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var EVENTS = _interopRequire(__webpack_require__(49));
	
	var TOOLTIP = _interopRequire(__webpack_require__(107));
	
	var SearchStateController = exports.SearchStateController = (function () {
		function SearchStateController($q, $state, $scope, $window, $stateParams, $compile, $timeout, JFrogNotifications, uiGridConstants, commonGridColumns, ArtifactSearchDao, ArtifactPackageSearchDao, JFrogModal, JFrogGridFactory, FooterDao, RepositoriesDao, ArtifactActions, RepoDataDao, ArtifactActionsDao, BasicConfigDao, User, UserProfileDao, JFrogEventBus, $injector, StashResultsDao, GoogleAnalytics, ArtifactoryFeatures, ArtifactViewSourceDao) {
			var _this = this;
	
			_classCallCheck(this, SearchStateController);
	
			this.$q = $q;
			this.inject = $injector.get;
			this.modal = JFrogModal;
			this.artifactSearchDao = ArtifactSearchDao;
			this.stashResultsDao = StashResultsDao;
			this.repositoriesDao = RepositoriesDao;
			this.notifications = JFrogNotifications;
			this.artifactViewSourceDao = ArtifactViewSourceDao.getInstance();
			this.$state = $state;
			this.$scope = $scope;
			this.$window = $window;
			this.$timeout = $timeout;
			this.$compile = $compile;
			this.$stateParams = $stateParams;
			this.title = "Search Artifacts";
			this.uiGridConstants = uiGridConstants;
			this.commonGridColumns = commonGridColumns;
			this.artifactoryGridFactory = JFrogGridFactory;
			this.artifactActionsDao = ArtifactActionsDao;
			this.actions = ArtifactActions;
			this.repoDataDao = RepoDataDao;
			this.footerDao = FooterDao;
			this.currentUser = User.getCurrent();
			this.userProfileDao = UserProfileDao;
			this.JFrogEventBus = JFrogEventBus;
			this.GoogleAnalytics = GoogleAnalytics;
			this.artifactPackageSearchDao = ArtifactPackageSearchDao;
			this.basicConfigDao = BasicConfigDao;
			this.features = ArtifactoryFeatures;
			this.options = ["quick", "package", "archive", "property", "checksum", "remote", "trash"];
			this.currentSearch = this.$stateParams.searchType || localStorage.lastSearchType || "quick";
			this.resultsMsg = "Search Results";
			this.TOOLTIP = TOOLTIP.artifacts.search;
			this.gridOptions = {};
			this.repoList = [];
			this.query = this.$stateParams.query ? JSON.parse(atob(this.$stateParams.query)) : {};
	
			if (this.features.isConanCE() || this.features.isJCR() || this.features.isEdgeNode()) {
				this.options = _.filter(this.options, function (i) {
					return i != "remote";
				});
			}
	
			this.JFrogEventBus.registerOnScope(this.$scope, EVENTS.REFRESH_PAGE_CONTENT, function () {
				_this.refreshRepoList();
			});
	
			this.packageTypesDefer = $q.defer();
			this._initSearch();
	
			if (localStorage.lastSearchType === "package") {
				this.packageTypesDefer.promise.then(function () {
					if (localStorage.lastPackageSearch) {
						var packageType = _.find(_this.availablePackageTypes, { id: localStorage.lastPackageSearch });
						_this.selectedPackageType = packageType;
					}
					_this.onPackageTypeChange();
				});
			}
	
			//Check if Trash Can search should be available
			this.currentUser = User.getCurrent();
			var trashDisabled = this.footerDao.get().then(function (footerData) {
				if (footerData.trashDisabled || !_this.currentUser.isAdmin()) {
					_this.options.pop();
					if (_this.currentSearch === "trash") _this.currentSearch = "quick";
				}
			});
	
			//Check if jCenter is configured
			if (!this.features.isConanCE() && !this.features.isJCR() && !this.features.isEdgeNode()) {
				this.repositoriesDao.isJcenterRepoConfigured().$promise.then(function () {
					return _this.isJcenterExists = true;
				}, function () {
					return _this.isJcenterExists = false;
				});
			}
	
			// init the query when the search type change
			$scope.$watch(function () {
				return _this.currentSearch;
			}, function () {
	
				_this.updateUrl();
				localStorage.lastSearchType = _this.currentSearch;
	
				if (_this.currentSearch === "package") {
					_this._createPackageSearchColumnsObject();
	
					//Focus on the package type dropdown
					_this.$timeout(function () {
						var e = angular.element($(".package-type-selection").children(".ui-select-container")[0]);
						var c = e.controller("uiSelect");
						c.focusser[0].focus();
	
						_this.onPackageTypeChange();
					});
				} else {
					if (_this.query.selectedPackageType) {
						delete _this.query.selectedPackageType;
						_this.updateUrl();
					}
					_this.refreshGrid();
				}
			});
	
			this._updateStashStatus();
		}
	
		_createClass(SearchStateController, {
			updateUrl: {
				value: function updateUrl() {
					var queryClone = _.cloneDeep(this.query);
					delete queryClone.search;
					this.$state.transitionTo(".", { searchType: this.currentSearch, query: !_.isEmpty(queryClone) ? btoa(JSON.stringify(this.query)) : "" }, { location: this.$stateParams.searchType ? true : "replace", inherit: true, relative: this.$state.$current, notify: false });
				}
			},
			search: {
				value: function search() {
					var _this = this;
	
					this.lastQuery = _.cloneDeep(this.query);
					this.updateUrl();
					this._trackGaEvent(this.currentSearch);
					if (this.currentSearch === "package" && this.query.search !== "gavc") {
						var repos = _.find(this.query.packagePayload, { id: "repo" });
						if (repos && repos.values && repos.values.length === 0) {
							this.notifications.create({ warn: "Select at least one repository to search" });
						} else {
							this.artifactPackageSearchDao.runQuery({}, this._getQueryWithImplicitWildCard(this.query.packagePayload)).$promise.then(function (result) {
								result = result.data;
	
								_.map(result.results, function (result) {
									if (result.extraFields) {
										for (var key in result.extraFields) {
											result["extraField_" + key] = result.extraFields[key].join(", ");
										}
										delete result.extraFields;
									}
								});
	
								_this.resultsMsg = result.message;
								_this.gridOptions.setGridData(result.results);
								_this.results = result.results;
								_this.savedToStash = false;
								if (result.searchExpression) {
									_this.cleanAql = result.searchExpression;
									_this._updateAQL();
									_this.showAQL = false;
									_this.$timeout(function () {
										var showAqlButtonElem = $("#show-aql-button-orig");
										var aqlViewerElem = $("#aql-viewer-orig").clone();
										var gridFilterElem = $("jf-grid-filter");
										var gridActionElem = $(".wrapper-grid-actions");
										var clone = showAqlButtonElem.clone();
										clone.attr("id", "show-aql-button");
										aqlViewerElem.attr("id", "aql-viewer");
										gridFilterElem.append(clone);
										clone.css("display", "block");
										_this.$compile(clone)(_this.$scope);
	
										gridActionElem.after(aqlViewerElem);
										aqlViewerElem.css("display", "block");
										var clipCopyElement = aqlViewerElem.find("jf-clip-copy");
										clipCopyElement.addClass("code-mirror-copy");
										_this.$compile(aqlViewerElem)(_this.$scope);
									});
								}
							});
						}
					} else {
						(function () {
							var payloadQuery = _.cloneDeep(_this.query);
							if (_this.currentSearch === "property") {
								if (payloadQuery.propertySetKeyValues) {
									if (!payloadQuery.propertyKeyValues) payloadQuery.propertyKeyValues = [];
									payloadQuery.propertySetKeyValues.forEach(function (propSet) {
										payloadQuery.propertyKeyValues.push(propSet);
									});
									delete payloadQuery.propertySetKeyValues;
								}
							} else if (_this.currentSearch === "trash") {
								payloadQuery.isChecksum = payloadQuery.isChecksum || false;
							}
	
							if (payloadQuery.selectedRepositories && payloadQuery.selectedRepositories.length == 0) {
								_this.notifications.create({ warn: "Select at least one repository to search" });
								_this.resultsMsg = "Search Results";
								_this.gridOptions.setGridData([]);
								_this.results = [];
							} else {
								_this.artifactSearchDao.fetch(_this._getQueryWithImplicitWildCard(payloadQuery)).$promise.then(function (result) {
									_this.resultsMsg = result.data.message;
									_this.gridOptions.setGridData(result.data.results);
									_this.results = result.data.results;
									_this.savedToStash = false;
								});
							}
						})();
					}
				}
			},
			reSearch: {
				value: function reSearch() {
					this.query = this.lastQuery;
					this.search();
				}
			},
			_getQueryWithImplicitWildCard: {
				value: function _getQueryWithImplicitWildCard(query) {
	
					var getNewVal = function (oldVal) {
	
						if (!oldVal) return oldVal;
	
						oldVal = oldVal.trim();
						var newVal = undefined;
						if (oldVal.startsWith("\"") && oldVal.endsWith("\"")) {
							newVal = oldVal.substr(1, oldVal.length - 2);
						} else if (!oldVal.endsWith("*")) {
							newVal = oldVal + "*";
						} else {
							newVal = oldVal;
						}
	
						return newVal;
					};
	
					var newQuery = _.cloneDeep(query);
	
					if (this.currentSearch === "package") {
						if (newQuery.search === "gavc") {
							newQuery.artifactID = getNewVal(newQuery.artifactID);
							newQuery.classifier = getNewVal(newQuery.classifier);
							newQuery.groupID = getNewVal(newQuery.groupID);
							newQuery.version = getNewVal(newQuery.version);
						} else {
							//standard package search, not gavc
							newQuery.forEach(function (cond) {
								if (cond.id !== "repo") {
									(function () {
										var newVals = [];
										cond.values.forEach(function (val) {
											newVals.push(getNewVal(val));
										});
										cond.values = newVals;
									})();
								}
							});
						}
					} else {
						for (var key in newQuery) {
							var val = newQuery[key];
							if (_.isString(val) && key !== "search") {
								if (!(key === "checksum" || this.currentSearch === "trash" && key === "query" && newQuery.isChecksum)) {
									newQuery[key] = getNewVal(val);
								}
							} else if (key === "propertyKeyValues" || key === "propertySetKeyValues") {
								val.forEach(function (prop) {
									if (prop.key) prop.key = getNewVal(prop.key);
									if (prop.values) {
										for (var i in prop.values) {
											prop.values[i] = getNewVal(prop.values[i]);
										}
									}
								});
							}
						}
					}
	
					return newQuery;
				}
			},
			_updateAQL: {
				value: function _updateAQL() {
					if (this.cleanAql) {
						this.aql = "curl -H 'Content-Type:text/plain' -H 'X-JFrog-Art-Api: <YOUR_API_KEY> -X POST " + this.baseUrl + "/api/search/aql -d '\n" + this.cleanAql + "'";
					}
				}
			},
			_initSearch: {
				value: function _initSearch(params) {
					var _this = this;
	
					this.artifactPackageSearchDao.availablePackages().$promise.then(function (data) {
						data = _.filter(data, function (packageType) {
							return !packageType.id.startsWith("docker") && (!_this.isOss || packageType.id === "gavc");
						});
						var i = 0;
						_.forEach(data, function () {
							if (data[i].displayName === "GAVC") {
								data[i].displayName = "Maven GAVC";
							}
							i++;
						});
						if (!_this.isOss) {
							data.unshift({
								id: "dockerV2",
								icon: "docker",
								displayName: "Docker"
							});
						}
	
						if (_this.features.isConanCE()) {
							data = _.filter(data, function (pack) {
								return pack.id === "conan";
							});
						} else if (_this.features.isJCR()) {
							data = _.filter(data, function (pack) {
								return pack.id === "Docker" || pack.id === "Helm";
							});
						}
	
						_this.availablePackageTypes = _.sortBy(data, function (pack) {
							return pack.displayName;
						});
						_this.packageTypesDefer.resolve();
					});
	
					if (!this.repoList.length) {
						this.refreshRepoList();
					}
	
					if (!this.propertiesOptions) this.getProperties();
	
					if (params && params.params) {
						this.query = JSON.parse(atob(params.params));
	
						if (this.currentSearch === "package") {
							this.packageSearchColumns = this.query.columns;
						}
						this._getGridData();
					} else {
						if (this.currentSearch === "package") {
							this.packageSearchColumns = ["artifact", "path", "repo", "modified"];
						}
					}
	
					this.basicConfigDao.get().$promise.then(function (result) {
						_this.baseUrl = result.baseUrl;
						_this._updateAQL();
					});
					//.authenticate({username: this.currentUser.name, password: this.currentPassword})
					// this.userProfileDao.getApiKey().$promise.then((res)=> {
					// 	this.apiKey = res.apiKey;
					// 	this._updateAQL();
					// });
				}
			},
			refreshRepoList: {
				value: function refreshRepoList() {
					var _this = this;
	
					//            let getFuncName = this.currentSearch === 'package' ? 'getForPackageSearch' : 'getForSearch';
					["getForSearch", "getForPackageSearch"].forEach(function (getFuncName) {
						_this.repoDataDao[getFuncName]().$promise.then(function (result) {
							result.repoTypesList = _.map(result.repoTypesList, function (repo) {
								repo._iconClass = "icon " + (repo.type === "local" ? "icon-local-repo" : repo.type === "remote" ? "icon-remote-repo" : repo.type === "virtual" ? "icon-virtual-repo" : repo.type === "distribution" ? "icon-distribution-repo" : "icon-notif-error");
								return repo;
							});
	
							var dists = _.filter(result.repoTypesList, function (repo) {
								return repo.type === "distribution";
							});
							var locals = _.filter(result.repoTypesList, function (repo) {
								return repo.type === "local";
							});
							var caches = _.filter(result.repoTypesList, function (repo) {
								return repo.type === "remote";
							});
	
							if (getFuncName === "getForSearch") _this.allRepoList = _.cloneDeep(_.union(dists, locals, caches));else if (getFuncName === "getForPackageSearch") _this.allPackageRepoList = _.cloneDeep(_.union(dists, locals, caches));
	
							var lastIncluded = _this.query.selectedRepositories || [];
	
							if (getFuncName === "getForSearch") {
								_this.repoList = _.filter(_this.allRepoList, function (repo) {
									return !_.find(lastIncluded, { repoKey: repo.repoKey });
								});
							} else if (getFuncName === "getForPackageSearch") {
								_this.packageRepoList = _.filter(_this.allPackageRepoList, function (repo) {
									return !_.find(lastIncluded, { repoKey: repo.repoKey });
								});
							}
						});
					});
				}
			},
			_createGrid: {
				value: function _createGrid() {
					if (this.currentSearch === "package" && !this.packageSearchColumns) {
						return;
					}if (this.currentSearch == "remote" || this.currentSearch == "archive") {
						this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setGridData([]);
					} else {
						this.gridOptions = this.artifactoryGridFactory.getGridInstance(this.$scope).setColumns(this._getColumns()).setRowTemplate("default").setMultiSelect().setBatchActions(this._getBatchActions()).setGridData([]);
					}
	
					this.gridOptions.isRowSelectable = function (row) {
						var notRepository = row.entity.relativeDirPath !== "[repo]";
						return notRepository && _.includes(row.entity.actions, "Delete");
					};
				}
			},
			refreshGrid: {
				value: function refreshGrid() {
					var _this = this;
	
					var defer = this.$q.defer();
	
					this.showGrid = false;
					this.$timeout(function () {
						_this._createGrid();
	
						//This is for recalculating grid columns width
						_this.$timeout(function () {
							try {
								window.dispatchEvent(new Event("resize"));
							} catch (e) {
								var resizeEvent = document.createEvent("Event");
								resizeEvent.initEvent("resize", false, true);
								window.dispatchEvent(resizeEvent);
							}
							_this.$timeout(function () {
								_this.showGrid = true;
								_this.resultsMsg = "Search Results";
								defer.resolve();
							});
						});
					});
	
					return defer.promise;
				}
			},
			_getBatchActions: {
				value: function _getBatchActions() {
					var _this = this;
	
					return [{
						icon: "clear",
						name: "Delete",
						callback: function () {
							return _this.bulkDelete(_this.currentSearch === "trash");
						}
					}];
				}
			},
			bulkDelete: {
				value: function bulkDelete(permanent) {
					var _this = this;
	
					var selectedRows = this.gridOptions.api.selection.getSelectedRows();
					permanent = permanent || this.footerDao.getInfo().trashDisabled;
					//console.log(selectedRows);
					// Ask for confirmation before delete and if confirmed then delete bulk of users
					this.modal.confirm("Are you sure you want to " + (permanent ? " <span class=\"highlight-alert\">permanently</span> " : " ") + " delete " + selectedRows.length + " items?").then(function () {
						_this._deleteSingleSelected(selectedRows);
					});
				}
			},
			_deleteSingleSelected: {
				value: function _deleteSingleSelected(rows) {
					var _this = this;
	
					//console.log(rows);
					if (rows.length === this.results.length) {
						//To prevent console error (RTFACT-13554)
						this.gridOptions.api.grouping.clearGrouping();
					}
					var elementsToDelete = _.map(rows, function (row) {
						return {
							name: row.name,
							path: _this.currentSearch === "trash" ? ((row.originRepository + "/" + row.relativeDirPath).split("[root]").join("") + "/" + row.name).split("//").join("/") : row.relativePath,
							repoKey: row.repoKey
						};
					});
					this.artifactSearchDao["delete"]({ artifacts: elementsToDelete }).$promise.then(function () {})["finally"](function () {
						_this.reSearch();
						_this.artifactoryState.setState("refreshTreeNextTime", true);
					});
				}
			},
			_deleteSelected: {
				value: function _deleteSelected(rows, permanent) {
					var _this = this;
	
					permanent = permanent || this.footerDao.getInfo().trashDisabled;
					this.modal.confirm("Are you sure you wish to " + (permanent ? " <span class=\"highlight-alert\">permanently</span> " : " ") + " delete " + rows[0].name + "?").then(function () {
						return _this._deleteSingleSelected(rows);
					});
				}
			},
			_getColumns: {
				value: function _getColumns() {
					var _this = this;
	
					switch (this.currentSearch) {
						case "package":
							{
								return this._getColumnsForPackageSearch(this.packageSearchColumns);
							}
						case "quick":
							{
								return [{
									name: "Artifact",
									displayName: "Artifact",
									field: "name",
									sort: {
										direction: this.uiGridConstants.ASC
									},
									cellTemplate: this.commonGridColumns.downloadableColumn("autotest-quick-artifact"),
									width: "25%",
									customActions: [{
										icon: "icon icon-view",
										tooltip: "View",
										callback: function (row) {
											return _this.viewCodeArtifact(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "View");
										}
									}],
									actions: {
										download: {
											callback: function (row) {
												return _this.downloadSelectedItems(row);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Download");
											}
										}
									}
								}, {
									name: "Path",
									displayName: "Path",
									field: "relativeDirPath",
									allowGrouping: true,
									cellTemplate: "<div class=\"autotest-quick-path ui-grid-cell-contents\">{{ row.entity.relativeDirPath}}</div>",
									width: "40%",
									customActions: [{
										icon: "icon icon-show-in-tree",
										tooltip: "Show In Tree",
										callback: function (row) {
											return _this.showInTree(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "ShowInTree");
										}
									}]
								}, {
									name: "Repository",
									displayName: "Repository",
									field: "repoKey",
									allowGrouping: true,
									cellTemplate: "<div class=\"autotest-quick-repository ui-grid-cell-contents\">{{ row.entity.repoKey}}</div>",
									width: "15%"
								}, {
									name: "Modified",
									displayName: "Modified",
									cellTemplate: "<div class=\"autotest-quick-modified ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
									field: "modifiedDate",
									width: "20%",
									actions: {
										"delete": {
											callback: function (row) {
												return _this._deleteSelected([row]);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Delete");
											}
										}
									}
								}];
							}
						case "archive":
							{
								return [{
									name: "Name",
									displayName: "Name",
									field: "name",
									sort: {
										direction: this.uiGridConstants.ASC
									},
									width: "30%"
								}, {
									name: "Artifact",
									displayName: "Artifact",
									field: "archiveName",
									allowGrouping: true,
									width: "20%",
									customActions: [{
										icon: "icon icon-view",
										tooltip: "View",
										callback: function (row) {
											return _this.viewCodeArtifact(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "View");
										}
									}],
									actions: {
										download: {
											callback: function (row) {
												return _this.downloadSelectedItems(row);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Download");
											}
										}
									}
								}, {
									name: "Artifact Path",
									displayName: "Artifact Path",
									field: "archivePath",
									allowGrouping: true,
									width: "25%",
									customActions: [{
										icon: "icon icon-show-in-tree",
										tooltip: "Show In Tree",
										callback: function (row) {
											return _this.showInTree(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "ShowInTree");
										}
									}]
								}, {
									name: "Repository",
									displayName: "Repository",
									field: "repoKey",
									allowGrouping: true,
									width: "10%"
								}, {
									name: "Modified",
									displayName: "Modified",
									cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
									field: "modifiedDate",
									width: "15%",
									actions: {
										"delete": {
											callback: function (row) {
												return _this._deleteSelected([row]);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Delete");
											}
										}
									}
								}];
							}
						case "gavc":
							{
								return [{
									name: "Artifact",
									displayName: "Artifact",
									field: "name",
									sort: {
										direction: this.uiGridConstants.ASC
									},
									width: "20%",
									customActions: [{
										icon: "icon icon-view",
										tooltip: "View",
										callback: function (row) {
											return _this.viewCodeArtifact(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "View");
										}
									}, {
										icon: "icon icon-show-in-tree",
										tooltip: "Show In Tree",
										callback: function (row) {
											return _this.showInTree(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "ShowInTree");
										}
									}],
									actions: {
										download: {
											callback: function (row) {
												return _this.downloadSelectedItems(row);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Download");
											}
										}
									}
								}, {
									name: "Group ID",
									displayName: "Group ID",
									field: "groupID",
									allowGrouping: true,
									width: "15%"
								}, {
									name: "Artifact ID",
									displayName: "Artifact ID",
									field: "artifactID",
									allowGrouping: true,
									width: "17%"
								}, {
									name: "Version",
									displayName: "Version",
									field: "version",
									allowGrouping: true,
									width: "13%"
								}, {
									name: "Classifier",
									displayName: "Classifier",
									field: "classifier",
									allowGrouping: true,
									width: "10%"
								}, {
									name: "Repository",
									displayName: "Repository",
									field: "repoKey",
									allowGrouping: true,
									width: "10%"
								}, {
									name: "Modified",
									displayName: "Modified",
									cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
									field: "modifiedDate",
									width: "15%",
									actions: {
										"delete": {
											callback: function (row) {
												return _this._deleteSelected([row]);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Delete");
											}
										}
									}
								}];
							}
						case "property":
							{
								return [{
									name: "Item",
									displayName: "Item",
									field: "name",
									sort: {
										direction: this.uiGridConstants.ASC
									},
									width: "25%",
									customActions: [{
										icon: "icon icon-view",
										tooltip: "View",
										callback: function (row) {
											return _this.viewCodeArtifact(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "View");
										}
									}],
									actions: {
										download: {
											callback: function (row) {
												return _this.downloadSelectedItems(row);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Download");
											}
										}
									}
								}, {
									name: "Type",
									displayName: "Type",
									field: "resultType",
									cellTemplate: "<div class=\"ui-grid-cell-contents\">" + "<span jf-tooltip=\"{{ row.entity.resultType }}\" class=\"icon\" ng-class=\"{ 'icon-local-repo': row.entity.resultType === 'Repository', 'icon-folder': row.entity.resultType === 'Directory', 'icon-general': row.entity.resultType === 'File'}\"></span></div>",
									allowGrouping: true,
									width: "8%"
								}, {
									name: "Path",
									displayName: "Path",
									field: "relativeDirPath",
									allowGrouping: true,
									width: "37%",
									customActions: [{
										icon: "icon icon-show-in-tree",
										tooltip: "Show In Tree",
										callback: function (row) {
											return _this.showInTree(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "ShowInTree");
										}
									}]
								}, {
									name: "Repository",
									displayName: "Repository",
									field: "repoKey",
									allowGrouping: true,
									width: "15%"
								}, {
									name: "Modified",
									displayName: "Modified",
									cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
									field: "modifiedDate",
									width: "15%",
									actions: {
										"delete": {
											callback: function (row) {
												return _this._deleteSelected([row]);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Delete");
											}
										}
									}
								}];
							}
						case "checksum":
							{
								return [{
									name: "Artifact",
									displayName: "Artifact",
									field: "name",
									sort: {
										direction: this.uiGridConstants.ASC
									},
									width: "25%",
									customActions: [{
										icon: "icon icon-view",
										tooltip: "View",
										callback: function (row) {
											return _this.viewCodeArtifact(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "View");
										}
									}],
									actions: {
										download: {
											callback: function (row) {
												return _this.downloadSelectedItems(row);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Download");
											}
										}
									}
								}, {
									name: "Path",
									displayName: "Path",
									field: "relativeDirPath",
									allowGrouping: true,
									width: "45%",
									customActions: [{
										icon: "icon icon-show-in-tree",
										tooltip: "Show In Tree",
										callback: function (row) {
											return _this.showInTree(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "ShowInTree");
										}
									}]
								}, {
									name: "Repository",
									displayName: "Repository",
									field: "repoKey",
									allowGrouping: true,
									width: "15%"
								}, {
									name: "Modified",
									displayName: "Modified",
									cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
									field: "modifiedDate",
									width: "15%",
									actions: {
										"delete": {
											callback: function (row) {
												return _this._deleteSelected([row]);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Delete");
											}
										}
									}
								}];
							}
						case "remote":
							{
								return [{
									name: "Name",
									displayName: "Name",
									field: "name",
									sort: {
										direction: this.uiGridConstants.ASC
									},
									width: "20%",
									actions: {
										download: {
											callback: function (row) {
												return _this.downloadSelectedItems(row);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Download");
											}
										}
									}
								}, {
									name: "Path",
									displayName: "Path",
									field: "path",
									customActions: [{
										icon: "icon icon-bintray",
										tooltip: "Show In Bintray",
										callback: function (row) {
											return _this.showInBintray(row);
										}
									}],
									width: "30%"
								}, {
									name: "Package",
									displayName: "Package",
									field: "package",
									width: "25%"
								}, {
									name: "Released",
									displayName: "Released",
									field: "release",
									width: "15%"
								}, {
									name: "Cached",
									displayName: "Cached",
									field: "cached",
									cellTemplate: this.commonGridColumns.booleanColumn("MODEL_COL_FIELD"),
									width: "10%"
								}];
							}
						case "trash":
							{
								return [{
									name: "Artifact",
									displayName: "Artifact",
									field: "name",
									sort: {
										direction: this.uiGridConstants.ASC
									},
									cellTemplate: this.commonGridColumns.downloadableColumn("autotest-trash-artifact"),
									width: "25%",
									customActions: [{
										icon: "icon icon-view",
										tooltip: "View",
										callback: function (row) {
											return _this.viewCodeArtifact(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "View");
										}
									}, {
										icon: "icon icon-trashcan-restore",
										tooltip: "Restore To Original Path",
										callback: function (row) {
											return _this.restoreTrashItem(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "Restore");
										}
									}],
									actions: {
										download: {
											callback: function (row) {
												return _this.downloadSelectedItems(row);
											},
											visibleWhen: function (row) {
												return _.includes(row.actions, "Download");
											}
										}
									}
								}, {
									name: "Original Path",
									displayName: "Original Path",
									field: "relativeDirPath",
									allowGrouping: true,
									cellTemplate: "<div class=\"autotest-trash-origin-path ui-grid-cell-contents\">{{ row.entity.relativeDirPath}}</div>",
									width: "40%",
									customActions: [{
										icon: "icon icon-show-in-tree",
										tooltip: "Show In Tree",
										callback: function (row) {
											return _this.showInTree(row);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "ShowInTree");
										}
									}]
								}, {
									name: "Original Repository",
									displayName: "Original Repository",
									field: "originRepository",
									allowGrouping: true,
									cellTemplate: "<div class=\"autotest-trash-origin-repository ui-grid-cell-contents\">{{ row.entity.originRepository}}</div>",
									width: "15%"
								}, {
									name: "Deleted Time",
									displayName: "Deleted Time",
									cellTemplate: "<div class=\"autotest-trash-deleted ui-grid-cell-contents\">{{ row.entity.deletedTimeString }}</div>",
									field: "deletedTime",
									width: "20%",
									customActions: [{
										icon: "icon icon-clear",
										tooltip: " Delete Permanently ", //Spaces are there to prevent text from splitting to two lines (RTFACT-13526)
										callback: function (row) {
											return _this._deleteSelected([row], true);
										},
										visibleWhen: function (row) {
											return _.includes(row.actions, "Delete");
										} }]
								}];
							}
	
					}
				}
			},
			_createPackageSearchColumnsObject: {
				value: function _createPackageSearchColumnsObject() {
					var _this = this;
	
					this.packageSearchColumnsObject = {
						artifact: {
							name: "Artifact",
							displayName: "Artifact",
							field: "name",
							sort: {
								direction: this.uiGridConstants.ASC
							},
							cellTemplate: this.commonGridColumns.downloadableColumn(),
							width: "25%",
							customActions: [{
								icon: "icon icon-view",
								tooltip: "View",
								callback: function (row) {
									return _this.viewCodeArtifact(row);
								},
								visibleWhen: function (row) {
									return _.includes(row.actions, "View");
								}
							}],
							actions: {
								download: {
									callback: function (row) {
										return _this.downloadSelectedItems(row);
									},
									visibleWhen: function (row) {
										return _.includes(row.actions, "Download");
									}
								}
							}
						},
						path: {
							name: "Path",
							displayName: "Path",
							field: "relativePath",
							allowGrouping: true,
							width: "40%",
							customActions: [{
								icon: "icon icon-show-in-tree",
								tooltip: "Show In Tree",
								callback: function (row) {
									return _this.showInTree(row);
								},
								visibleWhen: function (row) {
									return _.includes(row.actions, "ShowInTree");
								}
							}]
						},
						repo: {
							name: "Repository",
							displayName: "Repository",
							field: "repoKey",
							allowGrouping: true,
							width: "15%"
						},
						modified: {
							name: "Modified",
							displayName: "Modified",
							cellTemplate: "<div class=\"ui-grid-cell-contents\">{{ row.entity.modifiedString }}</div>",
							field: "modifiedDate",
							width: "20%",
							actions: {
								"delete": {
									callback: function (row) {
										return _this._deleteSelected([row]);
									},
									visibleWhen: function (row) {
										return _.includes(row.actions, "Delete");
									}
								}
							}
						},
						groupID: {
							name: "Group ID",
							displayName: "Group ID",
							field: "groupID",
							allowGrouping: true,
							width: "18%"
						},
						artifactID: {
							name: "Artifact ID",
							displayName: "Artifact ID",
							field: "artifactID",
							allowGrouping: true,
							width: "18%"
						},
						version: {
							name: "Version",
							displayName: "Version",
							field: "version",
							allowGrouping: true,
							width: "18%"
						},
						classifier: {
							name: "Classifier",
							displayName: "Classifier",
							field: "classifier",
							allowGrouping: true,
							width: "18%"
						}
					};
				}
			},
			_getColumnsForPackageSearch: {
				value: function _getColumnsForPackageSearch(columns) {
					var _this = this;
	
					var columnsArray = [];
					columns.forEach(function (column) {
						if (!_.includes(column, "*")) {
							columnsArray.push(_.cloneDeep(_this.packageSearchColumnsObject[column]));
						} else {
							var groupable = false;
							var width = undefined;
							if (_.includes(column, "@")) {
								column = column.split("@").join("");
								groupable = true;
							}
							if (_.includes(column, "!")) {
								var _splitted = column.split("!");
								column = _splitted[0];
								width = _splitted[1];
							}
	
							var splitted = column.split("*");
							var field = splitted[0];
							var _name = splitted[1];
							columnsArray.push({
								name: _name,
								displayName: _name,
								field: "extraField_" + field,
								width: width || "18%",
								allowGrouping: groupable
							});
						}
					});
	
					this._normalizeGridColumnWidths(columnsArray);
	
					if (!columnsArray[0].actions) columnsArray[0].actions = {};
					if (!columnsArray[0].actions.download) {
						columnsArray[0].actions.download = {
							callback: function (row) {
								return _this.downloadSelectedItems(row);
							},
							visibleWhen: function (row) {
								return _.includes(row.actions, "Download");
							}
						};
					}
	
					//If no path field add 'show in tree' action to first column
					if (_.findIndex(columnsArray, "name", "Path") < 0) {
						if (!columnsArray[0].customActions) columnsArray[0].customActions = [];
						columnsArray[0].customActions = [{
							icon: "icon icon-show-in-tree",
							tooltip: "Show In Tree",
							callback: function (row) {
								return _this.showInTree(row);
							},
							visibleWhen: function (row) {
								return _.includes(row.actions, "ShowInTree");
							}
						}];
					}
					return columnsArray;
				}
			},
			_normalizeGridColumnWidths: {
				value: function _normalizeGridColumnWidths(columnsArray) {
					var totalWidth = 0;
					for (var key in columnsArray) {
						var obj = columnsArray[key];
						totalWidth += parseInt(obj.width);
					}
					var scale = 100 / totalWidth;
					for (var key in columnsArray) {
						var obj = columnsArray[key];
						var origWidth = parseInt(obj.width);
						obj.width = origWidth * scale + "%";
					}
				}
			},
			showInTree: {
				value: function showInTree(row) {
					var relativePath = undefined;
					var artifactPath = undefined;
					if (this.currentSearch === "trash") {
						relativePath = (row.originRepository + "/" + row.relativeDirPath).split("[root]").join("");
						artifactPath = (row.repoKey + "/" + relativePath + "/" + row.name).split("//").join("/");
					} else {
						relativePath = row.relativePath ? row.relativePath.startsWith("./") ? row.relativePath.substr(2) : row.relativePath : "";
						artifactPath = row.repoKey + "/" + (relativePath || row.path);
					}
	
					var archivePath = "";
					if (row.archiveName) {
						if (row.archivePath === "[root]") {
							row.archivePath = "";
						}
						archivePath = row.repoKey + "/" + row.archivePath + row.archiveName;
					}
					var path = archivePath || artifactPath;
					this.$state.go("artifacts.browsers.path", {
						browser: "tree",
						tab: "General",
						artifact: path
					});
				}
			},
			_updateStashStatus: {
				value: function _updateStashStatus() {
					var _this = this;
	
					this.stashResultsDao.get({ name: "stash" }).$promise.then(function (data) {
						_this.stashedItemsCount = data.length;
						_this.showStashBox = true;
						if (data.length === 0) {
							_this.showStashBox = false;
							_this.savedToStash = false;
						}
					});
				}
			},
			_doStashAction: {
				value: function _doStashAction(action) {
					var _this = this;
	
					var payload = this._buildPayloadForStash();
					this.stashResultsDao[action]({ name: "stash" }, payload).$promise.then(function (response) {
						if (action === "save" && response.status === 200) {
							_this.savedToStash = true;
							_this.duringStashAnimation = false;
						}
						_this._updateStashStatus();
					});
				}
			},
			saveToStash: {
				value: function saveToStash() {
					var _this = this;
	
					this.showStashBox = true;
	
					/*let distanceRight = $('.repo-list-dropdown').width() + $('.repo-list-dropdown').offset().left - $('.repo-dnd-title').width() - $('.repo-dnd-title').offset().left;
	     $('#stash-animation').css('right', distanceRight);*/
					var distanceRight = $(document).width() - $("#stash-results-button").offset().left - $("#stash-results-button").width();
					$("#stash-animation").css({
						right: distanceRight,
						"animation-duration": $(document).width() / 960
					});
	
					this.$timeout(function () {
						_this.duringStashAnimation = true;
						$("#stash-container").addClass("animate");
	
						_this.duringStashAnimation = true;
	
						_this._doStashAction("save");
					});
				}
			},
			addToStash: {
				value: function addToStash() {
					this._doStashAction("add");
				}
			},
			subtractFromStash: {
				value: function subtractFromStash() {
					this._doStashAction("subtract");
				}
			},
			intersectWithStash: {
				value: function intersectWithStash() {
					this._doStashAction("intersect");
				}
			},
			gotoStash: {
				value: function gotoStash() {
					this.JFrogEventBus.dispatch(EVENTS.ACTION_REFRESH_STASH);
					this.$state.go("artifacts.browsers.path", { browser: "stash", artifact: "", tab: "StashInfo" });
				}
			},
			clearStash: {
				value: function clearStash() {
					var _this = this;
	
					this.modal.confirm("Are you sure you want to clear stashed results? All items will be removed from stash.", "Clear Stashed Results", { confirm: "Clear" }).then(function () {
						_this.stashResultsDao["delete"]({ name: "stash" }).$promise.then(function (response) {
							_this.JFrogEventBus.dispatch(EVENTS.ACTION_DISCARD_STASH);
							if (response.status === 200) {
								_this.savedToStash = false;
								_this._updateStashStatus();
								$("#stash-container").removeClass("animate");
							}
						});
					});
				}
			},
			_buildPayloadForStash: {
				value: function _buildPayloadForStash() {
					var searchType = this.currentSearch;
					if (searchType === "checksum") searchType = "quick";
					var selectedRows = this.gridOptions.api.selection.getSelectedRows();
					var rawResults = selectedRows.length ? selectedRows : this.results;
	
					rawResults = _.filter(rawResults, function (result) {
						return !result.resultType || result.resultType == "File";
					});
	
					var payload = _.map(rawResults, function (result) {
						var retObj = {};
						retObj.type = searchType === "archive" ? "class" : searchType;
						retObj.repoKey = result.repoKey;
	
						if (searchType === "archive") {
							if (result.archivePath === "[root]") result.archivePath = "";
							retObj.name = result.name;
							retObj.archivePath = result.archivePath + result.archiveName;
						} else {
							if (result.relativePath === "[root]") result.relativePath = "";
							retObj.relativePath = result.relativePath;
						}
	
						return retObj;
					});
	
					return payload;
				}
			},
			setShowAQL: {
				value: function setShowAQL(show) {
					var _this = this;
	
					this.showAQL = show;
					if (show) {
						(function () {
							var temp = _this.aql;
							_this.aql = "";
							_this.$timeout(function () {
								_this.aql = temp;
							});
						})();
					}
				}
			},
			downloadSelectedItems: {
				value: function downloadSelectedItems(row) {}
			},
			getProperties: {
				value: function getProperties() {
					var _this = this;
	
					this.artifactSearchDao.get({ search: "property", action: "keyvalue" }).$promise.then(function (_propeties) {
						_this.propertiesOptions = _propeties.data;
					});
				}
			},
			showInBintray: {
				value: function showInBintray(row) {
					this.$window.open("https://bintray.com/bintray/jcenter/" + row["package"], "");
				}
			},
			viewCodeArtifact: {
				value: function viewCodeArtifact(row) {
					var _this = this;
	
					var name = row.name;
					if (_.startsWith(name, "./")) {
						name = name.slice(2);
					}
					if (row.archiveName) {
						if (row.archivePath === "[root]") {
							row.archivePath = "";
						}
						this.artifactViewSourceDao.fetch({
							archivePath: row.archivePath + row.archiveName,
							repoKey: row.repoKey,
							sourcePath: name
						}).$promise.then(function (result) {
							_this.modal.launchCodeModal(row.name, result.source, { name: row.type, json: true });
						});
					} else {
						var data = {
							repoKey: row.repoKey,
							path: row.relativePath || row.path
						};
						this.artifactActionsDao.perform({ action: "view" }, data).$promise.then(function (result) {
							_this.modal.launchCodeModal(row.name, result.data.fileContent, { name: row.type, json: true });
						});
					}
				}
			},
			restoreTrashItem: {
				value: function restoreTrashItem(row) {
					var _this = this;
	
					this.actions.perform({ name: "RestoreToOriginalPath" }, {
						data: {
							path: (row.originRepository + "/" + row.relativeDirPath + "/" + row.name).split("[root]").join(""),
							repoKey: row.repoKey
						}
					}).then(function () {
						_this.reSearch();
					});
				}
			},
			getPrettySearchType: {
				value: function getPrettySearchType(type) {
					if (type === "trash") {
						return "Trash Can";
					}if (type === "remote") {
						return "JCenter";
					}if (type === "archive") {
						return "Archive Entries";
					} else {
						return _.capitalize(type);
					}
				}
			},
			createJcenter: {
				value: function createJcenter() {
					var _this = this;
	
					if (!this.currentUser.isAdmin()) {
						this.notifications.create({ warn: "Only an admin user can create repositories." });
						return false;
					}
					this.modal.confirm("A remote repository pointing to JCenter with default configuration values is about to be created.<br/>" + "If you wish to change it's configuration you can do so from the Remote Repositories menu in the Admin section", "Creating JCenter remote repository").then(function () {
						_this.repositoriesDao.createDefaultJcenterRepo().$promise.then(function () {
							return _this.isJcenterExists = true;
						}, function () {
							return "";
						});
					});
				}
			},
			onPackageTypeChange: {
				value: function onPackageTypeChange() {
					var _this = this;
	
					if (this.selectedPackageType) {
						this.$timeout(function () {
							if (_this.packageController) _this.packageController.onPackageTypeChange(_this.selectedPackageType);
						}, 100);
						localStorage.lastPackageSearch = this.selectedPackageType.id;
					}
				}
			},
			_trackGaEvent: {
				value: function _trackGaEvent(searchType) {
					switch (searchType) {
						case "quick":
							if (this.$stateParams.fromHome) {
								this.GoogleAnalytics.trackEvent("Homepage", "Quick search");
								this.$stateParams.fromHome = false;
							} else {
								this.GoogleAnalytics.trackEvent("Search", "Quick");
							}
							break;
						case "package":
							this.GoogleAnalytics.trackEvent("Search", "Package", this.query.selectedPackageType.displayName);
							break;
						case "archive":
							this.GoogleAnalytics.trackEvent("Search", "Archive");
							break;
						case "property":
							this.GoogleAnalytics.trackEvent("Search", "Property");
							break;
						case "checksum":
							this.GoogleAnalytics.trackEvent("Search", "Checksum");
							break;
						case "remote":
							this.GoogleAnalytics.trackEvent("Search", "Remote");
							break;
						case "trash":
							this.GoogleAnalytics.trackEvent("Search", "Trash");
							break;
						default:
							{
								this.GoogleAnalytics.trackEvent("Search", "Unknown");
								break;
							}
					}
				}
			}
		});
	
		return SearchStateController;
	})();

	// refresh the gridData in any case

	//        this.download(row.downloadLink);

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.searchQueryMaker = searchQueryMaker;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var searchDescriptor = _interopRequire(__webpack_require__(385));
	
	var searchQueryMakerController = (function () {
	    function searchQueryMakerController($q, $scope, $stateParams, $timeout) {
	        _classCallCheck(this, searchQueryMakerController);
	
	        this.$q = $q;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.$scope = $scope;
	
	        this.whenGotPropertiesData = $q.defer();
	        this.whenInitiated = $q.defer();
	
	        this.orderIndex = 0;
	        this.initWatchers();
	    }
	
	    _createClass(searchQueryMakerController, {
	        initWatchers: {
	            value: function initWatchers() {
	                var _this = this;
	
	                this.$scope.$watch("queryMaker.searchType", function (newVal, oldVal) {
	                    if (newVal === "package") return;
	                    _this.queryDescriptor = _this.compileQueryDescriptor(_.find(searchDescriptor.searchTypes, function (type) {
	                        return type.searchTypeName.toLowerCase() === newVal.toLowerCase();
	                    }));
	                    _this.refreshAvailableCriteria();
	                    if (!_.isEqual(_this.$stateParams.searchType, _this.searchType)) _this.initQuery();else if (!_.isEmpty(_this.query)) _this.initFromURLQuery();else {
	                        _.extend(_this.query, _this.queryDescriptor.staticPayload);
	                        if (_this.query.search === "property") {
	                            _this.initQuery();
	                        }
	                        _this.whenInitiated.resolve();
	                    }
	
	                    _this.focusField = false;
	                    _this.$timeout(function () {
	                        return _this.focusField = true;
	                    });
	                });
	                this.$scope.$watch("queryMaker.repoList", function (newVal, oldVal) {
	                    if (!newVal.length) return;
	                    _this.whenInitiated.promise.then(function () {
	                        _this.selectionRepoList = _.map(newVal, function (repo) {
	                            return {
	                                text: repo.repoKey,
	                                iconClass: repo._iconClass,
	                                isSelected: _this.inititiatedByURL && _this.query.selectedRepositories ? _this.query.selectedRepositories.indexOf(repo.repoKey) !== -1 : false
	                            };
	                        });
	                        if (_this.inititiatedByURL) delete _this.inititiatedByURL;
	                    });
	                });
	                this.$scope.$watch("queryMaker.propertiesData", function (newVal, oldVal) {
	                    if (newVal) {
	                        _this.transformedPropertiesData = _.cloneDeep(newVal);
	                        _this.transformedPropertiesData.forEach(function (prop) {
	                            if (prop.propertyType === "MULTI_SELECT") {
	                                prop.values = _.map(prop.values, function (val) {
	                                    return {
	                                        text: val,
	                                        isSelected: false
	                                    };
	                                });
	                            }
	                        });
	                        _this.propertySetKeys = _.sortBy(_.map(_this.transformedPropertiesData, "key"));
	                        _this.whenGotPropertiesData.resolve();
	                    }
	                });
	            }
	        },
	        initQuery: {
	            value: function initQuery() {
	                var _this = this;
	
	                for (var key in this.query) delete this.query[key];
	
	                this.queryDescriptor.searchCriteria.forEach(function (criterion) {
	                    if (criterion.multi && !criterion.copy) {
	                        _this.query[criterion.field] = [];
	                        if (criterion["default"] || criterion.visible) _this.query[criterion.field].push({ key: "", values: [] });
	                    }
	                });
	
	                _.extend(this.query, this.queryDescriptor.staticPayload);
	
	                this.whenInitiated.resolve();
	            }
	        },
	        initFromURLQuery: {
	            value: function initFromURLQuery() {
	                var _this = this;
	
	                //        console.log(this.query);
	                this.whenGotPropertiesData.promise.then(function () {
	                    for (var key in _this.query) {
	                        if (key === "search") continue;
	                        var criterion = _.find(_this.queryDescriptor.searchCriteria, { field: key });
	                        if (criterion && criterion.multi && _this.query.search === "property") {
	                            criterion.visible = false;
	                            if (_this.query[key]) {
	                                for (var i in _this.query[key]) {
	                                    if (i > 0) {
	                                        var newCriterion = _this._createMultiCriterionCopy(criterion);
	                                        _this.queryDescriptor.searchCriteria.push(newCriterion);
	                                    } else {
	                                        criterion.visible = true;
	                                    }
	
	                                    if (key === "propertySetKeyValues") {
	                                        (function () {
	                                            var keyVal = _this.query[key][i];
	                                            var propData = _.find(_this.transformedPropertiesData, { key: keyVal.key });
	                                            if (propData.propertyType === "MULTI_SELECT") {
	                                                keyVal.values.forEach(function (val) {
	                                                    var selectionObj = _.find(propData.values, { text: val });
	                                                    if (selectionObj) selectionObj.isSelected = true;
	                                                });
	                                            }
	                                        })();
	                                    }
	                                }
	                            }
	                        } else {
	                            if (criterion && !criterion["default"] && !criterion.multi) criterion.visible = true;
	                        }
	                    }
	
	                    _.extend(_this.query, _this.queryDescriptor.staticPayload);
	
	                    _this.inititiatedByURL = true;
	                    _this.refreshAvailableCriteria();
	                    _this.$timeout(function () {
	                        if (_this.canSearch()) _this.search();
	                    });
	
	                    _this.whenInitiated.resolve();
	                });
	            }
	        },
	        compileQueryDescriptor: {
	            value: function compileQueryDescriptor(descriptor) {
	                descriptor = _.cloneDeep(descriptor);
	                for (var i in descriptor.searchCriteria) {
	                    var criterion = descriptor.searchCriteria[i];
	
	                    if (_.isString(criterion)) {
	                        var _global = _.find(searchDescriptor.globalSearchCriteria, { id: criterion });
	                        descriptor.searchCriteria[i] = _.cloneDeep(_global);
	                    } else if (criterion.multi) {
	                        criterion.index = 0;
	                        criterion.nextIndex = criterion["default"] || criterion.visible ? 1 : 0;
	                        if (criterion["default"]) {
	                            criterion["default"] = false;
	                            criterion.visible = true;
	                        }
	                    }
	                    descriptor.searchCriteria[i].order = this.orderIndex;
	                    this.orderIndex++;
	                }
	                return descriptor;
	            }
	        },
	        refreshAvailableCriteria: {
	            value: function refreshAvailableCriteria() {
	                this.availableCriteria = this.queryDescriptor ? _.filter(this.queryDescriptor.searchCriteria, function (criterion) {
	                    return !criterion["default"] && !criterion.visible || criterion.multi && !criterion.copy;
	                }) : [];
	            }
	        },
	        onRepoSelectionChange: {
	            value: function onRepoSelectionChange(criterion) {
	                var selectedRepos = _.filter(this.selectionRepoList, function (repo) {
	                    return repo.isSelected;
	                });
	                this.query[criterion.field] = _.map(selectedRepos, "text");
	            }
	        },
	        onAddCriteria: {
	            value: function onAddCriteria() {
	                var _this = this;
	
	                if (this.criterionToAdd.id === "limitRepo") {
	                    this.openLimitDropDown = true;
	                } else {
	                    this.openLimitDropDown = false;
	                }
	
	                if (this.criterionToAdd.multi) {
	                    (function () {
	                        var newCriterion = _this._createMultiCriterionCopy(_this.criterionToAdd);
	                        _this.queryDescriptor.searchCriteria.push(newCriterion);
	                        if (!_this.query[newCriterion.field]) _this.query[newCriterion.field] = [];
	                        _this.query[newCriterion.field].push({ key: "", values: [] });
	
	                        newCriterion.order = _this.orderIndex;
	
	                        newCriterion.autofocus = true;
	                        _this.$timeout(function () {
	                            newCriterion.autofocus = false;
	                        }, 500);
	
	                        _this.orderIndex++;
	                    })();
	                } else {
	                    (function () {
	                        _this.criterionToAdd.order = _this.orderIndex;
	                        _this.orderIndex++;
	
	                        _this.criterionToAdd.visible = true;
	
	                        var tempCrit = _this.criterionToAdd;
	                        tempCrit.autofocus = true;
	                        _this.$timeout(function () {
	                            tempCrit.autofocus = false;
	                        }, 500);
	
	                        if (_this.criterionToAdd.type === "boolean") {
	                            _this.query[_this.criterionToAdd.field] = true;
	                        } else if (_this.criterionToAdd.id === "limitRepo") {
	                            _this.query.selectedRepositories = [];
	                        }
	                    })();
	                }
	                this.criterionToAdd = null;
	                this.refreshAvailableCriteria();
	            }
	        },
	        _createMultiCriterionCopy: {
	            value: function _createMultiCriterionCopy(orig) {
	                var newCriterion = _.cloneDeep(orig);
	                newCriterion["default"] = false;
	                newCriterion.visible = true;
	                newCriterion.copy = true;
	                newCriterion.index = orig.nextIndex;
	                orig.nextIndex++;
	                delete newCriterion.nextIndex;
	                return newCriterion;
	            }
	        },
	        clearMultiValPropSetSelectedValues: {
	            value: function clearMultiValPropSetSelectedValues(criterion) {
	                if (criterion.multi && criterion.type === "keyValSet" && this.query[criterion.field][criterion.index]) {
	                    var propSet = this.getPropertySetByKey(this.query[criterion.field][criterion.index].key);
	                    if (propSet && propSet.propertyType === "MULTI_SELECT") {
	                        propSet.values.forEach(function (val) {
	                            val.isSelected = false;
	                        });
	                    }
	                }
	            }
	        },
	        removeCriterion: {
	            value: function removeCriterion(criterion) {
	                this.clearMultiValPropSetSelectedValues(criterion);
	                if (criterion.multi) {
	
	                    if (criterion.copy) {
	                        var criterionIndex = _.indexOf(this.queryDescriptor.searchCriteria, criterion);
	                        this.queryDescriptor.searchCriteria.splice(criterionIndex, 1);
	                    } else criterion.visible = false;
	
	                    this.queryDescriptor.searchCriteria.forEach(function (crit) {
	                        if (crit.field === criterion.field && crit.multi && crit.copy && crit.index > criterion.index) {
	                            crit.index--;
	                        } else if (crit.field === criterion.field && crit.multi && !crit.copy) {
	                            crit.nextIndex--;
	                        }
	                    });
	                    if (this.query[criterion.field]) this.query[criterion.field].splice(criterion.index, 1);
	                } else {
	                    criterion.visible = false;
	                    delete this.query[criterion.field];
	                    if (criterion.id === "limitRepo") {
	                        _.filter(this.selectionRepoList, function (repo) {
	                            return repo.isSelected;
	                        }).forEach(function (selRepo) {
	                            selRepo.isSelected = false;
	                        });
	                        delete this.query.selectedRepositories;
	                    }
	                }
	                this.refreshAvailablePropertySetKeys();
	                this.refreshAvailableCriteria();
	            }
	        },
	        search: {
	            value: function search() {
	                var _this = this;
	
	                if (!this.canSearch()) {
	                    return;
	                }this.$timeout(function () {
	                    return _this.parentController.search();
	                }, 50);
	            }
	        },
	        getPropertySetByKey: {
	            value: function getPropertySetByKey(key) {
	                return _.find(this.transformedPropertiesData, { key: key });
	            }
	        },
	        onMultiSelectPropertyChange: {
	            value: function onMultiSelectPropertyChange(criterion) {
	                var keyVal = this.query[criterion.field][criterion.index];
	                var values = this.getPropertySetByKey(keyVal.key).values;
	
	                keyVal.values = _.map(_.filter(values, function (val) {
	                    return val.isSelected;
	                }), "text");
	            }
	        },
	        onChangePropertySetKey: {
	            value: function onChangePropertySetKey(criterion) {
	                var keyVal = this.query[criterion.field][criterion.index];
	                keyVal.values = [];
	
	                this.refreshAvailablePropertySetKeys();
	            }
	        },
	        refreshAvailablePropertySetKeys: {
	            value: function refreshAvailablePropertySetKeys() {
	                var _this = this;
	
	                this.propertySetKeys = _.sortBy(_.map(this.transformedPropertiesData, "key"));
	                if (!this.query.propertySetKeyValues || !this.query.propertySetKeyValues.length) {
	                    return;
	                } else {
	                    this.query.propertySetKeyValues.forEach(function (keyVal) {
	                        if (keyVal.key) {
	                            var propType = _this.getPropertySetByKey(keyVal.key).propertyType;
	                            if (propType === "MULTI_SELECT") {
	                                var i = _this.propertySetKeys.indexOf(keyVal.key);
	                                if (i !== -1) {
	                                    _this.propertySetKeys.splice(i, 1);
	                                }
	                            }
	                        }
	                    });
	                }
	            }
	        },
	        canSearch: {
	            value: function canSearch() {
	                return this.form && this.form.$valid && this.isQueryValid();
	            }
	        },
	        isQueryValid: {
	            value: function isQueryValid() {
	                if (this.searchType === "property") {
	                    if ((!this.query.propertyKeyValues || !this.query.propertyKeyValues.length) && (!this.query.propertySetKeyValues || !this.query.propertySetKeyValues.length)) {
	                        return false;
	                    } else if (this.query.propertySetKeyValues && this.query.propertySetKeyValues.length) {
	                        var nullValFound = false;
	                        for (var i in this.query.propertySetKeyValues) {
	                            if (!this.query.propertySetKeyValues[i].key) {
	                                nullValFound = true;
	                                break;
	                            }
	                        }
	                        if (nullValFound) {
	                            return false;
	                        }
	                    }
	                } else if (this.searchType === "archive") {
	                    if (!this.query.name && !this.query.path) {
	                        return false;
	                    }
	                }
	
	                return true;
	            }
	        },
	        clear: {
	            value: function clear() {
	                var _this = this;
	
	                var refreshProps = false;
	                this.queryDescriptor.searchCriteria.forEach(function (criterion) {
	                    _this.clearMultiValPropSetSelectedValues(criterion);
	
	                    if (criterion["default"] || criterion.visible) {
	                        if (criterion.type === "string") {
	                            _this.query[criterion.field] = "";
	                        } else if (criterion.type === "boolean") {
	                            _this.query[criterion.field] = false;
	                        } else if (criterion.type === "array") {
	                            _this.query[criterion.field] = [];
	                            _.filter(_this.selectionRepoList, function (repo) {
	                                return repo.isSelected;
	                            }).forEach(function (selRepo) {
	                                selRepo.isSelected = false;
	                            });
	                        } else if (criterion.type === "keyVal" || criterion.type === "keyValSet") {
	                            _this.query[criterion.field][criterion.index] = { key: "", values: [] };
	                            refreshProps = true;
	                        }
	                    }
	                });
	                if (refreshProps) this.refreshAvailablePropertySetKeys();
	            }
	        }
	    });
	
	    return searchQueryMakerController;
	})();
	
	function searchQueryMaker() {
	    return {
	        restrict: "E",
	        scope: {
	            searchType: "=",
	            query: "=",
	            repoList: "=",
	            propertiesData: "=",
	            parentController: "="
	        },
	        controller: searchQueryMakerController,
	        controllerAs: "queryMaker",
	        bindToController: true,
	        templateUrl: "states/search/search_query_maker.html"
	    };
	}

/***/ }),
/* 385 */
/***/ (function(module, exports) {

	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	"use strict";
	
	module.exports = {
	    globalSearchCriteria: [{
	        id: "limitRepo",
	        label: "Limit to Specific Repositories",
	        field: "selectedRepositories",
	        type: "array",
	        mandatory: false,
	        "default": false
	    }],
	    searchTypes: [{
	        searchTypeName: "Quick",
	        endPoint: "quick",
	        staticPayload: {
	            search: "quick"
	        },
	        searchCriteria: [{
	            label: "Value",
	            field: "query",
	            type: "string",
	            mandatory: true,
	            "default": true
	        }, "limitRepo"]
	    }, {
	        searchTypeName: "Archive",
	        endPoint: "class",
	        staticPayload: {
	            search: "class"
	        },
	        searchCriteria: [{
	            label: "Name",
	            field: "name",
	            type: "string",
	            mandatory: false,
	            "default": true
	        }, {
	            label: "Path",
	            field: "path",
	            type: "string",
	            mandatory: false,
	            "default": false
	        }, {
	            label: "Search Class Resources Only",
	            field: "searchClassOnly",
	            type: "boolean",
	            mandatory: false,
	            "default": false
	        }, {
	            label: "Exclude Inner Classes",
	            field: "excludeInnerClasses",
	            type: "boolean",
	            mandatory: false,
	            "default": false
	        }, "limitRepo"]
	    }, {
	        searchTypeName: "Property",
	        endPoint: "property",
	        staticPayload: {
	            search: "property"
	        },
	        searchCriteria: [{
	            label: "Property",
	            field: "propertyKeyValues",
	            type: "keyVal",
	            multi: true,
	            mandatory: true,
	            "default": true
	        }, {
	            label: "Property Set",
	            field: "propertySetKeyValues",
	            type: "keyValSet",
	            multi: true,
	            mandatory: true,
	            "default": false
	        }, "limitRepo"]
	    }, {
	        searchTypeName: "Checksum",
	        endPoint: "checksum",
	        staticPayload: {
	            search: "checksum"
	        },
	        searchCriteria: [{
	            label: "Checksum",
	            field: "checksum",
	            type: "string",
	            mandatory: true,
	            "default": true
	        }, "limitRepo"]
	    }, {
	        searchTypeName: "Remote",
	        endPoint: "remote",
	        staticPayload: {
	            search: "remote"
	        },
	        searchCriteria: [{
	            label: "Search for",
	            field: "searchKey",
	            type: "string",
	            mandatory: true,
	            "default": true
	        }]
	    }, {
	        searchTypeName: "Trash",
	        endPoint: "trash",
	        staticPayload: {
	            search: "trash"
	        },
	        searchCriteria: [{
	            label: "Query",
	            field: "query",
	            type: "string",
	            mandatory: true,
	            "default": true
	        }, {
	            label: "Checksum Search",
	            field: "isChecksum",
	            type: "boolean",
	            mandatory: false,
	            "default": false
	        }]
	    }]
	};

/***/ }),
/* 386 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	exports.packageSearch = packageSearch;
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var packageSearchController = (function () {
	    function packageSearchController($scope, $state, $stateParams, ArtifactPackageSearchDao, $timeout, $q, ArtifactoryFeatures) {
	        _classCallCheck(this, packageSearchController);
	
	        this.queryFields = [];
	
	        this.$q = $q;
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$stateParams = $stateParams;
	        this.$timeout = $timeout;
	        this.artifactPackageSearchDao = ArtifactPackageSearchDao;
	
	        this.features = ArtifactoryFeatures;
	    }
	
	    _createClass(packageSearchController, {
	        $onInit: {
	            value: function $onInit() {
	                var _this = this;
	
	                this.parentController.packageController = this;
	                this.$scope.$watch("packageSearch.repoList", function (newVal, oldVal) {
	                    if (!newVal || !newVal.length) return;
	                    _this.rawRepos = newVal;
	                    _this.refreshRepoList();
	                });
	                this.init();
	            }
	        },
	        refreshRepoList: {
	            value: function refreshRepoList() {
	                this.selectionRepoList = _.map(this.getFilteredRepoList(this.rawRepos, this.selectedPackageType ? this.selectedPackageType.id : undefined), function (repo) {
	                    return {
	                        text: repo.repoKey,
	                        iconClass: repo._iconClass,
	                        isSelected: false
	                    };
	                });
	            }
	        },
	        init: {
	            value: function init() {
	                var _this = this;
	
	                if (this.query.selectedPackageType) {
	                    this.selectedPackageType = this.query.selectedPackageType;
	
	                    this.onPackageTypeChange().then(function () {
	                        if (_this.query.packagePayload) {
	                            (function () {
	                                var runSearch = false;
	                                _this.query.packagePayload.forEach(function (queryItem) {
	                                    if (_this.rawQuery[queryItem.id]) {
	                                        _this.rawQuery[queryItem.id].values = queryItem.values.join(",");
	                                        var queryField = _.find(_this.queryFields, { id: queryItem.id });
	                                        if (queryField.id !== "repo") runSearch = true;
	                                        if (queryField && !queryField["default"]) {
	                                            if (queryField.id !== "repo") {
	                                                queryField.visible = true;
	                                            } else {
	                                                (function () {
	                                                    var queryRepos = _.find(_this.query.packagePayload, { id: "repo" }).values;
	                                                    if (queryRepos.length) queryField.visible = true;else {
	                                                        var i = _.findIndex(_this.query.packagePayload, { id: "repo" });
	                                                        _this.query.packagePayload.splice(i, 1);
	                                                    }
	
	                                                    _this.selectionRepoList.forEach(function (repo) {
	                                                        if (queryRepos.indexOf(repo.text) !== -1) {
	                                                            repo.isSelected = true;
	                                                        }
	                                                    });
	                                                })();
	                                            }
	                                        }
	                                    }
	                                });
	                                if (_this.query.selectedPackageType.id === "dockerV1") {
	                                    _this.queryFields.push({
	                                        id: "dockerV1",
	                                        displayName: "V1 Images",
	                                        visible: true
	                                    });
	                                }
	                                _this.refreshAvailableCriteria();
	                                _this.onRepoSelectionChange();
	                                if (runSearch) _this.$timeout(function () {
	                                    if (_this.canSearch()) _this.search();
	                                });
	                            })();
	                        } else if (_this.query.selectedPackageType.id === "gavc") {
	                            for (var key in _this.rawQuery) {
	                                _this.rawQuery[key].values = _this.query[key];
	                                var queryField = _.find(_this.queryFields, { id: key });
	                                if (queryField && _this.query[key] && !queryField["default"]) {
	                                    queryField.visible = true;
	                                }
	                            }
	                            _this.$timeout(function () {
	                                if (_this.canSearch()) _this.search();else _this.parentController.refreshGrid();
	                            });
	                        } else _this.parentController.refreshGrid();
	                    });
	                } else {
	                    this.parentController.refreshGrid();
	                }
	
	                this.artifactPackageSearchDao.availablePackages().$promise.then(function (data) {
	                    data = _.filter(data, function (packageType) {
	                        if (_this.features.isJCR()) {
	                            return packageType.id === "helm";
	                        }
	                        return !packageType.id.startsWith("docker") && (!_this.features.isOss() || packageType.id === "gavc");
	                    });
	                    var i = 0;
	                    _.forEach(data, function () {
	                        if (data[i].displayName === "GAVC") {
	                            data[i].displayName = "Maven GAVC";
	                        }
	                        i++;
	                    });
	                    if (!_this.features.isOss()) {
	                        data.unshift({
	                            id: "dockerV2",
	                            icon: "docker",
	                            displayName: "Docker"
	                        });
	                    }
	
	                    _this.availablePackageTypes = _.sortBy(data, function (pack) {
	                        return pack.displayName;
	                    });
	
	                    if (_this.features.isOss() || _this.features.isJCR()) {
	                        _this.parentController.availablePackageTypes = _this.availablePackageTypes;
	                    }
	                });
	            }
	        },
	        onPackageTypeChange: {
	            value: function onPackageTypeChange(selectedPackageType) {
	                var _this = this;
	
	                var defer = this.$q.defer();
	
	                if (selectedPackageType && selectedPackageType === this.selectedPackageType) {
	                    defer.resolve();
	                    return defer.promise;
	                }
	
	                this.rawQuery = {};
	                this.$timeout(function () {
	                    if (selectedPackageType) {
	                        _this.selectedPackageType = selectedPackageType;
	                    } else {
	                        _this.parentController.selectedPackageType = _this.selectedPackageType;
	                    }
	
	                    _this.refreshRepoList();
	
	                    _this.query.selectedPackageType = _this.selectedPackageType;
	                    _this.parentController.updateUrl();
	                    if (_this.selectedPackageType.id === "gavc") {
	                        var gavcFields = [{ id: "groupID", displayName: "Group ID", allowedComparators: "", "default": true }, { id: "artifactID", displayName: "Artifact ID", allowedComparators: "", "default": true }, { id: "version", displayName: "Version", allowedComparators: "", "default": true }, { id: "classifier", displayName: "Classifier", allowedComparators: "", "default": false }, { id: "repo", displayName: "", allowedComparators: "" }];
	                        _this.queryFields = gavcFields;
	
	                        _this.refreshAvailableCriteria();
	
	                        _this.queryFields.forEach(function (field) {
	                            _this.rawQuery[field.id] = { comparator: field.allowedComparators[0] };
	                        });
	                        defer.resolve();
	                    } else {
	                        _this.artifactPackageSearchDao.queryFields({}, { packageType: _this.selectedPackageType.id }).$promise.then(function (data) {
	                            if (_this.selectedPackageType.id === "nuget") {
	                                data = _.filter(data, function (field) {
	                                    return field.id !== "nugetTags" && field.id !== "nugetDigest";
	                                });
	                            } else if (_this.selectedPackageType.id === "dockerV2") {
	                                data = _.filter(data, function (field) {
	                                    return field.id !== "dockerV2TagPath";
	                                });
	                            }
	                            _this.queryFields = data;
	                            _this.queryFields.forEach(function (field) {
	                                field["default"] = field.visibleByDefault;
	                                _this.rawQuery[field.id] = { comparator: field.allowedComparators[0] };
	                            });
	
	                            _this.refreshAvailableCriteria();
	
	                            defer.resolve();
	                        });
	                    }
	                });
	
	                this.focusField = false;
	                this.$timeout(function () {
	                    return _this.focusField = true;
	                });
	
	                return defer.promise;
	            }
	        },
	        _transformQuery: {
	            value: function _transformQuery(rawQuery) {
	                var transformed = undefined;
	                if (this.selectedPackageType.id === "gavc") {
	                    transformed = {};
	                    transformed.search = "gavc";
	                    for (var key in rawQuery) {
	                        if (rawQuery[key].values) {
	                            transformed[key] = rawQuery[key].values || "";
	                        }
	                    }
	                    if (this.selectedRepos) transformed.selectedRepositories = this.selectedRepos;
	                } else {
	                    transformed = [];
	                    for (var key in rawQuery) {
	                        if (rawQuery[key].values) {
	                            if (key !== "repo") transformed.push({
	                                id: key,
	                                /*
	                                 comparator: rawQuery[key].comparator,
	                                 */
	                                values: rawQuery[key].values.split(",")
	                            });
	                        }
	                    }
	                    var repoField = _.find(this.queryFields, { id: "repo" });
	
	                    if (repoField && repoField.visible) transformed.push({
	                        id: "repo",
	                        values: this.selectedRepos || []
	                    });
	                }
	
	                return transformed;
	            }
	        },
	        canSearch: {
	            value: function canSearch() {
	                var ret = false;
	                if (this.rawQuery) {
	                    for (var key in this.rawQuery) {
	                        if (key !== "repo" && this.rawQuery[key].values) {
	                            ret = true;
	                            break;
	                        }
	                    }
	                }
	                return ret;
	            }
	        },
	        search: {
	            value: function search() {
	                var _this = this;
	
	                if (!this.canSearch()) {
	                    return;
	                }var transformedQuery = this._transformQuery(this.rawQuery);
	                for (var key in this.query) delete this.query[key];
	                if (_.isArray(transformedQuery)) {
	                    this.query.packagePayload = transformedQuery;
	                } else {
	                    //gavc
	                    _.extend(this.query, transformedQuery);
	                }
	                this.query.selectedPackageType = this.selectedPackageType;
	                this.parentController.packageSearchColumns = this.getColumnsByPackage();
	                this.parentController.refreshGrid().then(function () {
	                    _this.$timeout(function () {
	                        return _this.parentController.search();
	                    });
	                });
	            }
	        },
	        clear: {
	            value: function clear() {
	                for (var key in this.rawQuery) {
	                    var field = this.rawQuery[key];
	                    if (field.values) delete field.values;
	                }
	
	                _.filter(this.selectionRepoList, function (repo) {
	                    return repo.isSelected;
	                }).forEach(function (repoSel) {
	                    repoSel.isSelected = false;
	                });
	                delete this.selectedRepos;
	            }
	        },
	        getColumnsByPackage: {
	            value: function getColumnsByPackage() {
	
	                switch (this.selectedPackageType.id) {
	                    case "gavc":
	                        return ["artifact", "groupID", "artifactID", "version", "classifier", "repo", "path", "modified"];
	                        break;
	                    case "dockerV1":
	                        return ["dockerV1Image*Image@", "dockerV1Tag*Tag@", "repo", "modified"];
	                        break;
	                    case "dockerV2":
	                        return ["dockerV2Image*Image@", "dockerV2Tag*Tag@", "repo", "modified"];
	                        break;
	                    case "nuget":
	                        return ["nugetPackageId*Package ID", "nugetVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "npm":
	                        return ["npmName*Package Name", "npmVersion*Version@", "npmScope*Scope@", "repo", "path", "modified"];
	                        break;
	                    case "puppet":
	                        return ["puppetName*Name", "puppetVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "bower":
	                        return ["bowerName*Package Name", "bowerVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "debian":
	                        return ["artifact", "repo", "path", "debianDistribution*Distribution@", "debianComponent*Component@", "debianArchitecture*Architecture@", "modified"];
	                        break;
	                    case "pypi":
	                        return ["pypiName*Name", "pypiVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "gems":
	                        return ["gemName*Name", "gemVersion*Version@", "repo", "path", "modified"];
	                        break;
	                    case "rpm":
	                        return ["rpmName*Name", "rpmVersion*Version@", "rpmArchitecture*Architecture@", "repo", "path", "modified"];
	                        break;
	                    case "vagrant":
	                        return ["vagrantName*Box Name", "vagrantVersion*Box Version@", "vagrantProvider*Box Provider@", "repo", "path", "modified"];
	                        break;
	                    case "conan":
	                        return ["conanName*Name@", "conanVersion*Version@", "conanUser*User@", "conanChannel*Channel@", "repo", "modified"];
	                        break;
	                    default:
	                        return ["artifact", "repo", "path", "modified"];
	                }
	            }
	        },
	        refreshAvailableCriteria: {
	            value: function refreshAvailableCriteria() {
	                if (this.queryFields) {
	                    var criteria = _.filter(this.queryFields, function (criterion) {
	                        return !criterion["default"] && !criterion.visible;
	                    });
	
	                    this.availableCriteria = _.map(criteria, function (criterion) {
	                        if (criterion.id === "repo") {
	                            criterion.displayName = "Limit to Specific Repositories";
	                        }
	                        return criterion;
	                    });
	
	                    if (this.selectedPackageType.id === "dockerV2") {
	                        this.availableCriteria.push({
	                            id: "dockerV1",
	                            displayName: "V1 Images"
	                        });
	                    }
	                } else {
	                    this.availableCriteria = [];
	                }
	            }
	        },
	        onAddCriteria: {
	            value: function onAddCriteria() {
	                var _this = this;
	
	                if (this.criterionToAdd.id === "dockerV1") {
	                    //            this.selectedPackageType = _.find(this.availablePackageTypes,{id: 'dockerV1'});
	                    this.selectedPackageType.id = this.criterionToAdd.id;
	                    this.onPackageTypeChange().then(function () {
	                        _this.queryFields.push({
	                            id: "dockerV1",
	                            displayName: "V1 Images",
	                            visible: true
	                        });
	                    });
	                } else if (this.criterionToAdd.id === "repo") {
	                    this.openLimitDropDown = true;
	                    this.selectedRepos = [];
	                } else {
	                    (function () {
	                        var tempCrit = _this.criterionToAdd;
	                        tempCrit.autofocus = true;
	                        _this.$timeout(function () {
	                            tempCrit.autofocus = false;
	                        }, 500);
	                    })();
	                }
	                this.criterionToAdd.visible = true;
	                this.criterionToAdd = null;
	                this.refreshAvailableCriteria();
	            }
	        },
	        removeCriterion: {
	            value: function removeCriterion(criterion) {
	                criterion.visible = false;
	                delete this.rawQuery[criterion.id];
	                if (criterion.id === "repo") {
	                    _.filter(this.selectionRepoList, function (repo) {
	                        return repo.isSelected;
	                    }).forEach(function (selRepo) {
	                        selRepo.isSelected = false;
	                    });
	                    delete this.selectedRepos;
	                } else if (criterion.id === "dockerV1") {
	                    this.selectedPackageType.id = "dockerV2";
	                    this.onPackageTypeChange();
	                }
	
	                this.refreshAvailableCriteria();
	            }
	        },
	        onRepoSelectionChange: {
	            value: function onRepoSelectionChange(criterion) {
	                var selectedRepos = _.filter(this.selectionRepoList, function (repo) {
	                    return repo.isSelected;
	                });
	                this.selectedRepos = _.map(selectedRepos, "text");
	            }
	        },
	        getFilteredRepoList: {
	            value: function getFilteredRepoList(unfiltered, packageType) {
	
	                //        let lastIncluded = this.query.selectedRepositories || [];// (this.$stateParams.searchParams && this.$stateParams.searchParams.selectedRepos) ? this.$stateParams.searchParams.selectedRepos : [];
	
	                if (!packageType) {
	                    return unfiltered;
	                }var filterFunc = function (repo) {
	                    var ret = undefined;
	                    if (packageType.startsWith("docker")) {
	                        if (packageType.endsWith("V1")) ret = repo.repoType.toLowerCase() === "docker" && repo.dockerApiVersion === "V1";else if (packageType.endsWith("V2")) ret = repo.repoType.toLowerCase() === "docker" && repo.dockerApiVersion === "V2";
	                    } else if (packageType === "rpm") {
	                        ret = repo.repoType.toLowerCase() === "yum";
	                    } else if (packageType === "gavc") {
	                        ret = repo.repoType.toLowerCase() === "maven" || repo.repoType.toLowerCase() === "ivy" || repo.repoType.toLowerCase() === "sbt" || repo.repoType.toLowerCase() === "gradle";
	                    } else ret = repo.repoType.toLowerCase() === packageType.toLowerCase();
	
	                    return ret;
	                };
	
	                return _.filter(unfiltered, filterFunc);
	            }
	        }
	    });
	
	    return packageSearchController;
	})();
	
	function packageSearch() {
	    return {
	        restrict: "E",
	        scope: {
	            query: "=",
	            parentController: "=",
	            repoList: "="
	        },
	        controller: packageSearchController,
	        controllerAs: "packageSearch",
	        bindToController: true,
	        templateUrl: "states/search/package_search.html"
	    };
	}

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var PackagesNativeController = _interopRequire(__webpack_require__(388));
	
	var MODULE_PACKAGE_NATIVE = "packages";
	
	exports.MODULE_PACKAGE_NATIVE = MODULE_PACKAGE_NATIVE;
	function NativeConfig($stateProvider) {
	    $stateProvider.state({
	        name: "packagesNative",
	        url: "/packages/{subRouterPath:JFrogSubRouterPath}",
	        controller: "PackagesNativeController",
	        controllerAs: "$ctrl",
	        template: __webpack_require__(390),
	        parent: "app-layout" });
	}
	
	angular.module(MODULE_PACKAGE_NATIVE, []).config(NativeConfig).controller("PackagesNativeController", PackagesNativeController);

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	/*
	 *
	 * Artifactory is a binaries repository manager.
	 * Copyright (C) 2018 JFrog Ltd.
	 *
	 * Artifactory is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU Affero General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 *  (at your option) any later version.
	 *
	 * Artifactory is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU Affero General Public License for more details.
	 *
	 * You should have received a copy of the GNU Affero General Public License
	 * along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.
	 *
	 */
	
	var _ = _interopRequire(__webpack_require__(254));
	
	var field_options = _interopRequire(__webpack_require__(135));
	
	var _packagesMdsDaoAdapter = __webpack_require__(389);
	
	var packagesFieldsAdapter = _packagesMdsDaoAdapter.packagesFieldsAdapter;
	var versionsFieldsAdapter = _packagesMdsDaoAdapter.versionsFieldsAdapter;
	var versionExtraInfoAdapter = _packagesMdsDaoAdapter.versionExtraInfoAdapter;
	
	var PackagesNativeController = (function () {
	    function PackagesNativeController($state, $scope, PackagesDAO, $q, FooterDao, ArtifactoryFeatures, User, ArtifactoryStorage) {
	        var _this = this;
	
	        _classCallCheck(this, PackagesNativeController);
	
	        this.$state = $state;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.packagesDAO = PackagesDAO;
	        this.footerDao = FooterDao;
	        this.artifactoryStorage = ArtifactoryStorage;
	        this.useMdsApi = null;
	
	        this.mdsCache = {
	            packages: null,
	            versions: null
	        };
	
	        if (User.currentUser.name === "anonymous" && !User.currentUser.anonAccessEnabled) {
	            $state.go("login");
	            return;
	        }
	        if (ArtifactoryFeatures.isOss()) {
	            $state.go("home");
	            return;
	        }
	
	        this.disabledPackageTypes = [];
	        // if (!localStorage._enableNativeNpm) this.disabledPackageTypes.push('npm');
	
	        if (ArtifactoryFeatures.isJCR()) {
	            this.disabledPackageTypes.push("npm");
	        }
	
	        var mdsApiSwitcher = function (functionName) {
	            return _this.$q(function (resolve, reject) {
	                _this.isMdsEnabled().then(function (isMdsEnabled) {
	                    if (isMdsEnabled && _this["" + functionName + "Mds"] && _.isFunction(_this["" + functionName + "Mds"])) {
	                        resolve(_this["" + functionName + "Mds"].bind(_this));
	                    }
	                    resolve(_this[functionName].bind(_this));
	                });
	            });
	        };
	
	        this.hostData = {
	            getPackageTypes: function () {
	                return _this.getPackageTypes();
	            },
	            isXrayEnabled: function () {
	                return _this.isXrayEnabled();
	            },
	            // showExtraInfo: () => mdsApiSwitcher('showExtraInfo')(),
	            showExtraInfo: function () {
	                return _this.showExtraInfo();
	            },
	
	            getRepos: function (params) {
	                return _this.getRepos(params);
	            },
	            getPackages: function (params) {
	                return mdsApiSwitcher("getPackages").then(function (fn) {
	                    return fn(params);
	                });
	            },
	            getPackagesCount: function (params) {
	                return _this.getPackagesCount(params);
	            },
	            getPackage: function (params) {
	                return mdsApiSwitcher("getPackage").then(function (fn) {
	                    return fn(params);
	                });
	            },
	            // getVersion: (params) => mdsApiSwitcher('getVersion')(params),
	            getVersion: function (params) {
	                return _this.getVersion(params);
	            },
	            getVersionData: function (params) {
	                return _this.getVersionData(params);
	            },
	            getPackageExtraInfo: function (params) {
	                return mdsApiSwitcher("getPackageExtraInfo").then(function (fn) {
	                    return fn(params);
	                });
	            },
	            getVersionExtraInfo: function (params) {
	                return mdsApiSwitcher("getVersionExtraInfo").then(function (fn) {
	                    return fn(params);
	                });
	            },
	            getPackageSummary: function (params) {
	                return _this.getPackageSummary(params);
	            },
	            getVersionSummary: function (params) {
	                return _this.getVersionSummary(params);
	            },
	            getPackageSummaryExtraInfo: function (params) {
	                return mdsApiSwitcher("getPackageSummaryExtraInfo").then(function (fn) {
	                    return fn(params);
	                });
	            },
	            getVersionSummaryExtraInfo: function (params) {
	                return mdsApiSwitcher("getVersionSummaryExtraInfo").then(function (fn) {
	                    return fn(params);
	                });
	            },
	            getPackageDownloadsCount: function (params) {
	                return mdsApiSwitcher("getPackageDownloadsCount").then(function (fn) {
	                    return fn(params);
	                });
	            },
	            getVersionDownloadsCount: function (params) {
	                return mdsApiSwitcher("getVersionDownloadsCount").then(function (fn) {
	                    return fn(params);
	                });
	            },
	            getManifest: function (params) {
	                return _this.getManifest(params);
	            },
	
	            cancelPackageExtraInfo: function () {
	                return _this.cancelPackageExtraInfo();
	            },
	            cancelVersionExtraInfo: function () {
	                return _this.cancelVersionExtraInfo();
	            },
	
	            showInTree: function (params) {
	                return _this.showInTree(params);
	            } };
	    }
	
	    _createClass(PackagesNativeController, {
	        getPackageTypes: {
	            value: function getPackageTypes() {
	                var defferd = this.$q.defer();
	                var pkgTypes = field_options.repoPackageTypes.map(function (t) {
	                    return {
	                        value: t.value,
	                        displayText: t.text,
	                        iconClass: "icon-" + t.icon
	                    };
	                });
	                defferd.resolve(pkgTypes);
	                return defferd.promise;
	            }
	        },
	        getPackages: {
	            value: function getPackages(params) {
	                return this.packagesDAO.getPackages(params.pathAndQuery, params.payload).$promise;
	            }
	        },
	        getPackagesMds: {
	            value: function getPackagesMds(params) {
	                var _this = this;
	
	                return this.$q(function (resolve, reject) {
	                    _this.packagesDAO.getPackagesMds(params.pathAndQuery, params.payload).$promise.then(function (res) {
	                        _this.mdsCache.packages = res.packages;
	                        var packagesAdapted = packagesFieldsAdapter(res);
	                        resolve(packagesAdapted);
	                    })["catch"](function (e) {
	                        console.log(e);
	                    });
	                });
	            }
	        },
	        getPackagesCount: {
	            value: function getPackagesCount(params) {
	                return this.packagesDAO.getPackagesCount(_.extend(params.pathAndQuery, { $no_spinner: true }), params.payload).$promise;
	            }
	        },
	        getRepos: {
	            value: function getRepos(params) {
	                return this.packagesDAO.getRepos(params.pathAndQuery).$promise;
	            }
	        },
	        getPackage: {
	            value: function getPackage(params) {
	                return this.packagesDAO.getPackage(params.pathAndQuery, params.payload).$promise;
	            }
	        },
	        getPackageMds: {
	            value: function getPackageMds(params) {
	                var _this = this;
	
	                return this.$q(function (resolve, reject) {
	                    var _params$pathAndQuery = params.pathAndQuery;
	                    var packageType = _params$pathAndQuery.packageType;
	                    var packageName = _params$pathAndQuery.packageName;
	
	                    _this.packagesDAO.getPackageMds(params.pathAndQuery, params.payload).$promise.then(function (res) {
	                        var versions = res.versions.filter(function (v) {
	                            return v.pkgid === "" + packageType + ":" + packageName;
	                        });
	
	                        var versionsAdapted = versionsFieldsAdapter(versions, params.pathAndQuery);
	                        _this.mdsCache.versions = versionsAdapted;
	
	                        if (_this.resolvePackageDownloadCount) {
	                            _this.resolvePackageDownloadCount({
	                                totalDownloads: res.versions.length && res.versions[0].stats && res.versions[0].stats.download_count ? res.versions[0].stats.download_count : 0
	                            });
	                            _this.resolvePackageDownloadCount = null;
	                        }
	
	                        resolve(versionsAdapted);
	                    });
	                });
	            }
	        },
	        getPackageSummary: {
	            value: function getPackageSummary(params) {
	                return this.packagesDAO.getPackageSummary(params.pathAndQuery, params.payload).$promise;
	            }
	        },
	        getPackageSummaryExtraInfo: {
	            value: function getPackageSummaryExtraInfo(params) {
	                return this.packagesDAO.getPackageSummaryExtraInfo(_.extend(params.pathAndQuery, { $no_spinner: true }), params.payload).$promise;
	            }
	        },
	        getPackageExtraInfo: {
	            value: function getPackageExtraInfo(params) {
	                if (params.pathAndQuery.packageType === "docker") {
	                    return this.packagesDAO.getDockerPackageExtraInfo(_.extend(params.pathAndQuery, { $no_spinner: true })).$promise;
	                } else {
	                    return this.packagesDAO.getPackageExtraInfo(_.extend(params.pathAndQuery, { $no_spinner: true }), params.payload).$promise;
	                }
	            }
	        },
	        getPackageExtraInfoMds: {
	            value: function getPackageExtraInfoMds(params) {
	                var _this = this;
	
	                return this.$q(function (resolve, reject) {
	                    if (params.pathAndQuery.packageType === "docker") {
	                        if (_this.mdsCache.packages) {
	                            var packageData = _this.getPackageFromCache(params);
	                            if (packageData) {
	                                resolve({
	                                    totalDownloads: packageData.numberOfDownloads || 0,
	                                    totalVersions: packageData.numberOfVersions || 0,
	                                    lastModified: moment(packageData.modified).format("X")
	                                });
	                            }
	                        } else {
	                            return _this.packagesDAO.getDockerPackageExtraInfo(_.extend(params.pathAndQuery, { $no_spinner: true })).$promise.then(function (res) {
	                                return resolve(res);
	                            });
	                        }
	                    } else {
	                        if (_this.mdsCache.packages) {
	                            var packageData = _this.getPackageFromCache(params);
	                            if (packageData.length === 1) {
	                                resolve({
	                                    totalDownloads: packageData[0].downloadCount,
	                                    keywords: packageData.tags
	                                });
	                            }
	                        }
	                        return _this.packagesDAO.getPackageExtraInfo(_.extend(params.pathAndQuery, { $no_spinner: true }), params.payload).$promise.then(function (res) {
	                            return resolve(res);
	                        });
	                    }
	                });
	            }
	        },
	        getPackageFromCache: {
	            value: function getPackageFromCache(params) {
	                var packageData = this.mdsCache.packages.find(function (p) {
	                    return p.name === params.pathAndQuery.packageName;
	                });
	                return packageData;
	            }
	        },
	        getVersionExtraInfo: {
	            value: function getVersionExtraInfo(params) {
	                return this.packagesDAO.getVersionExtraInfo(_.extend(params.pathAndQuery, { $no_spinner: true }), params.payload).$promise;
	            }
	        },
	        getVersionExtraInfoMds: {
	            value: function getVersionExtraInfoMds(params) {
	                var _this = this;
	
	                var _params$pathAndQuery = params.pathAndQuery;
	                var packageName = _params$pathAndQuery.packageName;
	                var packageType = _params$pathAndQuery.packageType;
	                var versionName = _params$pathAndQuery.versionName;
	
	                if (this.mdsCache.packages) {
	                    var _ret = (function () {
	                        var packageData = _this.mdsCache.packages.filter(function (p) {
	                            return p.name === packageName;
	                        });
	                        if (packageData.length === 1) {
	                            return {
	                                v: new Promise(function (resolve, reject) {
	                                    var version = packageData.versions.filter(function (v) {
	                                        return v.name === packageName;
	                                    });
	                                    resolve(versionExtraInfoAdapter(version[0]));
	                                })
	                            };
	                        }
	                    })();
	
	                    if (typeof _ret === "object") {
	                        return _ret.v;
	                    }
	                }
	                if (this.mdsCache.versions) {
	                    return new Promise(function (resolve, reject) {
	                        var version = _this.mdsCache.versions.filter(function (v) {
	                            return v.name === versionName && v.pkgid === "" + packageType + ":" + packageName;
	                        });
	                        resolve(versionExtraInfoAdapter(version[0]));
	                    });
	                }
	                return this.packagesDAO.getVersionExtraInfo(_.extend(params.pathAndQuery, { $no_spinner: true }), params.payload).$promise;
	            }
	        },
	        cancelPackageExtraInfo: {
	            value: function cancelPackageExtraInfo() {
	                this.packagesDAO.$cancelAll("getPackageExtraInfo");
	            }
	        },
	        cancelVersionExtraInfo: {
	            value: function cancelVersionExtraInfo() {
	                this.packagesDAO.$cancelAll("getVersionExtraInfo");
	            }
	        },
	        getPackageDownloadsCount: {
	            value: function getPackageDownloadsCount(params) {
	                return this.packagesDAO.getPackageDownloadsCount(_.extend(params.pathAndQuery, { $no_spinner: true })).$promise;
	            }
	        },
	        getPackageDownloadsCountMds: {
	            value: function getPackageDownloadsCountMds(params) {
	                var _this = this;
	
	                return this.$q(function (resolve, reject) {
	                    _this.resolvePackageDownloadCount = resolve;
	                });
	            }
	        },
	        getVersionDownloadsCount: {
	            value: function getVersionDownloadsCount(params) {
	                return this.packagesDAO.getVersionDownloadsCount(_.extend(params.pathAndQuery, { $no_spinner: true })).$promise;
	            }
	        },
	        getVersionDownloadsCountMds: {
	            value: function getVersionDownloadsCountMds(params) {
	                var _this = this;
	
	                return this.$q(function (resolve, reject) {
	                    if (_this.mdsCache.versions) {
	                        var _params$pathAndQuery = params.pathAndQuery;
	                        var versionName = _params$pathAndQuery.versionName;
	                        var packageName = _params$pathAndQuery.packageName;
	                        var packageType = _params$pathAndQuery.packageType;
	
	                        var version = _this.findVersionByNameTypeVersion(packageType, packageName, versionName);
	                        resolve({
	                            totalDownloads: version.totalDownloads
	                        });
	                    }
	                });
	            }
	        },
	        getManifest: {
	            value: function getManifest(params) {
	                return this.packagesDAO.getManifest(params.pathAndQuery).$promise;
	            }
	        },
	        getVersion: {
	            value: function getVersion(params) {
	                return this.packagesDAO.getVersion(params.pathAndQuery).$promise;
	            }
	        },
	        getVersionMds: {
	            value: function getVersionMds(params) {
	                var _this = this;
	
	                var _params$pathAndQuery = params.pathAndQuery;
	                var versionName = _params$pathAndQuery.versionName;
	                var packageName = _params$pathAndQuery.packageName;
	                var packageType = _params$pathAndQuery.packageType;
	
	                return new Promise(function (resolve, reject) {
	                    if (!_this.mdsCache.versions) {
	                        _this.getPackageMds(params).then(function () {
	                            var versionData = _this.findVersionByNameTypeVersion(packageType, packageName, versionName);
	                            if (versionData) {
	                                return resolve(versionData);
	                            }
	                        });
	                    } else {
	                        var versionData = _this.findVersionByNameTypeVersion(packageType, packageName, versionName);
	                        if (versionData) {
	                            return resolve(versionData);
	                        }
	                    }
	                });
	            }
	        },
	        findVersionByNameTypeVersion: {
	            value: function findVersionByNameTypeVersion(packageType, packageName, versionName) {
	                var versionsKey = packageType === "docker" ? "versions" : "results";
	                return this.mdsCache.versions[versionsKey].find(function (v) {
	                    return v.name === versionName;
	                });
	            }
	        },
	        getVersionData: {
	            value: function getVersionData(params) {
	                return this.packagesDAO.getVersionData(_.extend(params.pathAndQuery, { $no_spinner: true })).$promise;
	            }
	        },
	        getVersionSummary: {
	            value: function getVersionSummary(params) {
	                return this.packagesDAO.getVersionSummary(params.pathAndQuery, params.payload).$promise;
	            }
	        },
	        getVersionSummaryExtraInfo: {
	            value: function getVersionSummaryExtraInfo(params) {
	                return this.packagesDAO.getVersionSummaryExtraInfo(_.extend(params.pathAndQuery, { $no_spinner: true }), params.payload).$promise;
	            }
	        },
	        getVersionSummaryExtraInfoMds: {
	            value: function getVersionSummaryExtraInfoMds(params) {
	                var _this = this;
	
	                return this.$q(function (resolve, reject) {
	                    _this.getPackageMds(params).then(function () {
	                        var _params$pathAndQuery = params.pathAndQuery;
	                        var versionName = _params$pathAndQuery.versionName;
	                        var packageName = _params$pathAndQuery.packageName;
	                        var packageType = _params$pathAndQuery.packageType;
	
	                        var versionData = _this.findVersionByNameTypeVersion(packageType, packageName, versionName);
	                        if (versionData) {
	                            return resolve({
	                                license: versionData.licenses,
	                                numOfDownloads: versionData.stats && versionData.stats.download_count ? versionData.stats.download_count : 0
	                            });
	                        }
	                    });
	                });
	            }
	        },
	        isXrayEnabled: {
	
	            // TODO: When the product team will decide on phase 2 (adding xray) , replace the 'false' value
	
	            value: function isXrayEnabled() {
	                return this.footerDao.get(true).then(function (footerData) {
	                    return footerData.xrayEnabled && footerData.xrayConfigured && footerData.xrayLicense;
	                });
	            }
	        },
	        isMdsEnabled: {
	            value: function isMdsEnabled() {
	                var _this = this;
	
	                return new Promise(function (resolve, reject) {
	                    if (_this.useMdsApi === null) {
	                        return _this.footerDao.get(true).then(function (footerData) {
	                            _this.useMdsApi = !!footerData.mdsPackageNativeUI;
	                            resolve(_this.useMdsApi);
	                        });
	                    } else {
	                        resolve(_this.useMdsApi);
	                    }
	                });
	            }
	        },
	        showExtraInfo: {
	            value: function showExtraInfo() {
	                //		return new Promise.when({showExtraInfo:true})
	                return this.packagesDAO.showExtraInfo().$promise;
	            }
	        },
	        showExtraInfoMds: {
	            value: function showExtraInfoMds() {
	                //		return new Promise.when({showExtraInfo:true})
	                return new Promise(function (res) {
	                    return res({ showExtraInfo: true });
	                });
	            }
	        },
	        showInTree: {
	            value: function showInTree(pathParams) {
	                var browser = this.artifactoryStorage.getItem("BROWSER") || "tree";
	                if (browser === "stash") {
	                    browser = "tree";
	                }
	
	                var path = pathParams.fullpath || "" + pathParams.repo + "/" + pathParams["package"] + "/" + pathParams.version;
	
	                this.$state.go("artifacts.browsers.path", {
	                    tab: "General",
	                    artifact: path,
	                    browser: browser
	                });
	            }
	        }
	    });
	
	    return PackagesNativeController;
	})();
	
	module.exports = PackagesNativeController;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var assign = __webpack_require__(254).assign;
	
	var getRepos = function (versions) {
	    var reposSet = new Set();
	    versions.map(function (v) {
	        v.repos.map(function (r) {
	            reposSet.add(r.name);
	        });
	    });
	    return [].concat(_toConsumableArray(reposSet));
	};
	
	var packagesFieldsAdapter = function (_ref) {
	    var packages = _ref.packages;
	    return {
	        results: packages.map(function (_ref2) {
	            var name = _ref2.name;
	            var modified = _ref2.modified;
	            var tags = _ref2.tags;
	            var _ref2$numberOfVersions = _ref2.numberOfVersions;
	            var numberOfVersions = _ref2$numberOfVersions === undefined ? 0 : _ref2$numberOfVersions;
	            var stats = _ref2.stats;
	
	            return {
	                name: name,
	                lastModified: moment(modified).format("X"),
	                keywords: tags,
	                numOfVersions: numberOfVersions,
	                totalDownloads: stats && stats.downloads_count ? stats.downloads_count : 0,
	                repositories: null,
	                numOfRepos: null
	            };
	        }),
	        resultsCount: packages.length
	    };
	};
	
	var versionsFieldsAdapter = function (versions, pathAndQuery) {
	    var repositories = getRepos(versions);
	    var packageType = pathAndQuery.packageType;
	    var packageName = pathAndQuery.packageName;
	
	    /*let adaptedVersions= versions.map(v => {
	        return {
	            name: v.name,
	            packageName: packageName,
	            lastModified: moment(v.created).format('X'),
	            downloadCount: v.downloadCount || 0,
	            repositories,
	            repoKey: repositories[0],
	            numOfRepos: repositories.length,
	            latestPath: (v.repos && v.repos.loadFilePath && v.repos.loadFilePath.length) ?
	                    v.repos.loadFilePath[0].leadFilePath : '',
	        }
	    });*/
	
	    if (packageType === "docker") {
	        var adaptedVersions = versions.map(function (v) {
	            return {
	                name: v.name,
	                packageName: packageName,
	                packageId: packageName,
	                totalDownloads: v.stats && v.stats.downloads_count ? v.stats.downloads_count : 0,
	                repoKey: v.repos.length ? v.repos[0].name : "",
	                lastModified: moment(v.created).format("X"),
	                size: 0 };
	        });
	        return {
	            versions: adaptedVersions,
	            packageName: packageName,
	            lastModified: moment(adaptedVersions[0].created).format("X"),
	            resultsCount: adaptedVersions.length
	        };
	    } else {
	        var adaptedVersions = versions.map(function (v) {
	            return {
	                name: v.name,
	                licenses: v.licenses.length ? v.licenses[0] : "",
	                lastModified: moment(v.created).format("X"),
	                numOfRepos: v.repos.map(function (r) {
	                    return r.name;
	                }).length,
	                repositories: v.repos.map(function (r) {
	                    return r.name;
	                }),
	                latestPath: "" + v.repos[0].name + "/" + v.repos[0].leadFilePath,
	                totalDownloads: v.stats && v.stats.downloads_count ? v.stats.downloads_count : 0 };
	        });
	        return {
	            results: adaptedVersions
	        };
	    }
	};
	
	var versionExtraInfoAdapter = function (version) {
	    var versionAdapted = assign({
	        downloadCount: 0
	    }, version);
	    return versionAdapted;
	};
	
	var getPackageTotalDownloads = function (packageData) {
	    return packageData.versions.reduce(function (acc, version) {
	        return acc + version.downloadCount;
	    }, 0);
	};
	
	exports.packagesFieldsAdapter = packagesFieldsAdapter;
	exports.versionsFieldsAdapter = versionsFieldsAdapter;
	exports.versionExtraInfoAdapter = versionExtraInfoAdapter;
	exports.getPackageTotalDownloads = getPackageTotalDownloads;

/***/ }),
/* 390 */
/***/ (function(module, exports) {

	module.exports = "<!--\n  ~ Artifactory is a binaries repository manager.\n  ~ Copyright (C) 2018 JFrog Ltd.\n  ~\n  ~ Artifactory is free software: you can redistribute it and/or modify\n  ~ it under the terms of the GNU Affero General Public License as published by\n  ~ the Free Software Foundation, either version 3 of the License, or\n  ~ (at your option) any later version.\n  ~\n  ~ Artifactory is distributed in the hope that it will be useful,\n  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  ~ GNU Affero General Public License for more details.\n  ~\n  ~ You should have received a copy of the GNU Affero General Public License\n  ~ along with Artifactory.  If not, see <http://www.gnu.org/licenses/>.\n  -->\n<packages-native-component\n        host-data=\"$ctrl.hostData\"\n        disabled-package-types=\"$ctrl.disabledPackageTypes\"\n        id=\"package-native-component\">\n</packages-native-component>"

/***/ })
]);
//# sourceMappingURL=artifactory_states.js.467.map